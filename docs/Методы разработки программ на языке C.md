---
tags:
 - c
 - development
---

# Методы разработки программ на языке _C_

Вольный перевод статьи Дэвида Тёрнера.

## 1. Методы разработки

Важно понимать, что программам необходимо обрабатывать три основных вида "исключений":

 - **ошибки пользователя**, когда на вход подаются невалидные данные;
 - **исчерпание ресурсов**, когда программа пытается получить доступ к разделяемым ресурсам;
 - **внутренние ошибки** ("баги", "висячие" указатели).

Надёжная программа должна детектировать или предотвращать все вышеуказанные состояния и разрешать из _безопасным_ и _разумным_ путём.

_Безопасность_ в данном случае означает, что программа не завершит свою работу "нештатно", не начнёт выводить "мусор" в консоль или окно и не попытается разрешить ситуацию странным способом, навроде создания 64-х уровней вложенных директорий и т.д. Система должна оставаться в стабильном состоянии.

_Разумный_ путь в данном контексте означает, что программа должна предоставлять "фидбек" в случае ошибок пользователя и всегда восстанавливать своё состояние в случае ошибки. Т.е. программа должна _работать штатно_, хоть и ограниченно в возможностях.

Некоторые "баги", например, утечки памяти, не являются исключающим состоянием и не будут далее рассмотрены. Но надёжная программа на _C_ должна предотвращать и подобные ошибки.

Применительно к языку программирования _C_, первые шаги к написанию надёжных программ - это создание большого количества проверок во время исполнения. Вот некоторые техники:

 - __проверка операторов контроля__ для обнаружения невалидных ограничений;
 - __проверка индексации массивов__ где только возможно;
 - __встраивание "магических чисел"__ в объекты для быстрой проверки их типов;
 - __проверка результата__ любого системного вызова или библиотечной функции.

Данные шаги важны для обнаружения исключающих состояний, но по-настоящему трудной задачей является определение того, _как_ их обрабатывать _безопасным_ и _разумным_ путём.

### 1.1. Чрезмерная паранойя

Самая распространённая техника, используемая разработчиками на _C_ - это проверка _всего_ и _везде_. Простыми словами, предполагается, что практически любая функция может выполниться некорректно. При обнаружении ошибки, программа должна выполнить "очистку" и "отмену" текущей операции.

Как следствие, примерно `90%` функций, написанных исходя из указанных выше утверждений, разрабатываются так, что возвращают _код ошибки_ и почти все вызовы функций проверяются на ошибки. Код также должен **явно** удалять/освобождать память объектов/ресурсов, полученных до возникновения ошибки.

Простой пример "небезопасного" кода, где нет проверки исчерпания памяти:

```c
void do_something(...)
{
    char *block1, *block2, *block3;

    block1 = (char *)malloc(1024);
    block2 = (char *)malloc(1024);
    block3 = (char *)malloc(1024);

    ... //do something

    free(block3);
    free(block2);
    free(block1);
}
```

Данный пример может быть изменён с учётом требований к надёжности с использованием "параноидальной" техники:

```c
int do_something(...)
{
    char *block1, *block2, *block3;

    block1 = (char *)malloc(1024);
    if(block1 == NULL)
        return ERR_MALLOC;

    block2 = (char *)malloc(1024);
    if(block2 == NULL)
    {
        free(block1);
        return ERR_MALLOC;
    }

    block3 = (char *)malloc(1024);
    if(block3 == NULL)
    {
        free(block2);
        free(block1);
        return ERR_MALLOC;
    }

    ... //do something

    free(block3);
    free(block2);
    free(block1);

    return ERR_OK;
}
```

Было изменено определение функции (теперь она возвращает код ошибки) и были добавлены соответствующие макросы.

Данная схема проста в реализации и широко используется для системных вызовов и в библиотеках. Тем не менее, существует несколько неудобств:

 - Хрупкость метода, поскольку, если забыть проверить возврат функции, могут возникнуть критические ошибки, которые в будущем будет гораздо сложнее обнаружить, поскольку возникнуть они могут при очень специфичных условиях. Также трудно проверить код, который обрабатывает исключение, поскольку оно не возникает при обычной работе программы.
 - Дополнительный объём исходного кода и потенциальная проблема производительности (большое количество "прыжков" в коде для обработки исключений уменьшает способность компилятора к оптимизации кода).
 - Проблемы с удобочитаемостью.

Простая, но эффективная оптимизация данной техники уменьшает количество кода "очистки". Она состоит из _запоминания истории операции_ для дальнейшего "отката" в _одном месте_. Пример:

```c
int do_something(...)
{
    int error;
    char *block1, *block2, *block3;

    error = ERR_OK;
    block1 = NULL;
    block2 = NULL;
    block3 = NULL;

    block1 = (char *)malloc(1024);
    if(block1 == NULL)
        goto Fail;

    block2 = (char *)malloc(1024);
    if(block2 == NULL)
        goto Fail;

    block3 = (char *)malloc(1024);
    if(block3 == NULL)
        goto Fail;

... //do something

    Exit:
    if(block3)
        free(block3);
    if(block2)
        free(block2);
    if(block1)
        free(block1);

    return error;

    Fail:
    error = ERR_MALLOC;
    goto Exit;
}
```

В примере выше, выделенная память освобождается в одном месте - метка `Exit`. Также можно заметить уменьшение количества вызовов функции `free()`.

Множество надёжных программ, написанных на _C_, реализованы с использованием техники с постоянными проверками (примеры: _XFree86_, _Ghostscript_, _FreeType_ и т. д.). Тем не менее, это не является нормой для большинства разработчиков. К примеру, множество программ используют "свою" версию функции выделения памяти, которая попросту экстренно завершает выполнение программы, когда случается исчерпание памяти. И это не является неожиданностью: поскольку выделение памяти - частая операция, игнорирование её ошибок уменьшает количество проверок на 90% в типичной программе. Возможно, это приемлемо во многих случаях (приложения рабочего стола, инструменты командной строки и т.д.), но неприемлемо для системных библиотек, встраиваемых систем или программ, которые должны быть запущены вне зависимости от наличия ошибок (системные сервисы и "демоны").

### 1.2. Реализация _транзакций_

Есть ещё одна, менее популярная схема, основанная на концептах "коммита" и "отката", используемых в системах **БД**.

Данной схеме не достаёт гибкости, необходимой для разработки крупных проектов, что сокращает количество вариантов для её использования.

Основная идея - это обозначение конкретных операций "транзакциями", которые должны выполняться в виде "всё или ничего". Т.е., в случае, если операция не может быть выполнена корректно, программа должна вернуться к состоянию до начала выполнения операции.

"Параноидальная" схема также может гарантировать тот же уровень безопасности, но схема с использованием "транзакций" делает это совершенно другим способом: при помощи вызовов `setjmp()` и `longjmp()`.

Для каждой транзакции создаётся специальный объект, хранящий "историю" или же "состояние" выполнения операции. Данный "объект состояния" содержит:

 - историю выделения всех ресурсов во время транзакции;
 - буфер перехода, используемый для моментального выхода из одной из функций транзакции, как только обнаружено исключение.

В качестве примера - "псевдокод":

```c
state = new_transaction_state(...);

if(setjmp(state->jumpbuff) == 0)
{
    transaction_function_1(state, ...);
    transaction_function_2(state, ...);
}
else
{
    ...an error occured. Notify the caller, whatever...
}
destroy_transaction_state(state);
```

Описать это можно так:

 - Сначала должен быть создан пустой объект транзакции программой-клиентом.
 - Программа вызывает функцию `setjmp()` для того, чтобы запомнить текущее состояние процессора в "прыжковом" буфере состояния транзакции.
 - Вызов `setjmp()` всегда возвращает `0` при первом вызове. Далее вызываются различные функции, выполняющие транзакцию.
 - Каждая функция в транзакции обновляет состояние в соответствии с созданными ими объектами/выделенными ими ресурсами. Как только замечено исключение в одной из этих функций, сразу же вызывается `longjmp()` для выхода из текущего контекста исполнения и передачи управления в место вызова `setjmp()`, который теперь уже вернёт не-нулевое значение.
 - Если `setjmp()` возвращает не-нулевое значение, предпринимаются действия для обработки ошибок в программе (напр., установка флага ошибки).
 - В конце уничтожается состояние транзакции. Это должно происходить так, что история исполнения "откатывается" в порядке, обратном порядку создания объектов/выделения ресурсов, выполненных во время транзакции.

Основное преимущество данной схемы - отсутствие необходимости возвращать коды ошибок функциям и, соответственно, не нужно проверять возвращаемый функцией результат. Использование `longjmp()`/`setjmp()` гарантирует, что управление будет передано напрямую обработчику, как только исключение будет обнаружено.

Тем не менее, существуют и недостатки:

 - Разработка объекта состояния и его деструктора может быть трудоёмкой. Ключевое слово `volatile` должно быть использовано часто для при определении полей объекта состояния для обеспечения корректного поведения при вызове `longjmp()`.
 - Объект состояния должен быть передан любой функции транзакции, что может являться серьёзным требованием. Использование же глобальных переменных - это плохое решение при разработке, т.к. нет гарантий того, что код не будет использован в нескольких потоках.

Пример:

```c
typedef struct
{
    jmp_buf jump_buffer;
    volatile char *block1;
    volatile char *block2;
    volatile char *block3;
} do_something_state;

//define a simple custom allocator
void *checked_malloc(do_something_state *state, size_t size)
{
    void *p = NULL;

    if(size > 0)
    {
        p = malloc(size);
        if(p == NULL)
//memory exhaustion, jump to error handler
            longjmp(state->jump_buffer, 1);
    }

    return p;
};

int do_something(...)
{
    volatile int error;
    do_something_state state;

    state.block1 = NULL;
    state.block2 = NULL;
    state.block3 = NULL;
    error = ERR_OK;

    if(setjmp(state.jump_buffer) == 0)
    {
//allocate temporaries, notice that we use a custom allocator to do that!
        state.block1 = checked_malloc(&state, 1024);
        state.block2 = checked_malloc(&state, 1024);
        state.block3 = checked_malloc(&state, 1024);
        ... //do something
    }
    else
//an exception was raised...
        error = ERR_MALLOC;

//cleanup
    if(state.block3)
        free(state.block3);
    if(state.block2)
        free(state.block2);
    if(state.block1)
        free(state.block1);

    return error;
};
```

Очевидно, пример выше может быть несколько перегружен, потому что мы хотим "поймать" исключения внутри функции и всегда возвращать код ошибки. Тем не менее, если состояние было имплементировано и создано до вызова функции, её можно было бы упростить:

```c
//our function does not return an error code
void do_something(do_something_state *state, ...)
{
//allocate temporaries, notice that we use a custom allocator to do that!
    state->block1 = checked_malloc(&state, 1024);
    state->block2 = checked_malloc(&state, 1024);
    state->block3 = checked_malloc(&state, 1024);

    ... //do something

//cleanup, that's completely optional but it's always a good idea to destroy temporaries as soon as they're un-needed
    free(state->block3);
    state->block3 = NULL;
    free(state->block2);
    state->block2 = NULL;
    free(state->block1);
    state->block1 = NULL;

    return;
};
```

Данный код не представляет внутри себя "прыжков" для обработки исключений и его структура схожа со структурой "небезопасного" кода.

Заключить можно тем, что схема транзакций полезна в случае с небольшим числом транзакций, которые выполняют относительно сложные операции. Она плохо масштабируется.

Пример использования в проектах: популярные библиотеки _LibPNG_ и _LibJPEG_, которые имлементируют собственные операции "load_image" и "save_image".

### 1.3. Структурированная обработка исключений (Structured Exception Handling, SEH)

Структурированная обработка исключений, к удивлению многих разработчиков, может быть реализована на языке _C_.

Существует некоторое количество портируемых реализаций __SEH__, которые основаны на вызовах `setjmp()`/`longjmp()`. Все они предоставляют специальные макросы (`TRY`, `CATCH`, `THROW` и т.д.) для имитации более современных языков программирования.

```c
TRY
{
//the code that executes here is "protected", i.e. much like with transactions, any exception transfers control to what is between the CATCH and END_CATCH
}
CATCH(exc)
{
//The following is only executed when an exception was thrown. The exception code is in "exc"
    switch(exc)
    {
        case ERR_MALLOC:
        fprintf(stderr, "out of memory\n");
        break;

        default:
        RETHROW(exc);
    }
}
END_CATCH
```

Существует множество путей определения макросов `TRY`, `CATCH` и др., зависящих от используемой подсистемы __SEH__. Тем не менее, все имплементации используют простые принципы:

 - Каждый вызов `TRY` выделяет скрытый, специализированный объект, именуемый "обработчиком исключений", который, помимо прочего, содержит буфер переходов для вызовов "`setjmp()`", которые происходят в макросе `TRY`.
 - "Обработчики исключений" хранятся в односвязном списке. Каждый вызов `TRY` добавляет новый обработчик в список. Каждые вызовы `CATCH` или `END_CATCH` ответственны за удаление обработчика из списка (если исключения не происходит). Это разрешает вкладывать друг в друга блоки `TRY`...`CATCH`.
 - Каждый вызов `THROW` находит текущий обработчик исключений, отвязывает его и использует `longjmp()` с содержащимся в обработчике буфером.

Макросы - это более простой способ использования `setjmp()`/`longjmp()` с поддержкой вложенных транзакций. Тем не менее, есть отличие, состоящее в том, что макросы не очищают выделенных ресурсов. Другими словами, обработчик исключений сам по себе не используется в качестве "состояния транзакции". По этой причине на разработчика возлагается работа по корректной реализации "истории транзакций" и "откатов".

Дополнительно, если в программе несколько потоков, каждый из них должен иметь собственный список обработчиков исключений. Обычно это реализуется с использованием локальных для потока хранилищ с объектами для сохранения текущего обработчика исключений, не переносимого по-умолчанию.

### 1.4. Обработчики исключений со стеком очистки (Cleanup Stack Exception Handling, CSEH)

Поскольку "ручное" управление состояниями транзакций в __SEH__ может быть неудобным (напр., по причине частого использования `volatile`), последняя обозреваемая техника разработана для облегчения данной задачи. Она основана на том, что "история" любой операции может быть имплементирована, как стек.

Во время выполнения программы, "стек очистки" существует для каждого потока. Стек изначально пуст. Как только выделяются ресурсы, программа должны "протолкнуть" их на вершину стека очистки вместе с адресом нужной "функции очистки", которая будет вызвана для освобождения ресурсов при возникновении исключения.

К примеру, если выделен новый блок памяти , он должен быть "протолкнут" вместе с адресом функции `free()`. Если мьютекс был заблокирован, он должен быть "протолкнут" в стек очистки вместе с функцией его разблокирования и т.д.

Очистка не должна вызывать исключений, поскольку она может быть вызвана через `THROW`. Иначе могут возникнуть комплексные случаи с попарными ошибками, с которыми справиться довольно сложно.

Когда выделенные ресурсы становятся ненужными или становятся частью переходного состояния программы, они должны быть изъяты из стека и очищены.

Обычно всё это решается небольшим набором функций:

 - `void cleanup_push(item, cleanup_function, cleanup_data)`: данная функция нужны для "проталкивания" нового объекта на вершину стека. Она хранит на вершине стека указатель на объект и указатель на функцию очистки.
 - `void cleanup_pop(item, keep_item)`: данная функция выталкивает верхний объект из стека. Если флаг `keep_item` выставлен в `false` (по-умолчанию), объект будет очищен. `item` должен соответствовать элементу на вершине стека для упрощения отладки.
 - `mark_t cleanup_mark(void)`: возвращает "непрозрачную" переменную, содержащую текущий размер стека. Данная переменная должна быть использована только в `cleanup_unwind()` (см. следующий пункт).
 - `void cleanup_unwind(mark)`: возвращает стек к состоянию, полученному при помощи `cleanup_mark()`. Данная операция автоматически очищает все объекты, вытолкнутые из стека.

Определения макросов __SEH__ также модифицированы:

 - Каждый вызов `TRY` вызывает `cleanup_mark()` для записи текущего размера стека очистки в скрытый буфер обработки исключений.
 - Каждый вызов `THROW` или `RETHROW` сначала вызывает `cleanup_unwind()` для очистки всех ресурсов, выделенных с последнего вызова `TRY`. Затем отсоединяется текущий обработчик и вызывается `longjmp()` для передачи управления.

Пример использования:

```c
//allocate a new memory block, then push it on the cleanup stack. Throws an exception in case of memory exhaustion
void *malloc_push(size_t size)
{
    void *p = NULL;

    if(size > 0)
    {
        p = malloc(size);
        if(p == NULL)
            THROW(ERR_ALLOC);
    }
//use "free" as the cleanup routine, the third parameter will be ignored
    cleanup_push(p, (cleanup_func_t)free, NULL);
};

//pop a block from the cleanup stack, then free it. We could define that as a macro, or simply invoke cleanup_pop directly in the code below.
void pop_free(void *block)
{
//setting the second parameter to false ensures that the item is cleaned immediately
    cleanup_pop(block, false);
};

void do_something(...)
{
    char *block1, *block2, *block3;

    block1 = (char *)malloc_push(1024);
    block2 = (char *)malloc_push(1024);
    block3 = (char *)malloc_push(1024);

    ...

    pop_free(block3);
    pop_free(block2);
    pop_free(block1);
};
```

Плюсы использования стека очистки:

 - Структура безопасного кода очень похожа на структуру небезопасного. В сравнении с оригинальной реализацией функции, были лишь изменены имена функций выделения и очистки памяти. Не было использовано "прыжков" и код удобочитаем.
 - Нет необходимости в создании специального объекта состояния, поскольку стек очистки используется для хранения истории выделения ресурсов. Не нужно определять дополнительные типы структур и передавать их в качестве параметров функциям.
 - Не нужно часто использовать `volatile`.

## 2. Анализ реализаций CSEH

### 2.1. Производительность

Поскольку выделенные ресурсы должны независимо проталкиваться в и вытесняться из стека во время исполнения программы, использование __CSEH__ может быть ресурсозатратным.

Использование __CSEH__ может повлиять на время исполнения программы, ровно как и реализация и частота проталкиваний/вытеснений.

К примеру, нам нужна функция чтения текстового файла, возвращающая простой односвязный список со строками:

```c
//define string list type
typedef struct list_node_t list_node_t;

struct list_node_t
{
    list_node_t *next;
    char *line;
};

typedef struct
{
    list_node_t *first;
    int count;
} list_t;

//string list finalizer for the list cleanup/destroy/clear
void list_done(list_t *list)
{
    if(list)
    {
        list_node_t *node, *next;

        node = list->first;
        while(node)
        {
            next = node->next;
            free(node->line);
            free(node);
            node = next;
        }

        list->first = NULL;
        list->count = 0;
    }
};

//read file and builds new string list
void list_read_file(list *list, file_t file)
{
    list_node_t *node;
    list_node_t **pnode;
    char *line;

//initialize list
    list->count = 0;
    list->first - NULL;
    pnode = &list->first;

//push list on cleanup stack
    cleanup_push(list, (cleanup_func_t)list_done, NULL);

//read file
    while(!eof(file))
    {
        line = file_read_new_line(file);
        if(line)
        {
            node = malloc_checked(sizeof(*node*));
            node->line = line;
            node->next = NULL;
            *pnode = node;
            pnode = &node->next;

            list->count++;
        }
    }

    cleanup_pop(list, true);
};
```

Заметьте, как, вне зависимости от количества строк, которые были прочитаны из файла, данная функция нуждается только в одной паре _push_/_pop_. Каждый узел аллоцируется при помощи простой и быстрой функции `malloc_checked()`, Цена **CSEH** в данном примере, таким образом, минимальна и это также является правдой для многих других классов контейнеров (деревьев, хэш-таблиц и т.д.).

ООП также имеет тенденцию уменьшать количество пар _push_/_pop_. Это происходит по причине общего правила о "временных" объектах: **только "корневые" объекты должны перемещаться в стеке**. Другими словами, объект, которым "владеет" другой объект, обычно не должен быть вставлен (_push_).

Таким образом, можно предположить, что цена **CSEH** минимальна в реальных программах, но иметь некоторое количество "сырых" чисел - всегда хорошая идея. Поэтому существует специфичный "_микро-бенчмарк_" (`c_bench.c`). Это небольшая программа, предназначенная для сравнения "таймингов" двух функций, выполняющих ту же работу:

+ `do_test_1()` - функция, которая выполняет множество аллокаций и взаимодействует с блоками фиксированного размера через непроверенные вызовы `malloc()` и `free()`
+ `do_test_2()` - вариант, использующий `malloc_push()` вместо `malloc()`, `pop_free()` вместо `free()`, как и "блокеры" `TRY..CATCH` для обработки исключений

Исходный код `c_bench.c` содержит простую, но рабочую реализацию подсистемы **CSEH** с макросами `TRY`, `CATCH`, `THROW` и т.д.

```c
#define MAX_TEMPS 3000
#define BLOCK_SIZE 32

static void *temps[MAX_TEMPS];

static void do_test_1(void)
{
    int n, i;

    for (n = 1; n < MAX_TEMPS; ++n)
    {
        /* allocate 'n' temporary memory blocks */
        for (i = 0; i < n; ++i)
	        temps[i] = malloc(BLOCK_SIZE);

		/* now, release them (in reverse order) */
		for (i = n - 1; i >= 0; --i)
			free(temps[i]);
    }
}
```

Код `do_test_2()` схож, изменены только имена функций `malloc()` и `free()` на `malloc_push()` и `pop_free()` соответственно.

`c_bench.c` портируем, следующая таблица даёт тайминги для выполнения двух тестовых функций с разными компиляторами на одной машине.

**Сравнение производительности `malloc()` и `malloc_push()`. "Тайминги" - средние для 10-ти "прогонов", выполненных на средне-нагруженном 233 MHz Mobile Pentium PC, 192 MB. Все тесты, кроме последнего, были выполненны в Windows**

| Компилятор          | do_test_1() | do_test_2() | Разница   | Соотношение замедлений |
| ------------------- | ----------- | ----------- | --------- | ---------------------- |
| _Borland C++ 5.5_   | `6,189` с   | `7,921` с   | `1,732` с | 28%                    |
| _Visual C++ 6_      | `8,932` с   | `10,415` с  | `1,483` с | 17%                    |
| _Mingw GCC 2.95.2_  | `20,299` с  | `22,342` с  | `2,043` с | 10%                    |
| _Cygwin GCC 2.95.3_ | `9,974` с   | `11.376` с  | `1,402` с | 14%                    |
| _LCC-Win32_         | `8,912` с   | `10,245` с  | `1,333` с | 15%                    |
| _Linux GCC 2.95.4_  | `5,89` с    | `7,5` с     | `1,61` с  | 27%                    |

+ Данный "микробенчмарк" не отражает типичные программы. Вместо этого, он измеряет производительность менеджера памяти библиотеки _C_ каждого компилятора. Аллокации _push_/_pop_ в _Borland C++_ быстрее, чем "сырые" в _Visual C++_.
+ Функция `malloc_push()` медленнее на 10-30%, чем "сырой" `malloc()`, в зависимости от компилятора и/или от используемой библиотеки.
+ Если программа тратит примерно 10% времени своего выполнения на управление памятью (число большее, чем может быть в реальных программах), то смена _всех_ функций на `malloc_push()` и `pop_free()` приведут к замедлению на 1-3% от общего времени выполнения.
+ Тем не менее, т.к. только "корневые" временные объекты должны перемещаться по стеку очистки и т.к. большая часть аллокации памяти не нуждается в парах _push_/_pop_. можно заявить, что **цена схемы CSEH для обычной программы незначительна**

### 2.2. Требования

#### 2.2.1. Размер кода

Опыт показывает, что реализация "рантайма" **CSEH**, т.е. функций управления очисткой стека, макросов обработки исключений, занимает от 4-х до 8-ми Кб машинного кода.

Общее количество кода, используемого "рантаймом" зависит от типа процессора и от нескольких деталей:

+ Обычная реализация использовала бы динамическую аллокацию для стека для поддержки произвольного количества временных объектов, гарантируя хорошую производительность для _push_/_pop_. Обычно это достигается через реализацию стека, как связного списка "чанков" слотов фиксированного размера, что далее усложняет код
+ В отладочных сборках реализация должна быть "параноидальной" для отслеживания неконсистентных состояний стека. Оные могут быть результатом ошибок разработчика (напр. неупорядоченные _push_/_pop_) или сложных багов (напр. висячие указатели)
+ Для поддержки многопоточности некоторые системо-зависимые операции должны быть предоставлены для или же реализованы в "рантайме" системы. Они используются для получения потоко-специфичных стеков очистки и списков обработчиков искоючений. Обычно это делается с использованием объектов, локальных для потока (**TLS**, _Thread-local Storage_)

Также, реализация некоторых операций "рантайма" непроста из-за использования динамической аллокации. Напр., `cleanup_push()` должна сравляться со случаями, когда не остаётся памяти для "наращивания" стека очистки.

Наконец, размер машинного код "рантайма" фиксирован для всех программ и, что код, который использует его, может быть написан просто и эффективно. Можно сравнить это с "параноидальной" схемой, где большое количество "прыжков" встречается в исходном коде, что обычно влияет на относительное увеличение размера кода вместо фиксированного.

#### 2.2.2. Несколько потоков

Дизайн кода, который может быть запущен в нескольких потоках параллельно, требует системо-специфичных примитивов синхронизации (мьютексы, события и т.д.), которые не являются совместимыми с **ANSI-C**. Также, каждый поток, который может использовать технику **CSEH**, нуждается в собственном "контексте обработки исключений", где каждый контекст содержит список обработчиков исключений и стек очистки.

С каждым `TRY`, `CATCH`, `THROW`, _push_ или _pop_, "рантайм" **CSEH** должен получать контекст обработки исключений текущего потока как можно быстрее. Обычно это реализуется с помощью объектов **TLS** (_Thread-local Storage_). Это контейнеры, содержащие потоко-специфичные значения, которые обычно разработаны для высоких скоростей (большая часть реализаций использует неблокирующее взаимное исключения, избегая разного рода обращения к ядру или иных "дорогих" вычислений).

Тем не менее, это может повлиять на производительность операций **CSEH**, включая функции _push_/_pop_. Сложно назвать конкретную величину, определяющую падение производительности из-за зависимости от системы (какие-то системы имеют быстрые контейнеры **TLS**, какие-то - нет). Но можно предположить, что редкое использование операций _push_/_pop_ во время выполнения типичной программы, должно оставить цену использования **CSEH** минимальной.

### 2.3. Реализации

Небольшое количество реализаций **CSEH**.

**_KazLib_**

_KazLib_ - пакет с переиспользуемыми программными модулями, написанный Кацом Килхеку (Kaz Kylheku), предоставляющий простые контейнеры (списки, хэш-таблици, словари, как и портируемые реализации **CSEH**).

Он предоставляет макросы `try`, `catch` и `end_catch`, а также функции `except_cleanup_push()` и `except_cleanup_pop()` для управления стеком очистки.

Реализация основана на `setjmp()`/`longjmp()`. Исходный код библиотеки включает операции для поддержки потоковой безопасности только для _Posix thread_.

**Система _Symbian EPOC_**

_EPOC_ - ОС, написанная на _C++_ для встраиваемых систем с жёсткими требованиями (телефоны, **PDA**).

Она предоставляет собственную подсистему потоков и реализацию **CSEH**, на которые опираются все библиотеки и классы системы и приложения.

Реализация _EPOC_ не использует "нативные" обработчики исключений _C++_ ради портируемости и производительности.

_**MLib**_

Библиотека "общего назначения", разработанная специально для встраиваемых систем (у неё есть серьёзные требования, например, запрещено использование статических переменных). Библиотека похожа на _GLib_, поскольку предоставляет набор полезных контейнеров (списки, хэш-таблицы, деревья и т.д.). Тем не менее, она была написана с учётом ограничений (например, выполнение программы не прекращается при использовании всей памяти) и предоставляет реализацию **CSEH**, на основе которой вся библиотека была реализована.

По-умолчанию, _MLib_ предоставляет быстрый однопоточный "рантайм" **CSEH**. Но клиентские приложения или библиотеки могут предоставить собственный интерфейс синхронизации (включая те, что используются для получения контекста обработки исключений) для автоматического и прозрачного использования её в нескольких потоках.

## 3. Заключение

Сумма положительных и отрицательных сторон рассмотренных техник.

**Параноидальная**

+ **+** легко понять, прямолинейная реализация (не нуждается в поддержке "рантайма")
+ **+** портируема, поддерживает потоки, т.к. нуждается только в простейших примитивах синхронизации
+ **-** трудно для написания, поддержки и чтения кода; многие разработчики избегают данной техники
+ используется кодом со строгими требованиями к надёжности (тем не менее, многие разработчики _C_ предпочитают избегать данную технику, особенно, когда дело касается расхода памяти)

**Транзакционная**

+ требует понимания функций `setjmp()`/`longjmp()`, как и понимания использования ключевого слова `volatile` для локальных переменных и некоторых функций
+ **+** портируема, т.к. `setjmp()`/`longjmp()` предоставляются всеми **ANSI C** библиотеками
+ затруднительно разрабатывать и поддерживать объект "состояния" транзакции, но написание функций, использующих его, гораздо проще
+ работает, но редко используется (обычно, когда существует небольшое количество однозначно определённых транзакций)

**Структурной обработки исключений**

+ требует понимания конструкций `TRY`..`CATCH`..`END_CATCH`; скрывает использование `setjmp()`/`longjmp()` или любых других имплементаций "переходов"
+ легко портируем для однопоточных программ, но требует простую поддержку "рантайма" для управления списками обработчиков исключений; также требует системо-зависимых объектов **TLS** для поддержки параллельных потоков
+ легко управляеются исключения (_throw_, _catch_ и т.д.); тем не менее, разработчик должен реализовать объекты состояний для корректной реализации _history_/_rollback_
+ **-** к сожалению, безопасное использование схемы затруднительно, напр. без корректной реализации отката в случае исключений (особенно, в _C++_)

**CSEH**

+ требует понимания конструкций `TRY`..`CATCH`..`END_CATCH` и операций _push_/_pop_
+ легко портируем для однопоточных программ, но требует сложной поддержки "рантайма" для управления контекстами обработки исключений (список обработчиков и стек очистки); также требует системо-специфичных объектов **TLS** для поддержки параллельных потоков
+ **+** легко использовать как для управления исключениями, так и управления "историей"; "безопасный" код с **CSEH** приближён к "небезопасному"
+ редко используется, но уже протестирован на широком спектре

## Приложение A: инструкции `setjmp()` и `longjmp()`

`setjmp()` и `longjmp()` - две **ANSI C**-совместимые функции, которые используются для передачи управления во вне функций в _C_.

```c
#include <setjmp.h>
```

**Механизм**

В первую очередь, `setjmp()` записывает текущее _состояние процессора_ (указатель инструкции и состояние регистра) в системо-специфичной структуре, известной, как "буфер перехода" (jump buffer) типа `jmp_buf`. Функция обычно возвращается сразу со значением `0`.

`longjmp()` используется со структурой `jmp_buf`, которая ранее была инициализирована `setjmp()`. Функция напрямую передаёт управление на указатель инструкции, расположенному в буфере перехода. Это происходит без проверки и очистки (unwinding) стека. После передачи управления соответствующая функция `setjmp()` возвращает не-нулевое значение (обычно, предоставленное в `longjmp()`)

```c
static jmp_buf jump_buffer;

void f1(int x)
{
	//print something
	printf("the value of x is %d\n", x);

	//transfer control, the 1 is not important
	longjmp(jump_buffer, 1);

	//never executed
	printf("the value of 2*x is %d\n", 2 * x);
}

void f2(int x)
{
	//never returns
	f1(x);

	//never executed
	printf("the value of x^2 is %d\n", x * x);
}

void main(void)
{
	int x = 509;

	if (setjmp(jump_buffer) == 0)
	{
		//print header
		printf("beginning!\n");

		//never returns
		f1(x);

		//never executed
		printf("what?\n");
	}
	else
		//executed after the "longjmp()" in "f1()"
		printf("branch taken!\n");

	//print footer
	printf("exiting!\n");
}
```

**Особые условия (`volatile`)**

С осторожностью нужно относиться к локальным переменным в функциях, использующих `setjmp()`. Поскольку многие оптимизирующие компиляторы хранят локальные переменные в регистрах и, т.к. функции `setjmp()`/`longjmp()` хранят и загружают значения регистров в буфер передачи управления, могут возникнуть некоторые сложно-отлаживаемые проблемы. Например:

```c
{
	int counter = 0;
	jmp_buf jump_buffer;

	printf("%d ", counter);
	coutner++;

	if (setjmp(jump_buffer) == 0)
	{
		printf("%d ", counter);
		counter++;
		longjmp(jump_buffer, 1);
	}

	printf("%d\n", counter);
}
```

Можно ожидать, что функция напечатает "0 1 2", но, с большнй частью оптимизирующих компиляторов, получим "0 1 1". Происходит это, поскольку переменная была оптимизирована и использована в регистре вместо того, чтобы находиться в слоте стека. При вызове `setjmp()`, он сохраняет все значения регистра в буфере передачи управления, включая текущее значение `counter`, равняющееся `1`. Когда вызывается `longjmp()`, он восстанавливает все значения регистра из буфера, поэтому второй инкремент `counter` был потерян.

Простой путь решения проблемы - использование ключевого слова `volatile` для локальных переменных. Оно говорит компилятору, что переменную класть в регистр не нужно:

```c
	volatile int counter = 0;
```

## Ссылки

https://freetype.sourceforge.net/david/reliable-c.html

#c #development