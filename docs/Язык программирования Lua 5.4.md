---
tags:
  - development
  - lua
  - programming
---

# Язык программирования _Lua_ `5.4`

## Содержание

 + [[#1. Введение]]
 + [[#2. Концепция]]
	 + [[#2.1. Значения и типы]]
	 + [[#2.2. Окружения и глобальное окружение]]
	 + [[#2.3. Обработка ошибок]]
	 + [[#2.4. Метатаблицы и метаметоды]]
	 + [[#2.5. Сборка мусора]]
		 + [[#2.5.1. Инкрементная сборка мусора]]
		 + [[#2.5.2. Сборка мусора поколениями]]
		 + [[#2.5.3. Метаметоды сборки мусора]]
		 + [[#2.5.4. Слабые таблицы]]
	+ [[#2.6. Сопрограммы]]
+ [[#3. Язык]]
	+ [[#3.1. Лексические соглашения]]
	+ [[#3.2. Переменные]]
	+ [[#3.3. Объявления]]
		+ [[#3.3.1. Блоки]]
		+ [[#3.3.2. Чанки]]
		+ [[#3.3.3. Присвоение]]
		+ [[#3.3.4. Контролирующие структуры]]
		+ [[#3.3.5. Объявление _for_]]
		+ [[#3.3.6. Вызов функций, как объявлений]]
		+ [[#3.3.7. Локальные объявления]]
		+ [[#3.3.8. Переменные _to-be-closed_]]
	+ [[#3.4. Выражения]]
		+ [[#3.4.1. Арифметические операторы]]
		+ [[#3.4.2. Побитовые операторы]]
		+ [[#3.4.3. Принудительные операции и конверсия]]
		+ [[#3.4.4. Операторы отношений]]
		+ [[#3.4.5. Логические операторы]]
		+ [[#3.4.6. Конкатенация]]
		+ [[#3.4.7. Оператор длины]]
		+ [[#3.4.8. Старшинство]]
		+ [[#3.4.9. Конструкторы таблиц]]
		+ [[#3.4.10. Вызов функций]]
		+ [[#3.4.11. Определение функций]]
		+ [[#3.4.12. Списки выражений, несколько результатов и выравнивание]]
	+ [[#3.5. Правила видимости]]
+ [[#4. Интерфейс приложения]]
	+ [[#4.1. Стэк]]
		+ [[#4.1.1. Размер стэка]]
		+ [[#4.1.2. Валидные и приемлемые индексы]]
		+ [[#4.1.3. Указатели на строки]]
	+ [[#4.2. Замыкания _C_]]
	+ [[#4.3. Регистр]]
	+ [[#4.4. Обработка ошибок в _C_]]
		+ [[#4.4.1. Коды статуса]]
	+ [[#4.5. Обработка нагрузки в _C_]]
	+ [[#4.6. Функции и типы]]
	+ [[#4.7. Интерфейс отладки]]
+ [[#5. Вспомогательная библиотека]]
	+ [[#5.1. Функции и типы]]
+ [[#6. Стандартные библиотеки]]
	+ [[#6.1. Простейшие функции]]
	+ [[#6.2. Манипуляция сопрограммами]]
	+ [[#6.3. Модули]]
	+ [[#6.4. Манипуляция строками]]
		+ [[#6.4.1. Паттерны]]
		+ [[#6.4.2. Форматирование строк для упаковки и распаковки]]
	+ [[#6.5. Поддержка _UTF-8_]]
	+ [[#6.6. Манипуляция таблицами]]
	+ [[#6.7. Математические функции]]
	+ [[#6.8. Ввод и вывод]]
	+ [[#6.9. Работа с __ОС__]]
	+ [[#6.10. Библиотека отладки]]
+ [[#7. Интерпретатор _Lua_]]
+ [[#8. Полный синтаксис _Lua_]]
+ [[#Ссылки]]

## 1. Введение

_Lua_ - мощный, эффективный, лёгкий и встраиваемый скриптовый язык. Он поддерживает процедурное, объектно-оринтированное, data-driven и функциональное программирование.

_Lua_ комбинирует простой процедурный синтаксис с мощным описанием данных и описанием конструкций, основанных на ассоциативных массивах и расширяемой семантикой. В языке есть динамическая типизация, которая интерпретирует байт-код в регистро-зависимой виртуальной машине и имеет автоматическое управление памятью с поколенческим сборщиком мусора.

_Lua_ реализован, как библиотека, написанная на _clean C_. Дистрибутив включает в себя программу _lua_, использующую данную библиотеку для реализации интерпретатора _Lua_.

В _Lua_ нет "основной" программы: он работает встроенно в клиент хоста. Хост-программа может выполнять функции для исполнения кода _Lua_, может читать и записывать переменные _Lua_ и регистрировать функции _C_, вызываемые из кода _Lua_.

## 2. Концепция

### 2.1. Значения и типы

_Lua_ - язык с динамической типизацией.

Все значения в _Lua_ - значения "первого класса". Они могут храниться в переменных, передаваться в качестве аргументов в функции и возвращаться в качестве результата.

8 простейших типов: _nil_, _boolean_, _number_, _string_, _function_, _userdata_, _thread_ и _table_. Тип _nil_ имеет единственное значение `nil`, свойство которого - быть отличным от любого другого значения. _boolean_ имеет два значения: `true` т `false`. `nil` и `false` в условиях представляют из себя "ложь". Любое другое значение - "истинное".

_number_ представляет целые числа и числа с плавающей точкой (подтипы _integer_ и _float_). _Lua_ использует для хранения 64 бита, но можно скомпилировать _Lua_ так, чтобы для _number_ использовалось 32 бита (см. `LUA_32BITS` в `luaconf.h`).

Любое переполнение по-умолчанию оборачивается (в случае целых чисел).

_string_ представляет иммутабельную последовательность байтов.

_Lua_ может вызывать функции, написанные на _Lua_ или на _C_. Они представлены типом _function_.

_userdata_ представлен, чтобы позволить хранить сырые данные из _C_ в переменных _Lua_. _full userdata_ - объект с блоком в памяти, управляемым из _Lua_; _light userdata_ - указатель из _C_. Используя метатаблицы, можно определить операции над значениями _full userdata_. Значения _userdata_ не могут быть созданы или изменены в _Lua_, данные действия возможны только с использованием __API__ _C_.

_thread_ представляет независимые потоки выполнения и нужен для реализации сопрограмм. Потоки _Lua_ не связаны с потоками __ОС__.

_table_ имплементирует ассоциативные массивы. Таблицы гетерогенны, т.е., могут содержать значения всех типов (кроме _nil_). Значения и соответствующие индексы могут быть любого типа.

Таблицы - единственный механизм структурирования данных в _Lua_; они могут быть использованы для представления массивов, списков, таблиц символов, записей, графов, деревьев и т.д. Для представления записей _Lua_ использует имя поля в качестве индекса. Язык поддерживает такую репрезентацию благодаря синтаксическому расширению `a.name` для `a["name"]`.

Таблицы могут содержать функции и методы.

`a[i]` и `a[j]` представляют один и тот же элемент, только если `j` и `i` абсолютно равны и/или идентичны.

Таблицы, функции, потоки и пользовательские данные - объекты: переменные не хранят данные значения, а только ссылки на них.

### 2.2. Окружения и глобальное окружение

Любая ссылка на незанятое имя `var` синтаксически переводится в `_ENV.var`. Более того, любой чанк компилируется в области видимости внешней локальной переменной `_ENV`, так что `_ENV` никогда не является незанятым именем в чанке.

Несмотря на существование внешней переменной `_ENV` и трансляции незанятых имён, `_ENV` - обычное имя. В частности, можно определить новые переменные и параметры с данным именем. Каждая ссылка на незанятое имя использует `_ENV`, который видим к тому моменту в программе, в соответствии с обычными правилами видимости в _Lua_.

Любая таблица, используемая, как значение `_ENV`, зовётся _окружением_.

_Lua_ хранит отдельное окружение, именуемое _глобальным_. Данное значение хранится, как специальный индекс в регистре _C_. Глобальная переменная `_G` инициализируется с этими значениями.

При загрузке чанка, стандартное значение для его `_ENV` - это глобальное окружение (см. `load()`). Таким образом, незанятые имена в коде ссылаются на поля в глобальном окружении и, следовательно, они зовутся _глобальными переменными_. Все стандартные библиотеки загружаются в глобальное окружение и некоторые функции оперируют над ним. Можно использовать `load()` (или `loadfile()`) для загрузки чанка с иным окружением (в _C_ придётся загрузить чанк и затем изменить значения его первого верхнего значения, см. `lua_setupvalue()`).

### 2.3. Обработка ошибок

Некоторые операции в _Lua_ могут вызвать ошибку. Ошибка прерывает поток выполнения программы, который может быть продолжен при "отлове" ошибки.

Вызвать ошибку можно, вызвав функцию `error()`.

Для отлова ошибок можно создать защищённый вызов, используя `pcall()` или `xpcall()`. `pcall()` вызывает переданную ей функцию в _защищённом режиме_. Любая ошибка при выполнении функции останавливает её выполнение и контроль возвращается в `pcall()`, возвращающую код статуса.

При возникновении ошибки, _объект ошибки_ заполняется информацией об ошибке. _Lua_ генерирует ошибки, чьи объекты являются строками, но программы могут генерировать ошибки с любым значением для объекта ошибок.

При вызове `xpcall()` (или `lua_pcall()` в _C_). можно вызвать хэндлер сообщения в случае ошибки. Данная функция вызывается с оригинальным объектом ошибки и возвращает новый объект ошибки. Он вызывается до того, как ошибка развернёт стек, так что можно получить больше информации об ошибке, к примеру, рассмотрев стек и создав трейсбэк. Данный обработчик сообщений всё-ещё защищён; так что ошибка внутри обработчика сообщений вызовет обработчик сообщений снова.

Также имеются _системные предупреждения_ (см. `warn()`). Поведение `warn()` можно определить в _C_ при помощи `lua_setwarnf()`.

### 2.4. Метатаблицы и метаметоды

Каждое значение в _Lua_ может иметь _метатаблицу_. Данная метатаблица является обычной таблицей, которая определяет поведение оригинальных значений для ряда событий. Можно изменить некоторые аспекты поведения значения, выставив определённые поля в данной метатаблице. К примеру, не-числовое значение может использовать операцию сложения; в таком случае, проверяется поле `__add()` метатаблицы. Если такое имеется, _Lua_ вызывает данную функцию для осуществления сложения.

Ключ каждого события в метатаблице - строка с именем события с префиксом `__`; соответствующее значение называется _метазначением_. Для большинства событий метазначение является функцией (_метаметод_).

Можно проверить метатаблицу для любого значения, используя `getmetatable()`. _Lua_ проверяет метаметоды в метатаблицах, используя прямой доступ (см. `rawget()`).

Можно заменить метатаблицу таблиц, используя `setmetatable()`. Заменить метатаблицы других типов в _Lua_ нельзя за исключением ситуаций с использованием отладочной библиотеки.

Таблицы и полные пользовательские данные имеют индивидуальные метатаблицы. Несколько таблиц и пользовательские данные также могут иметь общие метатаблицы.

__Список операций, контролируемых метатаблицами__

 + `__add`: операция сложения (`+`). Если операнд для сложения не является числом, _Lua_ попытается вызвать метаметод. Он начинается с проверки первого операнда (даже если он является числом); если данный операнд не определил метаметод для `__add`, _Lua_ проверит второй операнд. Если _Lua_ сможет найти метаметод, он вызывается с двумя операндами в качестве аргументов, результат вызова - результат операции. Если метаметод не найден, вызывается ошибка.
 + `__sub`: операция вычитания (`-`). См. `__add`.
 + `__mul`: операция умножения (`*`). См. `__add`.
 + `__div`: операция деления (`/`). См. `__add`.
 + `__mod`: операция вычисления остатка (`%`). См. `__add`.
 + `__pow`: операция возведения в степень (`^`). См. `__add`.
 + `__unm`: операция унарного отрицания (`-`). См. `__add`.
 + `__idiv`: операция деления без остатка (`//`). См. `__add`.
 + `__band`: побитовое И (`&`). См. `__add`, но _Lua_ попытается использовать данный метаметод только если любой операнд не является ни целым числом, ни числом с плавающей точкой, конвертируемым в целое
 + `__bor`: побитовое ИЛИ (`|`). См. `__band`.
 + `__bxor`: побитовое исключающее ИЛИ (`~`). См. `__band`.
 + `__bnot`: побитовое унарное НЕ (отрицание; `~`). См. `__band`.
 + `__shl`: побитовый сдвиг влево (`<<`). См. `__band`.
 + `__shr`: побитовый сдвиг вправо (`>>`). См. `__band`.
 + `__concat`: конкатенация (`..`). См. `__add`, но _Lua_ попытается вызвать метаметод, если любой операнд не строка и не число.
 + `__len`: оператор длины (`#`). Если объект не является строкой, _Lua_ вызовет метаметод. Если он существует, _Lua_ вызывает его с объектом в качестве аргумента. Если метаметода нет, но объект - таблица, _Lua_ использует операцию возврата размера таблицы. В остальных случаях вернётся ошибка. Возвращается одно значение.
 + `__eq`: оператор равенства (`==`). См. `__add`, но _Lua_ вызовет метаметод только если сравниваемые значения - обе таблицы или пользовательские данные. Результат - булево значение.
 + `__lt`: оператор "меньше, чем" `<`. См. `__add`, но метаметод вызывается, если значения не являются строками или числами. Результат - булево значение.
 + `__le`: "меньше или равно". См. `__lt`.
 + `__index`: операция доступа по индексу `table[key]`. Данное событие триггерится, когда `table` не является таблицей или когда `key` нет в `table`. Метазначение просматривается в метатаблице `table`. Метазначением для данного события может быть функция, таблица или любое значение с метазначением `__index`. Если это функция, она вызывается с `table` и `key` в качестве аргументов, а результат вызова (одно значение) - результат операции. Иначе, конечный результат - это результат индексации метазначения по `key`. Индексация обычная, не "сырая", потому может триггернуться ещё одно метазначение `__index`.
 + `__newindex`: присвоение по индексу `table[key] = value`. Как и в `__index`, данное событие случается, когда `table` не является таблицей или `key` нет в `table`. Метазначение просматривается в метатаблице `table`. Как с индексацией, метазначение для данного события может быть функцией, таблицей или любым значением с метазначением `__newindex`. Если это функция, она вызывается с `table`, `key` и `value` в качестве аргументов. Иначе повторяется присвоение по индексу для данного метазначения с теми же `key` и `value`. Присвоение регулярное, потому может триггернуться ещё одно метазначение `__newindex`. Когда метазначение `__newindex` вызывается, _Lua_ не делает примитивного присвоения. При необходимости, метаметод может вызвать `rawset()` для присвоения.
 + `__call`: вызов операции `func(args)`. Событие происходит при попытки вызова значения, не являющегося функцией (`func` - не функция). Метаметод просматривается в `func`. Если имеется, метаметод вызывается с `func` в качестве первого аргумента с последующими аргументами из скобок (`args`). Единственный метаметод, разрешающий множественный результат.
 + `__gc`: см. [[#2.5.3. Метаметоды сборки мусора]].
 + `__close`: см. [[#3.3.8. Переменные _to-be-closed_]].
 + `__mode`: см. [[#2.5.4. Слабые таблицы]].
 + `__name`: см. `tostring()`.

### 2.5. Сборка мусора

_Lua_ управляет памятью автоматически при помощи _сборщика мусора_ для сборки всех _мёртвых объектов_.

Объект считается мёртвым, как только сборщик удостоверяется в том, что доступ к объекту осуществляться больше не будет. _Lua_ не собирает объекты, доступные только через регистр (в т.ч. глобальное окружение, см. [[#4.3. Регистр]]).

Два режима сборщика мусора (__GC__, _Garbage Collector_): инкрементный и поколенческий.

Поведение __GC__ не портируемо между платформами.

Режим сборки мусора можно изменить, вызвав `lua_gc()` в _C_ или `collectgarbage()` в _Lua_. Данные функции также можно использовать для управления __GC__ напрямую (остановить, перезапустить и т.д.).

#### 2.5.1. Инкрементная сборка мусора

В инкрементном режиме каждый цикл __GC__ выполняет _mark-and_sweep_ сборку небольшими интервалами. __GC__ в данном режиме использует 3 числа для управления циклом сборки мусора: _garbage-collector pause_, _garbage-collector step multiplier_ и _garbage-collector step size_.

_garbage-collector pause_ контролирует, как долго сборщик ждёт до начала нового цикла. Сборщик начинает новый цикл, когда использование памяти достигает `n%` от использования после предыдущей сборки. Большие значения делают сборщик менее агрессивным. Значения меньшие или равные `100` означают, что __GC__ не будет ждать начала нового цикла. `200` значит, что сборщик ждёт, пока общий размер используемой памяти не удвоится перед началом нового цикла. По-умолчанию значение `200`, максимум - `1000`.

_garbage-collector step multiplier_ управляет скоростью __GC__ относительно к выделению памяти, т.е., сколько элементов он помечает или очищает на каждый выделенный _Кбайт_ памяти. Большие значения делают сборщик более агрессивным, но также увеличивают размер каждого шага. Нельзя использовать значения меньше `100`, поскольку они замедлят __GC__ и он не сможет завершить цикл. Значение по-умолчанию: `100`, максимальное: `1000`.

_garbage-collector step size_ управляет размером каждого шага, конкретно - сколько байт интерпретатор аллоцирует до выполнения следующего шага. Данный параметр логарифмический: `n` означает, что интерпретатор выделит 2<sup>n</sup> байт между шагами и выполнит ту же работу во время шага. Большое значение (`60`) делает __GC__ не-инкрементным сборщиком. Стандартное значение `13`, т.е. шаги примерно `8` Кбайт.

#### 2.5.2. Сборка мусора поколениями

В поколенческом режиме __GC__ делает частые _минорные_ сборки, которые проходятся по недавно созданным объектам. Если после минорной сборки использование памяти всё-ещё сверх лимита, сборщик делает _мажорную_ сборку, которая проходится по всем объектам. Используются два параметра: _minor multiplier_ и _major multiplier_.

_minor multiplier_ контролирует частоту минорных сборок. Для множителя `x`, новая минорная сборка будет сделана после того, как используемая память вырастет на `x%` по отношению к размеру после предыдущей мажорной сборки. К примеру, если множитель равен `20`, __GC__ выполнит минорную сборку, когда использование памяти станет на `20%` больше, чем то количество, которое было после предыдущей мажорной сборки. Стандартное значение `20`; максимальное - `200`.

_major multiplier_ управляет частотой мажорных сборок. Для множителя `x`, нова мажорная сборка будет произведена, когда используемая память станет на `x%` больше, чем память после предыдущей мажорной сборки. Значение по-умолчанию `100`; максимальное: `1000`.

#### 2.5.3. Метаметоды сборки мусора

Метаметоды сборки мусора можно установить для таблиц и, при использовании __API__ _C_, для пользовательских данных. Данные метаметоды называются _финализаторами_ и вызываются, когда сборщик мусора обнаруживает, что соответствующая таблица или данные "мертвы". Финализаторы позволяют координировать сборку мусора _Lua_ со внешним управлением ресурсами (закрытие файлов, соединений или очистка собственной памяти).

Объект для финализации после сборки должен быть _помечен_. Помечается он при создании метатаблицы с метаметодом `__gc()`.

При смерти помеченного объекта _Lua_ помещает его в список, по которому проходится после сборки мусора. Для каждого объекта вызывается `__gc()`, если таковой имеется, с объектом в качестве аргумента.

В конце каждого цикла сборки мусора вызываются финализаторы в обратном от пометки объектов порядке.

При закрытии объявления (см. `lua_close()`), _Lua_ вызывает финализаторы всех помеченных объектов.

Любая ошибка финализатора генерирует предупреждение.

#### 2.5.4. Слабые таблицы

_Слабая таблица_ - таблица, элементами которой являются _слабые ссылки_. Слабые ссылки игнорируются __GC__.

Слабая таблица может иметь слабые ключи, слабые значения, или и то, и другое. Таблица со слабыми значениями позволяет собирать её значения, но не позволяет собирать ключи. Таблица со слабыми ключами и значениями позволяет собирать и ключи, и значения. В любом случае, если ключ или значение собраны, вся пара удаляется из таблицы. "Слабость" таблицы управляется полем `__mode` её метатаблицы. Данное метазначение должно быть одним из следующих: `k`, для таблицы со слабыми ключами; `v`, для таблицы со слабыми значениями; `kv` для таблицы со слабыми ключами и значениями.

Таблица со слабыми ключами и сильными значениями также называется _эфемеронной таблицей_. В эфемеронной таблице значение считается доступным, только если его ключ доступен.

Любые изменения в силе таблицы вносятся только после следующего цикла __GC__.

Только объекты с явной конструкцией могут быть удалены из слабых таблиц. Значения вроде чисел и лёгких функций _C_ не являются субъектом для __GC__ и не удаляются из слабых таблиц (только если соответствующие им значения не собраны). Строки ведут себя, как значения, а не как объекты и не удаляются из слабых таблиц.

Финализируемые объекты и объекты, доступные только через них, имеют специальное поведение в слабых таблицах. Они удаляются из слабых значений до запуска их финализаторов, но из слабых ключей удаляются только во время следующей сборки после запуска их финализаторов, когда данные объекты действительно очищены. Данное поведение позволяет получить доступ финализаторам к свойствам, ассоциированным с объектом посредством слабых таблиц.

### 2.6. Сопрограммы

Сопрограммы представляют независимые потоки выполнения. Но они только приостанавливают выполнение вызовом функции `.yield()`.

Сопрограмму можно создать, вызвав `coroutine.create()`. Единственный аргумент - функция. `.create()` только создаёт новую сопрограмму и возвращает её хэндлер (типа _thread_); она не запускает сопрограмму.

Выполнить сопрограмму можно вызовом `coroutine.resume()`. При первом вызове `coroutine.resume()` с аргументом, являющимся потоком, возвращённым из `coroutine.create()`, сопрограмма начинает своё выполнение вызовом основной функции. Дополнительные аргументы, переданные в `coroutine.resume()` передаются, как аргументы в данную функцию. После старта сопрограммы, она выполняется либо до завершения, либо до вызова `.yield()`.

Завершается сопрограмма двумя путями: нормально (с возвратом); ненормально, при возникновении ошибки. В случае нормального завершения, `coroutine.resume()` возвращает `true` и любые значения, возвращаемые основной функцией сопрограммы. В случае ошибки, возвращается `false` и объект ошибки. Стек сопрограммы далее можно будет проинспектировать отладочным __API__.

Сопрограмма может выдать промежуточный результат, вызвав `coroutine.yield()`. В данном случае управление передаётся `coroutine.resume()`, даже если вызов был во вложенном вызове функции. Возвращается в данном случае `true` и значения, переданные в `coroutine.yield()`. Далее, при вызове той же сопрограммы, она продолжит своё выполнение с предыдущей точки вызова `coroutine.yield()`.

`coroutine.wrap()` также создаёт сопрограмму, но вместо возврата самой сопрограммы, она возвращает функцию, которая, при вызове, продолжает сопрограмму. Любые аргументы, переданные в эту функцию, идут, как дополнительные аргументы для `coroutine.resume()`. `coroutine.wrap()` возвращает все значения, возвращаемые `coroutine.resume()`, кроме самой первой (булевый код ошибки). В отличие от `coroutine.resume()`, функция, созданная `coroutine.wrap()`, отдаёт ошибки вызываемому. В данном случае, функция также закрывает сопрограмму (см. `coroutine.close()`).

```lua
function foo (a)
	print("foo", a)
	return coroutine.yield(2*a)
end

co = coroutine.create(function (a,b)
	print("co-body", a, b)
	local r = foo(a+1)
	print("co-body", r)
	local r, s = coroutine.yield(a+b, a-b)
	print("co-body", r, s)
	return b, "end"
end)

print("main", coroutine.resume(co, 1, 10))
print("main", coroutine.resume(co, "r"))
print("main", coroutine.resume(co, "x", "y"))
print("main", coroutine.resume(co, "x", "y"))
```

Сопрограммами можно управлять при помощи _C_ __API__ (см. `lua_newthread()` и `lua_yield()`).

## 3. Язык

Конструкции языка описаны с использованием расширенной нотации __BNF__, где `{a}` означает `0` или более `a`, `[a]` означает опциональное `a`. Не-терминалы показаны, как не-терминалы, ключевые слова показаны, как `kword` и другие терминальные символы показаны, как `'='`.
### 3.1. Лексические соглашения

_Lua_ - язык свободной формы. Он игнорирует пробелы и комментарии между лексическими элементами (токенами), за исключением разделителей между двумя токенами.

_Имена_ (_идентификаторы_) могут быть любыми строками латинских букв, цифр и нижних подчёркиваний. Не начинаются с числа и не являются зарезервированным словом.

__Ключевые слова__

 + `and`
 + `break`
 + `do`
 + `else`
 + `elseif`
 + `end`
 + `false`
 + `for`
 + `function`
 + `goto`
 + `if`
 + `in`
 + `local`
 + `nil`
 + `not`
 + `or`
 + `repeat`
 + `return`
 + `then`
 + `true`
 + `until`
 + `while`

_Lua_ регистрозависим. По соглашению, стоит избегать создания имён, начинающихся с нижних подчёркиваний с последующими одним или более большими буквами.

__Остальные зарезервированные токены__

 + `+`
 + `-`
 + `*`
 + `/`
 + `%`
 + `^`
 + `#`
 + `&`
 + `~`
 + `|`
 + `<<`
 + `>>`
 + `//`
 + `==`
 + `~=`
 + `<=`
 + `>=`
 + `<`
 + `>`
 + `=`
 + `(`
 + `)`
 + `{`
 + `}`
 + `[`
 + `]`
 + `::`
 + `;`
 + `:`
 + `,`
 + `.`
 + `..`
 + `...`

_Короткая литерная строка_ может быть разделена подходящими единичными иди двойными кавычками (`'`, `"`) и может иметь следующие эскейп-последовательности: `\a` (_bell_), `\b` (_backspace_), `\f` (_form feed_), `\n` (_newline_), `\r` (_carriage return_), `\t` (_horizontal tab_), `\v` (_vertical tab_), `\\` (_backslash_), `\"` (_double quote_), `\'` (_single quote_). Обратная косая черта с последующей новой строкой создают новую строку в строке. `\z` пропускает последующий интервал пробельных символов, включая разрывы строк.

Можно указать любой байт в короткой литерной строке, включая нулевые. Это можно сделать при помощи `\xXX`, где `XX`- две шестнадцатеричные цифры; или используя `\ddd`, где `ddd` - три десятичные цифры.

Символ _Unicode_ может быть вставлен при помощи `\u{XXX}`, где `XXX` - шестнадцатеричные цифры.

Литеральные строки также могут быть определены с использованием _длинных скобок_. _Открывающая длинная скобка уровня n_ - это открывающая квадратная скобка с последующими `n` одинаковыми знаками с ещё одной открывающей квадратной скобкой. Для закрывающих правило схожее (примеры: `[=[` `]=]`). _Длинные литерные строки_ могут содержать любой текст. Если после открывающей длинной скобки есть перевод строки, он не включается в строку.

```lua
a = 'alo\n123"'
a = "alo\n123""
a = '\97lo\10\04923"'
a = [[alo
123"]]
a = [==[
alo
123"]==]
```

_Числовые константы_ могут быть записаны с дополнительной дробной частью и опциональной десятичной экспонентой, помеченной через `e` или `E`. Также поддерживаются шестнадцатеричные константы, начинающиеся с `0x` или `0X`. Шестнадцатеричные константы также поддерживают опциональную дробную часть плюс дополнительную бинарную экспоненту, помеченную через `p` или `P` и записанную в десятичном виде (напр.: `0x1.fp10` - это `1984`, где `0x1f / 16` умножено на 2<sup>10</sup>).

Примеры вадидных целочисленных констант: `3`, `345`, `0xff`, `0xBEBADA`.

Примеры валидных чисел с плавающей точкой: `3.0`, `3.1416`, `314.16e-2`, `0.31416E1`, `34e1`, `0x0.1E`, `0xA23p-4`, `0X1.921FB54442D18P+1`.

_Комментарии_ начинаются с последовательности `--`. Длинные комментарии (в несколько строк) помечаются через `--` с последующей длинной скобкой (`[[`), комментарием и закрывающей длинной скобкой.

### 3.2. Переменные

В переменных хранятся значения. В _Lua_ есть три типа переменных: глобальные, локальные и поля таблиц.

Имя может обозначить глобальную или локальную переменные (или же формальный параметр функции, который является частным случаем локальной переменной).

```
var ::= Name
```

Любая переменная по-умолчанию глобальная, если отдельно не помечена, как локальная (см. [[#3.3.7. Локальные объявления]]). Локальные переменные лексически зависят от области видимости: они могут быть доступны внутри функций, в области видимости которых они определены (см. [[#3.5. Правила видимости]]).

До первого присвоения, значение переменной - `nil`.

Квадратные скобки используются для индексации таблиц:

```
var ::= prefixexp '[' exp ']'
```

Ниже - пример синтаксического расширения для доступа к полям таблиц:

```
var ::= prefixexp '.' Name
```

Доступ к глобальной переменной `x` эквивалентен `_ENV.x`. Сама переменная `_ENV` никогда не является глобальной.

### 3.3. Объявления

#### 3.3.1. Блоки

Блок - список объявлений, которые выполняются последовательно:

```
block ::= {stat}
```

Есть _пустые объявления_, которые позволяют разделять объявления точкой с запятой, начинать блок с точкой с запятой или записать две точки с запятой последовательно:

```
stat ::= ';'
```

Вызовы функций и присваивания могут начинаться с открытых скобок. Для фрагмента ниже

```lua
a = b + c
(print or io.write)('done')
```

грамматика может рассматриваться двумя путями:

```lua
a = b + c(print or io.write)('done')

a = b + c; (print or io.write)('done')
```

Парсер на данный момент выбирает первый путь, интерпретируя открытые скобки, как начало аргументов вызова. Для избежания неоднозначности, желательно предварять точкой с запятой заявления в скобках:

```lua
;(print or io.write)('done')
```

Блок можнт быть разделён для продуцирования единственного объявления:

```
stat ::= do block end
```

Раздельные блоки полезны для контроля над областью видимости объявления переменных. Они также могут быть использованы для того, чтобы добавить `return` в середину другого блока (см. [[#3.3.4. Контролирующие структуры]]).

#### 3.3.2. Чанки

Единица компиляции в _Lua_ называется "_чанком_". Синтаксически он является блоком:

```
chunk ::= block
```

Чанк рассматривается, как тело анонимной функции с переменным числом аргументов (см. [[#3.4.11. Определение функций]]). Чанки могут определять локальные переменные, принимать аргументы и возвращать значения. Более того, эти анонимные функции компилируются, как в области видимости внешней локальной переменной `_ENV`. Результирующая функция всегда имеет `_ENV`, как единственную внешнюю переменную, даже если её не использует.

Чанк может храниться в файле или в строке хостовой программы. Для исполнения чанка он должен быть _загружен_ с предкомпиляцией кода в инструкции для виртуальной машины и, затем, _Lua_ выполнит скомпилированный код интерпретатором.

Чанки могут быть предкомпилированы в двоичный формат; см. _luac_ и функцию `string.dump()`. _Lua_ автоматически различает исходный код и двоичные данные (см. `load()`).

#### 3.3.3. Присвоение

Есть возможность множественного присвоения. Так, синтаксис присвоения определяет список переменных слева и список выражений справа. Элементы обоих списков разделяются запятыми:

```
stat ::= varlist '=' explist
varlist ::= var {',' var}
explist ::= exp {',' exp}
```

Выражения рассматриваются в [[#3.4. Выражения]].

До присвоения, список значений выравнивается по длине списка переменных (см. [[#3.4.12. Списки выражений, несколько результатов и выравнивание]]).

Если переменная одновременно присваивается и читается во множественном присвоении, _Lua_ удостоверяется, что все чтения получают значение переменной до присвоения. Так, код ниже

```lua
i = 3
i, a[i] = i+1, 20
```

устанавливает `a[3]` в `20` без влияния на `a[4]`, поскольку `i` в `a[i]` раскрывается в `3` до присвоения ей значения `4`. Так, строка

```lua
x, y = y, x
```

Меняет значения `x` и `y` местами, а

```lua
x, y, z = y, z, x
```

циклично переставляет значения `x`, `y` и `z`.

Присвоение глобального имени `x = val` эквивалентно присвоению `_ENV.x = val`.

#### 3.3.4. Контролирующие структуры

Контролирующие структуры `if`, `while` и `repeat` имеют обычное значение и знакомый синтаксис:

```
stat ::= while exp do block end
stat ::= repeat block until exp
stat ::= if exp then block {elseif exp then block} [else block] end
```

Условное выражение контролирующей структуры может возвращать любое значение. Всё отличное от `nil` и `false` - `true`.

В цикле `repeat`-`until` внутренний блок не кончается ключевым словом `until`, а при соответствии условиям. Условия могут ссылаться на локальные переменные, определённые внутри блока цикла.

`goto` передаёт контроль выполнения метке. Метки являются объявлениями:

```
stat ::= goto Name
stat ::= label
label ::= '::' Name '::'
```

Метка видна в целом блоке, в котором определена, исключая вложенные функции. В одной области видимости не может быть одноимённых меток.

`break` терминирует выполнение циклов `while`, `repeat` и `for`, перескакивая к следующему за циклом объявлению:

```
stat ::= break
```

`break` завершает самый глубокий вложенный цикл.

`return` используется для возврата значений из функции или чанка. Можно вернуть больше одного значения:

```
stat ::= return [explist] [';']
```

`return` может быть записан только как последнее объявление в блоке. Если необходим возврат из середины блока, используется раздельный внутренний блок, как в идеоме `do return end`, поскольку "теперь" `return` - последнее объявление внутреннего блока.

#### 3.3.5. Объявление _for_

`for` имеет две формы: численную и обобщённую.

__Численный цикл `for`__

Численный цикл выполняется, пока контрольная переменная арифметически прогрессирует:

```
stat ::= for Name '=' exp ',' exp [',' exp] do block end
```

Идентификатор (`Name`) определяет контрольную переменную, которая является новой переменной, локальной для тела цикла.

Вычисляются три значения для цикла: _начальное значение_, _лимит_ и _шаг_. Если шаг отсутствует, то он принимается за `1`.

Управляющие значения могут быть числами с плавающей точкой.

Шаг может быть отрицательным.

В случае переполнения управляющей переменной, цикл заканчивается.

__Обобщённый цикл `for`__

Обобщённый `for` работает с функциями, называющимися _итераторами_. На каждом шаге, итератор вызывается для получения нового значения. Цикл останавливается при возврате `nil` итератором. Синтаксис:

```
stat ::= for namelist in explist do block end
namelist ::= Name {',' Name}
```

Также может быть и такой синтаксис:

```
for var_1, ..., var_n in explist do body end
```

`var_i` объявляет переменные цикла локальные для его тела. Первые переменные - _управляющие_.

Цикл начинается с раскрытия `explist` для получения четырёх значений: _итератора_, _состояния_, _начального значения_ для переменной контроля и _завершающего значения_.

Далее, на каждом шаге вызывается итератор с двумя аргументами: состоянием и переменной контроля. Результаты вызова далее присваиваются переменным цикла. Как только переменная контроля становится `nil`, цикл заканчивается.

Завершающее значение ведёт себя, как переменная _to-be-closed_ (см. [[#3.3.8. Переменные _to-be-closed_]]), которая может использоваться для освобождения ресурсов после завершения цикла.

#### 3.3.6. Вызов функций, как объявлений

В примере ниже все возвращаемые переменные отбрасываются (см. [[#3.4.10. Вызов функций]]):

```
stat ::= functioncall
```

#### 3.3.7. Локальные объявления

Локальные переменные могут быть объявлены в любом месте блока. Объявление может включать в себя инициализацию:

```
stat ::= local attnamelist ['=' explist]
attnamelist ::= Name attrib {',' Name attrib}
```

Если нет инициализации, все переменные равны `nil`.

Каждое имя переменной может быть с постфиксом-атрибутом:

```
attrib ::= ['<' Name '>']
```

Есть два атрибута: `const` для константных переменных (ей нельзя ничего присваивать после объявления); `close` для переменных _to-be-closed_ (см. [[#3.3.8. Переменные _to-be-closed_]]). Список переменных может содержать максимум одну переменную _to-be-closed_.

Правила видимости локальных переменных см. в [[#3.5. Правила видимости]].

#### 3.3.8. Переменные _to-be-closed_

Переменная _to-be-closed_ ведёт себя, как локальная константа, за исключением того, что её значение _закрывается_, когда переменная выходит из области видимости, включая обычную терминацию блока, выход из блока при помощи `break`/`goto`/`return` или выход с ошибкой.

"Закрыть" переменную означает вызвать её метаметод `__close()`. При вызове метаметода, само значение передаётся в качестве первого аргумента и объект ошибки (если таковой имеется) в качестве второго (если ошибки нет, второй аргумент - `nil`).

Значение переменной _to-be-closed_ должно иметь метаметод `__close()` или быть ложным.

Если несколько переменных _to-be-closed_ выходят из области видимости при возникновении одного события, они закрываются в обратном от объявления порядке.

Для ситуаций с сопрограммами, когда переменные не закрываются, можно использовать финализаторы или вызвать `coroutine.close()`.

### 3.4. Выражения

Простейшие выражения в _Lua_:

```
exp ::= prefixexp
exp ::= nil | false | true
exp ::= Numeral
exp ::= LiteralString
exp ::= functiondef
exp ::= tableconstructor
exp ::= '...'
exp ::= exp binop exp
exp ::= unop exp
prefixexp ::= var | functioncall | '(' exp ')'
```

#### 3.4.1. Арифметические операторы

Поддерживаемые арифметические операторы:

 + `+`: сложение
 + `-`: вычитание
 + `*`: умножение
 + `/`: деление чисел с плавающей точкой
 + `//`: деление до целой части
 + `%`: вычисление остатка от деления
 + `^`: возведение в степень
 + `-`: унарный минус

За исключением возведения в степень и деления чисел с плавающей точкой, операторы работают следующим образом: если оба операнда - целочисленные, операция выполняется над ними и результат тоже целочисленный. Иначе, если оба операнда - числа, они конвертируются в числа с плавающей точкой и операция выполняется по правилам арифметики чисел с плавающей точкой конкретной машины (обычно это __IEEE 754__) и результат - число с плавающей точкой (библиотека строк может сконвертировать строки в числа для арифметических операций, см. [[#3.4.3. Принудительные операции и конверсия]]]]).

Возведение в степень и деление чисел с плавающей точкой всегда конвертируют операнды в числа с плавающей точкой, результат соответствующий. Возведение в степень использует функцию _C_ `pow()`.

#### 3.4.2. Побитовые операторы

Поддерживаются следующие побитовые операторы:

 + `&`: побитовое _И_
 + `|`: побитовое _ИЛИ_
 + `~`: побитовое _исключающее ИЛИ_
 + `>>`: сдвиг вправо
 + `<<`: сдвиг влево
 + `~`: _НЕ_

Побитовые операции конвертируют операнды в целые числа (см. [[#3.4.3. Принудительные операции и конверсия]]).

Сдвиги заполняют свободные биты нулями.

#### 3.4.3. Принудительные операции и конверсия

_Lua_ может автоматически конвертировать типы во время выполнения. Все операции со смешанными числами конвертируют их в числа с плавающей точкой. Конкатенация строк принимает числа в качестве аргументов.

В некоторых случаях строки могут рассматриваться, как числа. Метаметоды стандартной библиотеки строк могут попытаться конвертировать строки в числа во всех арифметических операциях.

`"1"==1` - `false`, `"1"<1` вызывает ошибку (см. [[#3.4.4. Операторы отношений]]). Данное поведение существует для совместимости.

Конвертируемая в число строка может иметь лидирующие или завершающие пробелы, как и знаки.

Для конвертирования чисел в строки можно использовать `string.format()`.

#### 3.4.4. Операторы отношений

 + `==`: равенство
 + `~=`: неравенство
 + `<`: меньше, чем
 + `>`: больше, чем
 + `<=`: меньше или равно
 + `>=`: больше или равно

Результатом всегда будет булево значение.

`==` сначала сравнивает типы операндов. Если они различаются, результат - `false`.

Таблицы, пользовательские данные и потоки сравниваются по ссылкам: два объекта равны только если они являются тем же самым объектом.

Сравнения таблиц можно кастомизировать метаметодом `__eq()`.

В сравнениях строки не конвертируются в числа и наоборот.

`NaN` не может быть равно (или) меньше/больше любого значения (включая самого себя).

#### 3.4.5. Логические операторы

Логические операторы - это: `and`, `or` и `not`.

`not` всегда возвращает булево значение. `and` возвращает свой первый аргумент, если это значение `false` или `nil`; иначе, `and` вернёт второй аргумент. `or` возвращает первый аргумент, если его значение отличается от `nil` и `false`; иначе, `or` вернёт второй аргумент.

```lua
10 or 20
10 or error()
nil or "a"
nil and 10
false and error()
false and nil
false or nil
10 and 20
```

#### 3.4.6. Конкатенация

Конкатенация строк выполняется оператором `..`. Числа конвертируются в строки; если невозможно, вызывается метаметод `__concat()`.

#### 3.4.7. Оператор длины

Оператор длины обозначается унарным префиксным оператором `#`.

Длина строки - количество байт.

Оператор длины для таблицы возвращает её _границу_. Граница - это число, удовлетворяющее следующим условиям:

```lua
(border == 0 or t[border] ~= nil) and
(t[border + 1] == nil or border == math.maxinteger)
```

Таблица с одной границей называется _последовательностью_. Пример: таблица `{10, 20, 30, 40, 50}`, в которой граница - `5`. Пример таблицы, не являющейся последовательностью с тремя границами: `{nil, 20, 30, nil, nil, 60, nil}`; границы `0`, `3` и `6`.

Если `t` - не последовательность, `#t` может вернуть любую из её границ.

Вычисление длины таблицы имеет гарантированное худшее время в `O(log n)`, где `n` - крупнейший целочисленный ключ таблицы.

#### 3.4.8. Старшинство

Старшинство операторов от низшего приоритета к высшему:

 + `or`
 + `and`
 + `<` `>` `<=` `>=` `~=` `==`
 + `|`
 + `~`
 + `&`
 + `<<` `>>`
 + `..`
 + `+` `-`
 + `*` `/` `//` `%`
 + `not` `#` `-` `~`
 + `^`

#### 3.4.9. Конструкторы таблиц

Конструктор таблиц может создать как пустую таблицу, так и таблицу с инициализированными полями. Общий синтаксис:

```
tableconstructor ::= '{' [fieldlist] '}'
fieldlist ::= field {fieldsep field} [fieldsep]
field ::= '[' exp ']' '=' exp | Name '=' exp | exp
fieldsep ::= ',' | ';'
```

Каждое поле вида `[exp1] = exp2` добавляет в новую таблицу запись с ключом `exp1` и значением `exp2`. Поле вида `name = exp` эквивалентно `["name"] = exp`. Поля формы `exp` эквивалентны `[i] = exp`, где `i` - последовательные числа, начинающиеся с `1`.

Пример ниже

```lua
a = { [f(1)] = g; "x", "y"; x = 1, f(x), [30] = 23; 45}
```

эквивалентен данному:

```lua
do
	local t = {}
	t[f(1)] = g
	t[1] = "x" -- 1st exp
	t[2] = "y" -- 2nd exp
	t.x = 1 -- t["x"] = 1
	t[3] = f(x) -- 3rd exp
	t[30] = 23
	t[4] = 45 --4th exp
	a = t
end
```

Порядок присвоений не определён.

Если последнее поле в списке имеет форму `exp` и выражение многомерно, все значения, возвращаемые выражением, вставляются в список последовательно (см. [[#3.4.12. Списки выражений, несколько результатов и выравнивание]]).

#### 3.4.10. Вызов функций

Синтаксис вызова функции:

```
functioncall ::= prefixexp args
```

В вызове функции первый `perfixexp` и `args` раскрываются. Если значение `prefixexp` - функция, тогда вызывается данная функция с данными аргументами. Иначе, если существует, вызывается метаметод `__call()` для `prefixexp`: его первый аргумент - значение `prefixexp` с последующими аргументами `args`.

Вид

```
functioncall ::= prefixexp ':' Name args
```

Может быть использован для эмуляции методов. Вызов `v:name(args)` - синтаксическое расширение для `v.name(v,args)`, но `v` раскрывается единожды.

Аргументы имеют следующий синтаксис:

```
args ::= '(' [explist] ')'
args ::= tableconstructor
args ::= LiteralString
```

Все выражения аргументов раскрываются до вызова. Вызов вида `f{fields}` - синтаксическое расширение для `f({fields})`. Вызовы вида `f'string'`, `f"string"` и `f[[string]]` - синтаксическое расширение для `f('string')`.

Вызов вида `return functioncall` вне области видимости переменной _to-be-closed_ называется _хвостовым вызовом_. Предела вызовов вложенных хвостовых вызовов нет. Хвостовой вызов стирает отладочную информацию функции, сделавшей его. Примеры ниже __не являются__ хвостовыми вызовами:

```lua
return (f(x)) -- results adjusted to 1
return 2 * f(x) -- result multiplied by 2
return x, f(x) -- additional results
f(x); return -- results discarded
return x or f(x) -- results adjusted to 1
```

#### 3.4.11. Определение функций

Синтаксис определения функции:

```
functiondef ::= function funcbody
funcbody ::= '(' [parlist] ')' block end
```

Синтаксическое расширение:

```
stat ::= function funcname funcbody
stat ::= local function Name funcbody
funcname ::= Name {'.' Name} [':' Name]
```

Заявление

```lua
function f () body end
```

транслируется в

```lua
f = function () body end
```

Заявление

```lua
function t.a.b.c.f () body end
```

транслируется в

```lua
t.a.b.c.f = function () body end
```

Заявление

```lua
local function f () body end
```

транслируется в

```lua
local f; f = function () body end
```

, но не в

```lua
local f = function () body end
```

Определение функции - исполняемое выражение, значение которого имеет тип функции. При прекомпиляции чанка, все тела его функций прекомпилируюися, но не создаются. Далее, когда функция выполняется, она _инстанциируется_ (замыкается). Экземпляр функции (_замыкание_) - финальное значение выражения.

Параметры ведут себя, как локальные переменные, которые проинициализированы значениями аргументов:

```
parlist ::= namelist [',' '...'] | '...'
```

При вызове функции, аргументы выравниваются по длине списка параметров (см. [[#3.4.12. Списки выражений, несколько результатов и выравнивание]]), если функция не является _вариативной_, которая имеет троеточие (`...`) в конце списка параметров. Вариативная функция не выравнивает список аргументов; вместо этого, она собирает все дополнительные аргументы и передаёт их функции через _выражение vararg_, которое тоже является троеточием. Значение данного выражения - список актуальных дополнительных аргументов, как в функции с несколькими результатами (см. [[#3.4.12. Списки выражений, несколько результатов и выравнивание]]).

Пример определений:

```lua
function f(a, b) end
function g(a, b, ...) end
function r() return 1,2,3 end
```

Пример их вызовов:

```lua
f(3) -- a=3, b=nil
f(3, 4) -- a=3, b=4
f(3, 4, 5) -- a=3, b=4
f(r(), 10) -- a=1, b=10
f(r()) -- a=1, b=2

g(3) -- a=3, b=nil, ... --> (nothing)
g(3, 4) -- a=3, b=4, ... --> (nothing)
g(3, 4, 5, 8) -- a=3, b=4, ... -> 5 8
g(5, r()) -- a=5, b=1, ... --> 2 3
```

Если функция доходит до конца, где нет `return`, функция не возвращает результата.

Количество возвращаемых значений зависит от системы (гарантированно больше `1000`).

Двоеточие используется для эмуляции методов, добавляя отдельный дополнительный параметр `self` к функции. Так, объявление

```lua
function t.a.b.c.f (params) body end
```

является синтаксическим расширением для

```lua
t.a.b.c.f = function (self, params) body end
```

#### 3.4.12. Списки выражений, несколько результатов и выравнивание

Вызовы функций и выражения _vararg_ могут возвращать несколько результатов.

Когда мультирезультирующее выражение используется в качестве последнего элемента списка выражений, все результаты из выражения добавлеются в список значений, продуцируемых списком выражений. Одно выражение, которое ожидает список выражений - последние выражение в для данного списка.

Случаи, когда _Lua_ ожидает список выражений:

 + Объявление `return`, напр.: `return e1, e2, e3`
 + Конструктор таблиц, напр.: `{e1, e2, e3}`
 + Аргументы вызова функции, напр.: `foo(e1, e2, e3)`
 + Множественное присвоение, напр.: `a, b, c = e1, e2, e3`
 + Локальное объявление, напр.: `local a, b, c = e1, e2, e3`
 + Начальное значение в обобщённом цикле `for`, напр.: `for k in e1, e2, e3 do ... end`

В последних четырёх счучаях, список значений из списка выражений должен быть _выровнен_ по определённой длине: число параметров в вызове не-вариативной функции, число переменных во множественном присвоении или локальном объявлении и точно `4` значений для обобщённого цикла `for`. Выравнивание следует правилам: если значений больше нужного, дополнительные значения отбрасываются; если значений меньше нужного, список расширяется `nil`'ами. Когда список выражений заканчивается мультирезультирующим выражением, все результаты этого выражения вставляются в список значений до выравнивания.

Когда мультирезультирующее выражение используется в списке выражений, но не является последним элементом или в том месте, где синтаксис ожидает единичное выражение, _Lua_ выравнивает результат данного выражения к одному элементу.

Примеры использования мультирезультирующих выражений:

```lua
print(x, f()) -- prints x and all results from f()
print(x, (f())) -- prints x and the first result from f()
print(f(), x) -- prints the first result from f() and x
print(1 + f()) -- prints 1 added to the first result from f()
local x = ... -- x gets the first vararg argument
x,y = ... -- x gets the first vararg argument; y gets the second vararg argument
x,y,z = w, f() -- x gets w, y gets the second result from f(), z gets the third result from f()
x,y,z = f(), g() -- x gets the first result from f(), y gets the first result from g(), z gets the second result from g()
x,y,z = (f()) -- x gets the first result from f(), y and z get nil
return f() -- returns all results from f()
return x, ... -- returns xand all received vararg arguments
return x,y,f() -- returns x, y and all results from f()
{f()} -- creates a list with all results from f()
{...} -- creates a list with all vararg arguments
{f(), 5} -- creates a list with the first result from f() and 5
```

### 3.5. Правила видимости

```lua
x = 10 -- global variable
do -- new block
	local x = x -- new 'x', with value 10
	print(x) -- 10
	x = x+1
	do -- another block
		local x = x+1 -- another 'x'
		print(x) -- 12
	end
	print(x) -- 10 (the global one)
```

Каждое выполнение `local` определяет новую локальную переменную. В примере ниже цикл создаёт десять замыканий. Каждое из этих замыканий использует свою переменную `y`, но у всех общая `x`:

```lua
a = {}
local x = 20
for i = 1, 10 do
	local y = 0
	a[i] = function () y = y + 1; return x + y end
end
```

## 4. Интерфейс приложения

Данная секция описывает _C_ __API__ для _Lua_, т.е. набор функций для хостовой программы, при помощи которых она может взаимодействовать с _Lua_. Все функции __API__ и соответствующие типы данных объявлены в `lua.h`.

Компиляция _Lua_ с флагом `LUA_USE_APICHECK` заставляет проверять аргументы функций __API__ на валидность и консистентность.

Вся информация хранится в динамической структуре _Lua state_.

Каждый _Lua state_ имеет один или более поток, каждый из которых привязан к независимой ветви исполнения.

### 4.1. Стэк

_Lua_ использует _виртуальный стэк_ для передачи значений из и в _C_. Каждый элемент стэка представляет значение _Lua_. Фунции в __API__ могут получить доступ к стэку через параметр состояния _Lua_, который они получают.

При вызове _C_ из _Lua_, вызываемая функция получает новый стэк, который независим от предыдущих и стэков функций _C_. Данный стэк изначально содержит любый аргументы _C_-функции и является тем местом, где _C_ может хранить временные значения _Lua_ и должен класть результаты для возврата вызываемому (см. `lua_CFunction`).

Запросы могут ссылаться на любой элемент в стэке, используя _индекс_: положительный индекс представляет абсолютную позицию в стэке, начиная с `1`, как с низа стэка; отрицательный индекс представляет сдвиг по отношению к вершине стэка (`-1` представляет последний элемент).

#### 4.1.1. Размер стэка

При работе с __API__ нужно следить за переполнением стэка. При вызове любой функции __API__, нужно удостовериться, что в стэке достаточно места для результата.

Исключение из данного правила: когда вызывается функция _Lua_ без фиксированного числа результатов (см. `lua_call()`), _Lua_ проверяет, что в стэке достаточно места для всех результатов, но не гарантирует дополнительного места. Перед тем, как положить что-то в стэк, нужно вызывать `lua_checkstack()`.

Когда _Lua_ вызывает _C_, он удостоверяется, что в стэке есть место для, как минимум `LUA_MINSTACK` элементов. `LUA_MINSTACK` определён, как `20`.

#### 4.1.2. Валидные и приемлемые индексы

Любая функция в __API__, принимающая индексы стэка, работает только с _валидными_ и _приемлемыми_ индексами.

_Валидный индекс_ - индекс, ссылающийся на позицию, хранящую модифицируемое значение _Lua_. Он включает в себя индексы между `1` и вершиной стэка (`1 <= abs(index) <= top`) плюс _псевдо-индексы_, которые представляют некоторые позиции, доступные из _C_, но не находящиеся в стэке. Псевдо-индексы используются для доступа к регистру (см. [[#4.3. Регистр]]) и к _upvalue_ функций _C_ (см. [[#4.2. Замыкания _C_]]).

Функции, не нуждающиеся в определённой изменяемой позиции, но только в значении (запросы), могут быть вызваны приемлемыми индексами. _Приемлемый индекс_ может быть любым валидным индексом, но также может быть любым положительным индексом после вершины стэка внутри пространства, выделенного для стэка. Индексы на _upvalue_ (см. [[#4.2. Замыкания _C_]]) большие, чем реальное число _upvalue_ в текущей функции _C_, также приемлемы (но невалидны).

Приемлемые индексы нужны для избежания дополнительных проверок вершины стэка.

Для функций, которые могут быть вызваны приемлемыми индексами, любой невалидный индекс обрабатывается, как индекс, хранящий значение виртуального типа `LUA_TNONE`, который ведёт себя, как `nil`.

#### 4.1.3. Указатели на строки

__API__ гарантирует, что любой указатель на строку в стэке валиден, пока значение строки по индексу не удаляется из стэка. Когда индекс - псевдо-индекс, указатель валиден, пока соответствующий вызов активен и соответствующее _upvalue_ не изменено.

### 4.2. Замыкания _C_

При создании _C_-функции, возможно ассоциировать некоторые значения с ней, создавая _замыкание C_ (см. `lua_pushcclosure()`); такие значения называются _upvalues_ и доступны для функции в любой момент.

Когда _C_-функция вызывается, её _upvalue_ находятся находятся по специальным псевдо-индексам. Псевдо-индексы создаются макросом `lua_upvalueindex()`. Первый _upvalue_, ассоциированный с функцией находится в `lua_upvalueindex(1)` и т.д.

### 4.3. Регистр

_Lua_ предоставляет _регистр_ - таблица, заранее определённая, которая может быть использована любым _C_-кодом для хранения данных в этой таблице, но нужно соблюдать осторожность при выборе ключей, чтобы избежать коллизий. Обычно, в качестве ключа используется строка, содержащая имя библиотеки или лёгкие пользовательские данные с адресом объекта кода _C_, или любой объект _Lua_. Как и с именами переменных, строковые ключи, начинающиеся с нижнего подчёркивания с последующими большими буквами, зарезервированы для _Lua_.

Целочисленные ключи в регистре используются механизмом ссылок (см. `luaL_ref()`) и некоторыми предопределёнными значениями.

При создании нового состояния _Lua_, его регистр имеет несколько предопределённых значений:

 + `LUA_RIDX_MAINTHREAD`: по этому индексу в регистре лежит основной поток (привязанный к состоянию) состояния.
 + `LUA_RIDX_GLOBALS`: по этому индексу регистр хранит глобальное окружение.

### 4.4. Обработка ошибок в _C_

Внутри _Lua_ использует `longjmp()` для обработки ошибок (или же будут использованы исключения, если компилировать с _C++_; см. `LUAI_THROW`). Как только обнаруживается ошибка, происходит длинный переход. _Защищённое окружение_ использует `setjmp()` для установки точки восстановления; любая ошибка переходит к последней активной точке восстановления.

Внутри _C_ можно вызвать ошибку через `lua_error()`.

Если ошибка возникает вне защищённого окружения, вызывается _функция паники_ (см. `lua_atpanic()`) и далее вызывается `abort()` с выходом из программы-хоста. Если никогда не делать возврата из функции паники, можно избежать завершения программы-хоста (длинный переход к собственной точки восстановления вне _Lua_).

#### 4.4.1. Коды статуса

 + `LUA_OK (0)`: нет ошибок.
 + `LUA_ERRRUN`: ошибка исполнения.
 + `LUA_ERRMEM`: ошибка выделения памяти. Для данных ошибок _Lua_ не вызывает обработчик сообщений.
 + `LUA_ERRERR`: ошибка выполнения обработчика сообщений.
 + `LUA_ERRSYNTAX`: ошибка синтаксиса во время прекомпиляции.
 + `LUA_YIELD`: ошибка нагрузки сопрограммы.
 + `LUA_ERRFILE`: ошибка обработки файла.

См. `lua.h`.

### 4.5. Обработка уступок в _C_

Внутри используется `longjmp()` для уступки для сопрограммы. Так, если функция _C_ `foo()` вызывает функцию __API__ и эта функция уступает (напрямую или опосредованно через вызов другой функции), _Lua_ не сможет вернуться к `foo()`, поскольку `longjmp()` удаляет его кадр из стэка _C_.

Для избежания такой проблемы, _Lua_ вызывает ошибку всякий раз, когда совершается попытка уступить через вызов __API__, за исключением трёх функций: `lua_yieldk()`, `lua_callk()` и `lua_pcallk()`. Все эти функции принимают _функцию континуации_ (как параметр `k`) для продолжения выполнения после уступки.

Допустим, есть _C_-функция, вызывающаяся из _Lua_, которую мы назовём _оригинальной функцией_. Эта оригинальная функция далее вызывает одну из упомянутых выше трёх функций, которые назовём _абонентскими функциями_, которым далее уступает текущй поток. Это может случиться, когда абонентская функция - `lua_yieldk()`, или когда абонентские функции - `lua_callk()` или `lua_pcallk()`, а функции, вызываемой ими, уступают.

Выполняемый поток уступает, пока выполняет абонентские функции. После продолжения потока, он закончится вызовом абонентской функции. Тем не менее, абонентские функции не могут вернуться к оригинальной функции, поскольку её кадр в стэке _C_ был уничтожен уступкой. Вместо этого, _Lua_ вызывает функцию континуации, которая была дана в качестве аргумента абонентской функции. Функция континуации должна продолжить выполнение задачи оригинальной функции.

Пример:

```c
int original_function (lua_State *L) {
/* code 1 ... */
	status = lua_pcall(L, n, m, h); /* calls Lua */
/* code 2 ... */
}
```

далее мы хотим позволить коду _Lua_ быть запущенным через `lua_pcall()` для уступки. Сначала, можем переписать пример выше так:

```c
int k (lua_State *L, int status, lua_KContext ctx) {
/* code 2 ...*/
}

int original_function (lua_State *L) {
/* code 1 ...*/
	return k(L, lua_pcall(L, n, m, h), ctx);
}
```

В коде выше новая функция `k()` является функцией континуации (тип - `lua_KFunction`), которая должна сделать всю работу, которую делает оригинальная функция после вызова `lua_pcall()`. Теперь мы должны оповестить _Lua_, что он должен вызвать `k()`, если код _Lua_, выполняемый через `lua_pcall()`, прерывается, потому переписываем код, заменяя `lua_pcall()` на `lua_pcallk()`:

```c
int original_function (lua_State *L) {
/* code 1 ... */
	return k(L, lua_pcallk(L, n, m, h, ctx2, k), ctx1);
}
```

Вызов континуации внешний и отдельный: _Lua_ вызовет континуацию только при необходимости (ошибка или продолжение после уступки).

Помимо состояния _Lua_, функция континуации имеет два других параметра: конечный статус вызова и значение контекста (`ctx`), которое оригинально было передано в `lua_pcallk()`. _Lua_ не использует данное значение контекста; оно передаётся от оригинальной функции к функции континуации. Для `lua_pcallk()`, статус тот же, что и вернётся из `lua_pcallk()`, за исключением того, что он - `LUY_YIELD` во время исполнения после уступки (вместо `LUA_OK`). Для `lua_yieldk()` и `lua_callk()` статус всегда `LUA_YIELD`, когда _Lua_ вызывает континуацию. Также, при использовании `lua_callk()` нужно вызывать функцию континуации с `LUA_OK` в качестве статуса.

### 4.6. Функции и типы

__lua_absindex()__

```c
int lua_absindex (lua_State *L, int idx);
```

Конвертирует приемлемый индекс `idx` в эквивалентный абсолютный индекс.

__lua_Alloc__

```c
typedef void * (*lua_Alloc) (void *ud, void *ptr, size_t osize, size_t nsize);
```

Тип функции выделения памяти для состояний _Lua_.

Простейшая имплементация аллокатора, использующая `luaL_newstate()`:

```c
static void *l_alloc (void *ud, void *ptr, size_t osize, size_t nsize) {
	(void)ud; (void)osize; /* not used */
	if (nsize == 0) {
		free(ptr);
		return NULL;
	}
	else
		return realloc(ptr, nsize);
}
```

__lua_arith()__

```c
void lua_arith (lua_State *L, int op);
```

Выполняет арифметическую или побитовую операцию над двумя значениями на вершине стэка, где значение на вершине - второй операнд. Значения выталкиваются из стэка, результат - помещается.

`op`:

 + `LUA_OPADD`: сложение.
 + `LUA_OPSUB`: вычитание.
 + `LUA_OPMUL`: умножение.
 + `LUA_OPDIV`: деление чисел с плавающей точкой.
 + `LUA_OPIDIV`: деление без остатка.
 + `LUA_OPMOD`: вычисление остатка от деления.
 + `LUA_OPPOW`: возведение в степень.
 + `LUA_OPUNM`: арифметическое отрицание.
 + `LUA_OPBNOT`: побитовое НЕ.
 + `LUA_OPBAND`: побитовое И.
 + `LUA_OPBOR`: побитовое ИЛИ.
 + `LUA_OPBXOR`: побитовое исключающее ИЛИ.
 + `LUA_OPSHL`: побитовый сдвиг влево.
 + `LUA_OPSHR`: побитовый сдвиг вправо.

__lua_atpanic()__

```c
lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf);
```

Устанавливает новую функцию паники и возвращает старую.

__lua_call()__

```c
void lua_call (lua_State *L, int nargs, int nresults);
```

Вызов функции. Соответствует метаметоду `__call()`.

Данный пример на _Lua_:

```lua
a = f("how", t.x, 14)
```

эквивалентен данному на _C_:

```c
lua_getglobal(L, "f"); /* function to be called */
lua_pushliteral(L, "how"); /* 1st argument */
lua_getglobal(L, "t"); /* table to be indexed */
lua_getfield(L, -1, "x"); /* push result of t.x (2nd arg) */
lua_remove(L, -2); /* remove 't' from the stack */
lua_pushinteger(L, 14); /* 3rd argument */
lua_call(L, 3, 1); /* call 'f' with 3 arguments and 1 result */
lua_setglobal(L, "a"); /* set global 'a' */
```

__lua_callk()__

```c
void lua_callk (lua_State *L, int nargs, int nresults, lua_KContext ctx, lua_KFunction k);
```

Функция аналогична `lua_call()`, но позволяет вызывающей функции уступить.

__lua_CFunction__

```c
typedef int (*lua_CFunction) (lua_State *L);
```

Тип для функций _C_.

Пример, где функция принимает переменное число числовых аргументов и возвращает их среднее значение и сумму:

```c
static int foo (lua_State *L) {
	int n = lua_gettop(L); /* number of arguments */
	lua_Number sum = 0.0;
	int i;
	for (i = 1; i <= n; i++) {
		if (!lua_isnumber(L, i)) {
			lua_pushliteral(L, "incorrect argument");
			lua_error(L);
		}
		sum += lua_tonumber(L, i);
	}
	lua_pushnumber(L, sum/n); /* first result */
	lua_pushnumber(L, sum); /* second result */
	return 2; /* number of results */
}
```

__lua_checkstat()__

```c
int lua_checkstat (lua_State *L, int n);
```

Удостоверяется, что в стэке есть место хотя бы для `n` дополнительных элементов.

__lua_close()__

```c
void lua_close (lua_State *L);
```

Закрывает все активные переменные _to-be-closed_ в основном потоке. освобождает все объекты данного состояния _Lua_ (вызывая соответствующий __GC__) и освобождает всю динамическую память, используемую данным состоянием.

__lua_closeslot()__

```c
void lua_closeslot (lua_State *L, int index);
```

Закрывает слот _to-be-closed_ для данного индекса и устанавливает значение в `nil`.

__lua_closethread()__

```c
int lua_closethread (lua_State *L, lua_State *from);
```

Сбрасывает поток, очищая его стек и закрывая все ожидающие переменные _to-be-closed_.

__lua_compare()__

```c
int lua_compare (lua_State *L, int index1, int index2, int op);
```

Сравнивает два значения _Lua_.

`op`:

 + `LUA_OPEQ`: равенство.
 + `LUA_OPLT`: меньше.
 + `LUA_OPLE`: меньше или равно.

__lua_concat()__

```c
void lua_concat (lua_State *L, int n);
```

Конкатенация `n` значений на вершине стека. Выталкивает их и кладёт результат на вершину.

__lua_copy()__

```c
void lua_copy (lua_State *L, int fromidx, int toidx);
```

Копирует элемент по индексу `fromidx` в валидный индекс `toidx`, замещая значение на целевой позиции.

__lua_createtable()__

```c
void lua_createtable (lua_State *L, int narr, int nrec);
```

Создаёт новую пустую таблицу и помещает её в стек.

__lua_dump()__

```c
int lua_dump (lua_State *L, lua_Writer writer, void *data, int strip);
```

Дамп функции в виде двоичного чанка.

__lua_error()__

```c
int lua_error (lua_State *L);
```

Вызов ошибки _Lua_.

__lua_gc()__

```c
int lua_gc (lua_State *L, int what, ...);
```

Управление сборщиком мусора.

 + `LUA_GCOLLECT`: выполнение цикла сборки мусора.
 + `LUA_GCSTOP`: остановка __GC__.
 + `LUA_GCRESTART`: перезапуск __GC__.
 + `LUA_GCCOUNT`: возврат текущего количества памяти в Кбайт, используемой _Lua_.
 + `LUA_GCCOUNTB`: возврат остатка от деления текущей используемой памяти в байтах на `1024`.
 + `LUA_GCSTEP (int stepsize)`: инкрементный шаг сборки мусора, соответствующий выделению `stepsize` Кбайт.
 + `LUA_GCISRUNNING`: узнать, запущен ли __GC__ или нет (`boolean`).
 + `LUA_GCINC (int pause, int stepmul, stepsize)`: __GC__ переводется в инкрементный режим с данными параметрами. Возвращает предыдущий режим (`LUA_GCGEN` или `LUA_GCINC`).
 + `LUA_GCGEN (int minormul, int majormul)`: __GC__ преводится в поколенческий режим с данными параметрами. Возвращает предыдущий режим.

__lua_getallocf()__

```c
lua_Alloc lua_getallocf (lua_State *L, void **ud);
```

Возвращает функцию выделения памяти для данного состояния.

__lua_getfield()__

```c
int lua_getfield (lua_State *L, int index, const char *k);
```

Помещает в стек значение `t[k]`, где `t` - значение данного индекса.

__lua_getextraspace()__

```c
void *lua_getextraspace (lua_State *L);
```

Возвращает указатель на область сырой памяти с данным состоянием _Lua_.

__lua_getglobal()__

```c
int lua_getblobal (lua_State *L, const char *name);
```

Помещает в стек значение глобального имени.

__lua_geti()__

```c
int lua_geti (lua_State *L, int index, lua_Integer i);
```

Помещает в стек значение `t[i]`, где `t` - значение с данным индексом.

__lua_getmetatable()__

```c
int lua_getmetatable (lua_State *L, int index);
```

Если значение по данному индексу имеет метатаблицу, функция помещает её в стек и возвращает `1`.

__lua_gettable()__

```c
int lua_gettable (lua_State *L, int index);
```

Помещает в стек значение `t[k]`, где `t` - значение по данному индексу и `k` - значение на вершине стека.

__lua_gettop()__

```c
int lua_gettop (lua_State *L);
```

Возвращает индекс верхнего элемента стека.

__lua_getiuservalue()__

```c
int lua_getiuservalue (lua_State *L, int index, int n);
```

Помещает в стек `n`-ное пользовательское значение, ассоциированное с полными пользовательскими данными по данному индексу и возвращает тип помещённого значения.

__lua_insert()__

```c
void lua_insert (lua_State *L, int index);
```

Перемещает верхний элемент на данный валидный индекс, сдвигая вверх элементы.

__lua_Integer__

```c
typedef ... lua_Integer;
```

Тип целых чисел в _Lua_.

__lua_isboolean()__

```c
int lua_isboolean (lua_State *L, int index);
```

Возвращает `1`, если значение по индексу булево типа, иначе - `0`.

__lua_iscfunction()__

```c
int lua_iscfunction (lua_State *L, int index);
```

__lua_isfunction()__

```c
int lia_isfunction (lua_State *L, int index);
```

__lua_isinteger()__

```c
int lua_isinteger (lua_State *L, int index);
```

__lua_islightuserdata()__

```c
int lua_islightuserdata (lua_State *L, int index);
```

__lua_isnil()__

```c
int lua_isnil (lua_State *L, int index);
```

__lua_isnone()__

```c
int lua_isnone (lua_State *L, int index);
```

__lua_isnoneornil()__

```c
int lua_isnoneornil (lua_State *L, int index);
```

__lua_isnumber()__

```c
int lua_isnumber (lua_State *L, int index);
```

__lua_isstring()__

```c
int lua_isstring (lua_State *L, int index);
```

__lua_istable()__

```c
int lua_istable (lua_State *L, int index);
```

__lua_isthread()__

```c
int lua_isthread (lua_State *L, int index);
```

__lua_isuserdata()__

```c
int lua_isuserdata (lua_State *L, int index);
```

__lua_isyieldable()__

```c
int lua_isyeldable (lua_State *L);
```

__lua_KContext__

```c
typedef ... lua_KContext;
```

Тип для контекстов функций континуации.

__lua_KFunction__

```c
typedef int (*lua_KFunction) (lua_State *L, int status, lua_KContext ctx);
```

Тип для функций континуации.

__lua_len()__

```c
void lua_len (lua_State *L, int index);
```

Возвращает размер значения по данному индексу.

__lua_load()__

```c
int lua_load (lua_State *L, lua_Reader reader, void *data, const char *chunkname, const char *mode);
```

Загружает чанк _Lua_ без его запуска.

__lua_newstate()__

```c
lua_State *lua_newstate (lua_Alloc f, void *ud);
```

Создаёт новое независимое состояние и возвращает его основной поток.

__lua_newtable()__

```c
void lua_newtable (lua_State *L);
```

Создаёт пустую таблицу и помещает её в стек.

__lua_newthread()__

```c
lua_State *lua_newthread (lua_State *L);
```

Создаёт новый поток, помещает его в стек и возвращает указатель на `lua_State`, представляющий этот новый поток.

__lua_newuserdatauv()__

```c
void *lua_newuserdatauv (lua_State *L, size_t size, int nuvalue);
```

Функция создаёт и помещает в стек новые полные пользовательские данные с ассоциированными значениями `nuvalue` и ассоциированный блок сырой памяти размером `size` байт.

__lua_next()__

```c
int lua_next (lua_State *L, int index);
```

Функция выталкивает ключ из стека и помещает в стек пару ключ-значение из таблицы по заданному индексу, следующему после следующей пары после данного ключа.

Пример:

```c
/* table is in the stack at index 't' */
lua_pushnil(L); /* first key */
while (lua_next(L, t) != 0) {
	/* uses 'key' (at index -2) and 'value' (at index -1) */
	printf("%s - %s\n", lua_typename(L, lua_type(L, -2)), lua_typename(L, lua_type(L, -1)));
	/* removes 'value'; keeps 'key' for next iteration */
	lua_pop(L, 1);
}
```

__lua_Number__

```c
typedef ... lua_Number;
```

Тип чисел с плавающей точкой.

__lua_numbertointeger()__

```c
int lua_numbertointeger (lua_Number n, lua_Integer *p);
```

Функция попытается конвертировать число с плавающей точкой в целое число.

__lua_pcall()__

```c
int lua_pcall (lua_State *L, int nargs, int nresults, int msgh);
```

Вызывает функцию (или вызываемый объект) в защищённом режиме.

__lua_pcallk()__

```c
int lua_pcallk (lua_State *L, int nargs, int nresults, int msgh, lua_KContext ctx, lua_KFunction k);
```

Функция аналогична `lua_pcall()`, но позволяет функции уступать.

__lua_pop()__

```c
void lua_pop (lua_State *L, int n);
```

Выталкивает `n` элементов из стека.

__lua_pushboolean()__

```c
void lua_pushboolean (lua_State *L, int b);
```

Помещает булево значение `b` в стек.

__lua_pushcclosure()__

```c
void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n);
```

__lua_pushcfunction()__

```c
void lua_pushcfuntion (lua_State *L, lua_CFunction f);
```

__lua_pushfstring()__

```c
const char *lua_pushfstring (lua_State *L, const char *fmt, ...);
```

__lua_pushglobaltable()__

```c
void lua_pushglobaltable (lua_State *L);
```

__lua_pushinteger()__

```c
void lua_pushinteger (lua_State *L, lua_Integer n);
```

__lua_pushlightuserdata()__

```c
void lua_pushlightuserdata (lua_State *L, void *p);
```

__lua_pushliteral()__

```c
const char *lua_pushliteral (lua_State *L, const char *s);
```

__lua_pushlstring()__

```c
const char *lua_pushlstring (lua_State *L, const char *s, size_t len);
```

__lua_pushnil()__

```c
void lua_pushnil (lua_State *L);
```

__lua_pushnumber()__

```c
void lua_pushnumber (lua_State *L, lua_Number n);
```

__lua_pushstring()__

```c
const char *lua_pushstring (lua_State *L, const char *s);
```

__lua_pushthread()__

```c
int lua_pushthread (lua_State *L);
```

__lua_pushvalue()__

```c
void lua_pushvalue (lua_State *L, int index);
```

__lua_pushvfstring()__

```c
const char *lua_pushvfstring (lua_State *L, const char *fmt, va_list argp);
```

__lua_rawequal()__

```c
int lua_rawequal (lua_State *L, int index1, int index2);
```

Сравнивает два значения по индексам `index1` и `index2`. Аналогично вызову метаметода `__eq()`.

__lua_rawget()__

```c
int lua_rawget (lua_State *L, int index);
```

Аналогично `lua_gettable()`, но даёт сырой доступ (без метаметодов).

__lua_rawgeti()__

```c
int lua_rawgeti (lua_State *L, int index, lua_Integer n);
```

Помещает в стек значение `t[n]`, где `t` - таблица по заданному индексу. Доступ сырой, потому не использует метазначение `__index`.

__lua_rawgetp()__

```c
int lua_rawgetp (lua_State *L, int index, const void *p);
```

Помещает в стек значение `t[k]`, где `t` - таблица по заданному индексу и `k` - указатель `p`, представленный в виде лёгких пользовательских данных. Доступ сырой, потому не использует метазначение `__index`.

__lua_rawlen()__

```c
lua_Unsigned lua_rawlen (lua_State *L, int index);
```

Возвращает сырую "длину" значения по заданному индексу.

__lua_rawset()__

```c
void lua_rawset (lua_State *L, int index);
```

Аналогична `lua_settable()`, но делает "сырое" присвоение (без метаметодов).

__lua_rawseti()__

```c
void lua_rawseti (lua_State *L, int index, lua_Integer i);
```

Эквивалент `t[i] = v`, где `t` - таблица по заданному индексу и `v` - значение на вершине стека. Значение выталкивается из стека. Присвоение сырое, потому не использует метазначение `__newindex`.

__lua_rawsetp()__

```c
void lua_rawsetp (lua_State *L, int index, const void *p);
```

Эквивалент `t[p] = v`, где `t` - таблица по заданному индексу, `p` представлена, как лёгкие пользовательские данные и `v` - значение на вершине стека.

__lua_Reader__

```c
typedef const char * (*lua_Reader) (lua_State *L, void *data, size_t *size);
```

Функция чтения, используемая `lua_load()`.

__lua_register()__

```c
void lua_register (lua_State *L, const char *name, lua_CFunction f);
```

Устанавливает функцию _C_ `f`, как новое значение глобального имени.

```c
#define lua_register(L,n,f) \
	(lua_pushcfunction(L, f), lua_setglobal(L, n))
```

__lua_remove()__

```c
void lua_remove (lua_State *L, int index);
```

Удаляет элемент по заданному валидному индексу, сдвигая вниз элементы выше удаляемого.

__lua_replace()__

```c
void lua_replace (lua_State *L, int index);
```

Перемещает верхний элемент стека в заданный валидный индекс без сдвига элементов и выталкивает его из стека.

__lua_resetthread()__

```c
int lua_resetthread (lua_State *L);
```

__lua_resume()__

```c
int lua_resume (lua_State *L, lua_State *from, int nargs, int *nresults);
```

Запускает и продолжает сопрограмму в заданном потоке `L`.

__lua_rotate()__

```c
void lua_rotate (lua_State *L, int idx, int n);
```

Ротирует на `n` позиций элементы стека между валидным индексом `idx` и вершиной стека.

__lua_setallocf()__

```c
void lua_setallocf (lua_State *L, lua_Alloc f, void *ud);
```

Меняет функцию аллокатора для данного состояния на `f` с пользовательскими данными `ud`.

__lua_setfield()__

```c
void lua_setfield (lua_State *L, int index, const char *k);
```

Эквивалент `t[k] = v`, где `t` - значение по заданному индексу и `v` - значение на вершине стека.

__lua_setglobal()__

```c
void lua_setglobal (lua_State *L, const char *name);
```

Выталкивает значение из стека и устанавливает го, как новое значение глобального имени.

__lua_seti()__

```c
void lua_seti (lua_State *L, int index, lua_Integer n);
```

Эквивалент `t[n] = v`, где `t` - значение по заданному индексу и `v` - значание на вершине стека.

__lua_setiuservalue()__

```c
int lua_setiuservalue (lua_State *L, int index, int n);
```

Выталкивает значение из стека и устанавливает его, как новые полные пользовательские данные, ассоциированные с n-ным пользователем.

__lua_setmetatable()__

```c
int lua_setmetatable (lua_State *L, int index);
```

Выталкивает таблицу или `nil` их стека и устанавливает значение, как новую метатаблицу для значения по заданному индексу.

__lua_settable()__

```c
void lua_settable (lua_State *L, int index);
```

Эквивалент `t[k] = v`, где `t` - значение по заданному индексу, `v` - значение на вершине стека, `k` - значение под вершиной.

__lua_settop()__

```c
void lua_settop (lua_State *L, int index);
```

Принимает любой индекс или `0` и устанавливает вершину стека по заданному индексу.

__lua_setwarnf()__

```c
void lua_setwarnf (lua_State *L, lua_WarnFunction f, void *ud);
```

Устанавливает функцию предупреждения. `ud` передаётся в функцию предупреждения.

__lua_State__

```c
typedef struct lua_State lua_State;
```

Структура, указывающая на поток и опосредованно на состояние интерпретатора _Lua_.

__lua_status()__

```c
int lua_status (lua_State *L);
```

Возвращает статус потока `L`.

__lua_stringtonumber()__

```c
size_t lua_stringtonumber (lua_State *L, const char *s);
```

Конвертирует нуль-терминированную строку `s` в число, помещает число в стек и возвращает общую длину стррки.

__lua_toboolean()__

```c
int lua_toboolean (lua_State *L, int index);
```

Конвернтирует значение _Lua_ по заданному индексу в булево значение _C_.

__lua_tocfunction()__

```c
lua_CFunction lua_tocfunction (lua_State *L, int index);
```

Конвертирует значение по заданному индесу в функцию _C_.

__lua_toclose()__

```c
void lua_toclose (lua_State *L, int index);
```

Помечает заданный индекс в стеке, как слот _to-be-closed_.

__lua_tointeger()__

```c
lua_Integer lua_tointeger (lua_State *L, int index);
```

__lua_tointegerx()__

```c
lua_Integer lua_tointegerx (lua_State *L, int index, int *isnum);
```

__lua_tolstring()__

```c
const char *lua_tolstring (lua_State *L, int index, size_t *len);
```

__lua_tonumber()__

```c
lua_Number lua_tonumber (lua_State *L, int index);
```

__lua_tonumberx()__

```c
lua_Number lua_tonumberx (lua_State *L, int index, int *isnum);
```

__lua_topointer()__

```c
const void *lua_topointer (lua_State *L, int index);
```

__lua_tostring()__

```c
const char *lua_tostring (lua_State *L, int index);
```

__lua_tothread()__

```c
lua_State *lua_tothread (lua_State *L, int index);
```

__lua_touserdata()__

```c
void *lua_touserdata (lua_State *L, int index);
```

__lua_type()__

```c
int lua_type (lua_State *L, int index);
```

Возвращает тип значения по заданному валидному индексу или `LUA_TNONE` для невалидного, но приемлемого индекса. Типы могут быть: `LUA_TNIL`, `LUA_TNUMBER`, `LUA_TBOOLEAN`, `LUA_TSTRING`, `LUA_TFUNCTION`, `LUA_TUSERDATA`, `LUA_TTHREAD` или `LUA_TLIGHTUSERDATA`.

__lua_typename()__

```c
const char *lua_typename (lua_State *L, int tp);
```

Возвращает имя типа, закодированное значением `tp`.

__lua_Unsigned__

```c
typedef ... lua_Unsigned;
```

__lua_upvalueindex()__

```c
int lua_upvalueindex (int i);
```

Возвращает псевдо-индекс, представляющий `i`-е _upvalue_ в текущей функции. `i` должен быть в диапазоне от `1` до `256`.

__lua_version()__

```c
lua_Number lua_version (lua_State *L);
```

Возвращает версию.

__lua_WarnFunction__

```c
typedef void (*lua_WarnFunction) (void *ud, const char *msg, int tocont);
```

Тип для функций предупреждения.

__lua_warning()__

```c
void lua_warning (lua_State *L, const char *msg, int tocont);
```

Вызывает предупреждение с заданным сообщением.

__lua_Writer__

```c
typedef int (*lua_Writer) (lua_State *L, const void *p, size_t sz, void *ud);
```

Тип записывающей функции, используемой в `lua_dump()`.

__lua_xmove()__

```c
void lua_xmove (lua_State *from, lua_State *to, int n);
```

Обмен значениями между разными потоками одного состояния.

__lua_yield()__

```c
int lua_yield (lua_State *L, int nresults);
```

Эквивалент `lua_yieldk()` без возобновления.

__lua_yieldk()__

```c
int lua_yieldk (lua_State *L, int nresults, lua_KContext ctx, lua_KFunction k);
```

Уступка в сопрограмме (потоке).

### 4.7. Интерфейс отладки

Специальный интерфейс для отладки имеет функции и "_хуки_".

__lua_Debug__

```c
typedef struct lua_Debug {
	int event;
	const char *name; /* (n) */
	const char *namewhat; /* (n) */
	const char *what; /* (S) */
	const char *source; /* (S) */
	size_t srclen; /* (S) */
	int currentline; /* (l) */
	int linedefined; /* (S) */
	int lastlinedefined; /* (S) */
	unsigned char nups; /* (u) number of upvalues */
	unsigned char nparams; /* (u) number of parameters */
	char isvararg; /* (u) */
	char istailcall; /* (t) */
	unsigned short ftransfer; /* (r) index of first value transferred */
	unsigned short ntransfer; /* (r) number of transferred values */
	char short_src[LUA_IDSIZE]; /* (S) */
	/* private part */
...
} lua_Debug;
```

Структура, содержащая различную информацию о функции или записи активации.

 + `source`: исходный код чанка, создавшего функцию. Если начинается с "`@`", это значит, что функция была определена в файле, где имя файла следует за `@`. Если начинается с "`=`", остаток содержания описывает исходный код способом, зависящем от пользователя. Иначе, функция определена в строке поля `source`.
 + `srclen`: размер строки `source`.
 + `short_src`: "печатаемая" версия `source`, используемая в сообщениях об ошибках.
 + `linedefined`: номер строки, где начинается определение функции.
 + `lastlinedefined`: номер строки с определением конца  функции.
 + `what`: строка `Lua`, если это - функция _Lua_, `C` - если функция _C_, `main`, если основная часть чанка.
 + `currentline`: текущая строка, на которой выполняется функция.
 + `name`: имя для заданной функции. Некоторые функции могут иметь значение нескольких глобальных переменных, другие - могут храниться только в поле таблицы.
 + `namewhat`: описывает имя поля. Значение может быть `global`, `local`, `method`, `field`, `upvalue` или пустой строкой, в зависимости от того, каким образом была запущена функция.
 + `istailcall`: `true`, если функция вызвана через хвостовой вызов.
 + `nups`: число _upvalue_ функции.
 + `nparams`: число параметров функции.
 + `isvararg`: `true`, если функция вариативная.
 + `ftransfer`: индекс в стеке для первого значения, которое "передаётся", т.е. параметры в вызове или возвращаемые значения. Полезно для "хука" вызова или "хука" возврата.
 + `ntransfer`: число переменных, которые передаются.

__lua_gethook()__

```c
lua_Hook lua_gethook (lua_State *L);
```

Возвращает текущую "хук"-функцию.

__lua_gethookcount()__

```c
int lua_gethookcount (lua_State *L);
```

Возвращает текущее число "хуков".

__lua_gethookmask()__

```c
int lua_gethookmask (lua_State *L);
```

Возвращает текущую маску "хука".

__lua_getinfo()__

```c
int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);
```

Получает информацию о конкретной функции или вызове функции.

```c
lua_Debug ar;
lua_getglobal(L, "f"); /* get global 'f' */
lua_getinfo(L, ">S", &ar);
printf("%d\n", ar.linedefined);
```

Для аргумента `what`:

 + `f`: помещает в стек функцию, запущенную с данным уровнем.
 + `l`: заполняет поле `currentline`.
 + `n`: заполняет поля `name` и `namewhat`.
 + `r`: заполняет поля `ftransfer` и `ntransfer`.
 + `S`: заполняет поля `source`, `short_src`, `linedefined`, `lastlinedefined` и `what`.
 + `t`: заполняет поле `istailcall`.
 + `u`: заполняет поля `nups`, `nparams` и `isvararg`.
 + `L`: помещает в стек таблицу с индексами - строками функции с некоторым ассоциированным кодом, т.е. строки, в которые можно поместить точку прерывания.

__lua_getlocal()__

```c
const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n);
```

Получает информацию о локальной переменной или временном значении по заданной записи активации заданной функции.

__lua_getstack()__

```c
int lua_getstack (lua_State *L, int level, lua_Debug *ar);
```

Получает информации о стеке интерпретатора на данный момент.

__lua_getupvalue()__

```c
const char *lua_getupvalue (lua_State *L, int funcindex, int n);
```

Получает информацию об `n`-ном _upvalue_ замыкания по индексу `funcindex`.

__lua_Hook__

```c
typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);
```

Тип отладочных функций-"хуков".

__lua_sethook()__

```c
void lua_sethook (lua_State *L, lua_Hook f, int mask, int count);
```

Определение для отладочных функций-"хуков". "Хуки" для каждого события (определяются в `mask`) вызываются следующим образом:

 + _Хук вызова_: вызывается, когда интерпретатор вызывает функцию. Хук вызывается после входа _Lua_ в новую функцию.
 + _Хук возврата_: вызывается, когда интерпретатор возвращается из функции. Хук вызывается сразу перед выходом из функции.
 + _Хук строки_: вызывается, когда интерпретатор собирается выполнить новую строку кода или когда он "прыгает" по коду.
 + _Хук подсчёта_: вызывается после выполнением интерпретатором инструкций `count`.

__lua_setlocal()__

```c
const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n);
```

Устанавливает локальную переменную данной записи активации.

__lua_setupvalue()__

```c
const char *lua_setupvalue (lua_State *L, int funcindex, int n);
```

Устанавливает значение _upvalue_ замыкания.

__lua_upvalueid()__

```c
void *lua_upvalueid (lua_State *L, int funcindex, int n);
```

Возвращает уникальный идентификатор для _upvalue_, в `n` позиций от замыкания по индесу `funcindex`.

__lua_upvaluejoin()__

```c
void lua_upvaluejoin (lua_State *L, int funcindex1, int n1, int funcindex2, int n2);
```

Делает `n-1`-е _upvalue_ замыкания по индексу `funcindex1` ссылаемым на `n-2`-е _upvalue_ замыкания по индексу `funcindex2`.

## 5. Вспомогательная библиотека

### 5.1. Функции и типы

__luaL_addchar()__

```c
void luaL_addchar (luaL_Buffer *B, char c);
```

__luaL_addgsub()__

```c
const void luaL_addgsub (luaL_Buffer *B, const char *s, const char *p, const char *r);
```

__luaL_addlstring()__

```c
void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l);
```

__luaL_addsize()__

```c
void luaL_addsize (luaL_Buffer *B, size_t n);
```

__luaL_addstring()__

```c
void luaL_addstring (luaL_Buffer *B, const char *s);
```

__luaL_addvalue()__

```c
void luaL_addvalue (luaL_Buffer *B);
```

__luaL_argcheck()__

```c
void luaL_argcheck (lua_State *L, int cond, int arg, const char *extramsg);
```

__luaL_argerror()__

```c
int luaL_argerror (lua_State *L, int arg, const char *extramsg);
```

__luaL_argexpected()__

```c
void luaL_argexpected (lua_State *L, int cond, int arg, const char *tname);
```

__luaL_Buffer__

```c
typedef struct luaL_Buffer luaL_Buffer;
```

__luaL_buffaddr()__

```c
char *luaL_buffaddr (luaL_Buffer *B);
```

__luaL_buffinit()__

```c
void luaL_buffinit (lua_State *L, luaL_Buffer *B);
```

__luaL_bufflen()__

```c
size_t luaL_bufflen (luaL_Buffer *B);
```

__luaL_bugginitsize()__

```c
char *luaL_buffinitsize (lua_State *L, luaL_Buffer *B, size_t sz);
```

__luaL_buffsub()__

```c
void luaL_buffsub (luaL_Buffer *B, int n);
```

__luaL_callmeta()__

```c
int luaL_callmeta (lua_State *L, int obj, const char *e);
```

__luaL_checkany()__

```c
void luaL_checkany (lua_State *L, int arg);
```

__luaL_checkinteger()__

```c
lua_Integer luaL_checkinteger (lua_State *L, int arg);
```

__luaL_checklstring()__

```c
const char *luaL_checklstring (lua_State *L, int arg, size_t *l);
```

__luaL_checknumber()__

```c
lua_Number luaL_checknumber (lua_State *L, int arg);
```

__luaL_checkoption()__

```c
int luaL_checkoption (lua_State *L, int argm const char *def, const char *const lst[]);
```

__luaL_checkstack()__

```c
void luaL_checkstack (lua_State *L, int sz, const char *msg);
```

__luaL_checkstring()__

```c
const char *luaL_checkstring (lua_State *L, int arg);
```

__luaL_checktype()__

```c
void luaL_checktype (lua_State *L, int arg, int t);
```

__luaL_checkudata()__

```c
void *luaL_checkudata (lua_State *L, int arg, const char *tname);
```

__luaL_checkversion()__

```c
void luaL_checkversion (lua_State *L);
```

__luaL_dofile()__

```c
int luaL_dofile (lua_State *L, const char *filename);
```

```c
(luaL_loadfile(L, filename) || lua_pcall(L, 0, LUA_MULTRET, 0))
```

__luaL_dostring()__

```c
int luaL_dostring (lua_State *L, const char *str);
```

```c
(luaL_loadstring(L, str) || lua_pcall(L, 9, LUA_MULTRET, 0))
```

__luaL_error()__

```c
int luaL_error (lua_State *L, const char *fmt, ...);
```

__luaL_execresult()__

```c
int luaL_execresult (lua_State *L, int stat);
```

__luaL_fileresult()__

```c
int luaL_fileresult (lua_State *L, int stat, const char *fname);
```

__luaL_getmetafield()__

```c
int luaL_getmetafield (lua_State *L, int obj, const char *e);
```

__luaL_getmetatable()__

```c
int luaL_getmetatable (lua_State *L, const char *tname);
```

__luaL_getsubtable()__

```c
int luaL_getsubtable (lua_State *L, int idx, const char *fname);
```

__luaL_gsub()__

```c
const char *luaL_gsub (lua_State *L, const char *s, const char *p, const char *r);
```

__luaL_len()__

```c
lua_Integer luaL_len (lua_State *L, int index);
```

__luaL_loadbuffer()__

```c
int luaL_loadbuffer (lua_State *L, const char *buff, size_t sz, const char *name);
```

__luaL_loadbufferx()__

```c
int luaL_loadbufferx (lua_State *L, const char *buff, size_t sz, const char *name, const char *mode);
```

__luaL_loadfile()__

```c
int luaL_loadfile (lua_State *L, const char *filename);
```

__luaL_loadfilex()__

```c
int luaL_loadfilex (lua_State *L, const char *filename, const char *mode);
```

__luaL_loadstring()__

```c
int luaL_loadstring (lua_State *L, const char *s);
```

__luaL_newlib()__

```c
void luaL_newlib (lua_State *L, const luaL_Reg l[]);
```

```c
(luaL_newlibtable(L,l), luaL_setfuncs(L,l,0))
```

__luaL_newlibtable()__

```c
void luaL_newlibtable (lua_State *L, const luaL_Reg l[]);
```

__luaL_newmetatable()__

```c
int luaL_newmetatable (lua_State *L, const char *tname);
```

__luaL_newstate()__

```c
lua_State *luaL_newstate (void);
```

__luaL_openlibs()__

```c
void luaL_openlibs (lua_State *L);
```

__luaL_opt()__

```c
T luaL_opt (L, func, arg, dflt);
```

```c
(lua_isnoneornil(L, (arg)) ? (dflt) : func(L,(arg)))
```

__luaL_optinteger()__

```c
lua_Integer luaL_optinteger (lua_State *L, int argm lua_Integer d);
```

__luaL_optlstring()__

```c
const char *luaL_optlstring (lua_State *L, int arg, const char *d, size_t *l);
```

__luaL_optnumber()__

```c
lua_Number luaL_optnumber (lua_State *L, int arg, lua_Number d);
```

__luaL_optstring()__

```c
const char *luaL_optstring (lua_State *L, int argm const char *d);
```

__luaL_prepbuffer()__

```c
char *luaL_prepbuffer (luaL_Buffer *B);
```

__luaL_prepbuffsize()__

```c
char *luaL_prepbuffsize (luaL_Buffer *B, size_t sz);
```

__luaL_pushfail()__

```c
void luaL_pushfail (lua_State *L);
```

__luaL_pushresult()__

```c
void luaL_pushresult (luaL_Buffer *B);
```

__luaL_pushresultsize()__

```c
void luaL_pushresultsize (luaL_Buffer *B, size_t sz);
```

__luaL_ref()__

```c
int luaL_ref (lua_State *L, int t);
```

__luaL_Reg__

```c
typedef struct luaL_Reg {
	const char *name;
	lua_CFunction func;
} luaL_Reg;
```

__luaL_requiref()__

```c
void luaL_requiref (lua_State *L, const char *modname, lua_CFunction openf, int glb);
```

__luaL_setfuncs()__

```c
void luaL_setfuncs (lua_State *L, const luaL_Reg *l, int nup);
```

__luaL_setmetatable()__

```c
void luaL_setmetatable (lua_State *L, const char *tname);
```

__luaL_Stream__

```c
typedef struct luaL_Stream {
	FILE *f;
	lua_CFunction closef;
} luaL_Stream;
```

__luaL_testudata()__

```c
void *luaL_testudata (lua_State *L, int arg, const char *tname);
```

__luaL_tolstring()__

```c
const char *luaL_tolstring (lua_State *L, int idx, size_t *len);
```

__luaL_traceback()__

```c
void luaL_traceback (lua_State *L, lua_State *L1, const char *msg, int level);
```

__luaL_typeerror()__

```c
int luaL_typeerror (lua_State *L, int arg, const char *tname);
```

__luaL_typename()__

```c
const char *luaL_typename (lua_State *L, int index);
```

__luaL_unref()__

```c
void luaL_unref (lua_State *L, int t, int ref);
```

__luaL_where()__

```c
void luaL_where (lua_State *L, int lvl);
```

## 6. Стандартные библиотеки

### 6.1. Простейшие функции

__assert(v \[, message\])__

Возвращает ошибку, если значение аргумента `v` - `false`/`nil`; иначе - возвращает все аргументы. `message` - объект ошибки.

__collectgarbage(\[opt \[, arg\]\])__

Функция - обобщённый интерфейс __GC__.

`opt`:

 + `collect`: выполняет цикл __GC__. По-умолчанию.
 + `stop`: останавливает автоматическое исполнение __GC__. Далее __GC__ автоматически запускаться не будет (до полного перезапуска).
 + `restart`: перезапускает автоматическое исполнение __GC__.
 + `count`: возвращает общее количество используемой _Lua_ памяти в Кбайт.
 + `step`: выполняет шаг __GC__. Размер шага контролируется `arg`. `true` возвращается, если шага заканчивает цикл __GC__.
 + `isrunning`: возвращает булево значение, представляющее статус __GC__ (запущен/незапущен).
 + `incremental`: меняет режим __GC__ в инкрементный. За опцией могут следовать три числа: пауза __GC__, множитель шага и размер шага.
 + `generational`: меняет режим __GC__ на поколенческий. За опцией могут следовать два числа: минорный множитель и мажорный множитель.

Функция не должна вызываться финализатором.

__dofile(\[filename\])__

Открывает файл и выполняет содержимое, как чанк. Если вызыван без аргументы, выполняется содержимое `stdin`. Возвращает все значения, возвращаемые чанком.

__error(message \[, level\])__

Ошибка с `message` в качестве объекта ошибки. Функция не имеет возврата.

`level` указывает на то, как получить позицию ошибки. `1` - по-умолчанию.

**_G**

Глобальная переменная, содержащая глобальное окружение.

__getmetatable(object)__

Если `object` не имеет метатаблицы, возвращает `nil`. Иначе, возвращает ассоциированное с полем `__metatable` значение. Если не может, возвращает объект метатаблицы.

__ipairs(t)__

Возвращает три значения так, что конструкция

```lua
for i,v in ipairs(t) do body end
```

будет итерировать по парам ключ-значение (`1,t[1]`, `2,t[2]`, ...) до первого отсутствующего индекса.

__load(chunk \[, chunkname \[, mode \[, env\]\]\])__

Загружает чанк.

Если `chunk` - строка, чанк ей становится. Если `chunk` - функция, `load()` вызывает её с повторами, чтобы получить части чанка. Каждый вызов `chunk()` должен возвращать строку, которая конкатенируется с предыдущими результатами. Возврат `nil` или отсутствие значения сигнализирует о конце чанка.

`load()` возвращает скомпилированный чанк в виде функции; иначе - `fail` и сообщение об ошибке.

При загрузке основного чанка, результирующая функция всегда будет иметь только одно _upvalue_ - переменную `_ENV`. Но, при загрузке двоичного чанка, созданного из функции (см. `string.dump()`), результирующая функция будет иметь арбитрарное количество _upvalue_ и нет гарантии, что первым будет переменная `_ENV` (её может и вовсе не быть).

Вне зависимости от наличия в результирующей функции _upvalue_, её первое _upvalue_ всегда устанавливается в значение `env`, если параметр задан или же в значение глобального окружения. Остальные _upvalue_ инициализируются в `nil`. Все _upvalue_ "свежие" и не используются разделённо с любой другой функцией.

`chunkname` используется для наименования чанка для сообщений об ошибках и отладочной информации. По-умолчанию - `chunk`, если `chunk` - строка, иначе - `=(load)`.

Строка `mode` управляет тем, является ли чанк текстовым или двоичным. Значения: `b` для двоичного, `t` для текстового, `bt` - совмещённый.

__loadfile(\[filename \[, mode \[, env\]\]\])__

Аналогично `load()`, но чанк загружается из файла `filename` или из `stdin`.

__next(tabke \[, index\])__

Позволяет программе перемещаться по полям таблицы. Первый аргумент - таблица, второй - индекс в таблице. Вызов возвращает следующий индекс в таблице и его ассоциированное значение. Когда `nil` - второй аргумент, возвращается стартовый индекс и ассоциированное значение. При вызове с последним индексом или `nil` в пустой таблице, возвращается `nil`. Отсутствие второго аргумента интерпретируется, как `nil`.

Порядок перечисления индексов не специфицирован даже для численных.

__pairs(t)__

Если `t` имеет метаметод `__pairs()`, вызывает его с `t` в качестве аргумента и возвращает первые три результата вызова.

Иначе, возвращает три значения: функцию `next()`, таблицу `t` и `nil`, так что

```lua
for k,v in pairs(t) do body end
```

проитерирует по всем парам ключ-значение таблицы `t`.

__pcall(f \[, arg1, ...\])__

Вызывает функцию `f()` с заданными аргументами в _защищённом режиме_. Т.е., любая ошибка внутри `f()` не вызывается; вместо этого `pcall()` отлавливает её и возвращает код статуса. Её первый результат - код статуса (булево значение), который `true`, если вызов выполняется без ошибок. В таком случае, `pcall()` также возвращает все результаты вызова. В случае ошибки, возвращается `false` и объект ошибки.

__print(...)__

Получает любое количество аргументов и выводит их значения в `stdout`, конвертируя каждый аргумент в строку, используя правила `tostring()`.

Вывод функции не предназначени для форматированного вывода, но может использоваться для быстрого показа значения при отладке.

__rawequal(v1, v2)__

Проверяет равенство `v1` и `v2`, вызывая метаметод `__eq()`.

__rawget(table, index)__

Получает реальное значение `table[index]` без использования метазначения `__index`. `table` должна быть таблицей, `index`- любое значение.

__rawlen(v)__

Возвращает длину объекта `v`, который должен быть таблицей или строкой, без вызова метаметода `__len()`. Возвращает целое число.

__rawset(table, index, value)__

Устанавливает реальное значение `table[index]` в `value` без использования метазначения `__newindex`. `table` - таблица, `index`- любое значение, кроме `nil` и `NaN`, `value` - любое значение _Lua_. Возвращает `table`.

__select(index, ...)__

Если `index` - число, возвращает все аргументы после аргумента номер `index`; отрицательное число индексирует с конца (`-1` - последний аргумент). Иначе, `index` должен быть строкой `#` и `select()` возвращает общее количество дополнительных аргументов, если они были получены.

__setmetatable(table, metatable)__

Устанавливает метатаблицу для данной таблицы. Если `metatable` - `nil`, удаляет метатаблицу данной таблицы. Если оригинальная метатаблица имеет поле `__metatable`, вызывается ошибка. Возвращает `table`.

__tonumber(e \[, base\])__

Когда вызывается без `base`, происходит попытка конвертировать аргумент в число. Если аргумент - уже число или строка, конвертируемая в число, возвращается данное число; иначе, возвращается `fail`.

Конвертация строк может результировать числа целые и с плавающей точкой, в соответствии с лексическими соглашениями. Могут иметься начальные и конечные пробельные символы.

При вызове с `base`, `e` должна быть строкой, интерпретируемой, как целое число или число с плавающей точкой с данным основанием. `base` - любое целое между `2` и `36` включительно.

__tostring(v)__

Принимает значение любого типа и конвертирует его в строку в удобочитаемом формате.

Если метатаблица для `v` имеет поле `__tostring()`, `tostring()` вызывает данный метаметод с `v` в качестве аргумента и использует результат вызова в качестве своего. Иначе, если метатаблица для `v` имеет поле `__name` со строковым значением, `tostring()` может вернуть эту строку в качестве результата.

__type(v)__

Возвращаеи тип единственного аргумента в виде строки.

**_VERSION**

Глобальная переменная, содержащая строку с версией _Lua_.

__warn(msg1, ...)__

Вызывает предупреждение с сообщением, сконкатенированным из аргументов.

По соглашению, цельное сообщение, начинающееся с `@`, подразумевается, как _управляющее сообщение_, т.е. сообщение для предупреждения системы самой себя.

__xpcall(f, msgh \[, arg1, ...\])__

Аналогична `pcall()`, но устанавливает новый обработчик сообщений `msgh`.

### 6.2. Манипуляция сопрограммами

__coroutine.close(co)__

Закрывает сопрограмму `co`, т.е. закрывает все ожидающие переменные _to-be-closed_ и "убивает" сопрограмму. Данная сопрограмма не должна быть мертва или приостановлена. В случае ошибки возвращает `false` и объект ошибки.

__coroutine.create(f)__

Создаёт новую сопрограмму с телом `f`. `f()` - функция. Возвращает новую сопрограмму, объект типа `thread`.

__coroutine.isyieldable(\[co\])__

Возвращает `true`, если сопрограмма `co` может уступать. По-умолчанию `co` - текущая сопрограмма.

__coroutine.resume(co \[, val1, ...\])__

Запускает или создаёт сопрограмму `co`. При первом вызове, создаётся и запускается тело сопрограммы. Значения `val1, ...` передаются в качестве аргументов тела функции. Если сопрограмма была приостановлена уступкой, `.resume()` перезапускает её.

Если не было ошибок выполнения, возвращается `true` и любые значения, переданные в `yield()` или любые значения, вернувшиеся из тела функции.

__coroutine.running()__

Возвращает текущую сопрограмму и статус (`true`, если сопрограмма основная).

__coroutine.status(co)__

Возвращает статус сопрограммы `co` в виде строки: `running`, `suspended`, `normal` и `dead`.

__coroutine.wrap(f)__

Создаёт новую сопрограмму с телом функции `f()`. Возвращает функцию, которая продолжает выполнение сопрограммы при каждом вызове. Аргументы, переданные в функцию - дополнительные аргументы для `.resume()`. Возвращается то же самое, что и в `.resume()`, кроме первого булевого значения.

__coroutine.yield(...)__

Приостанавливает выполнения сопрограммы. Аргументы, переданные в `.yield()` - дополнительные результаты для `.resume()`.

### 6.3. Модули

__require(modname)__

Загружает заданный модуль. Функция начинается с просмотра в таблицу `package.loaded` для определения того, не загружен ли модуль на данный момент. Если так, `require()` возвращает значение из `package.loaded[modname]`. Иначе, пытается найти _загрузчик_ для модуля.

Для поиска загрузчика, `require()` направляется в таблицу `package.searchers`. Каждэй элемент таблицы - функция поиска модуля. Изменив таблицу, можно определить поведение при поиске модуля. Далее - поведение по-умолчанию.

Сначала `require()` запрашивает `package.preload[modname]`. Если у него есть значение, оно является загрузчиком. Иначе, `require()` ищет загрузчик _Lua_, используя путь в `package.path`. Если его нет, ищется загрузчик _C_, используя путь в `package.cpath`. Если его нет, используется загрузчик _all-in-one_ (см. `package.searchers`).

Как только загрузчик найден, `require()` вызывает загрузчик с двумя аргументами: `modname` и _данные загрузчика_. Данные загрузчика могут быть любым значением, полезным для модуля. Для поисковиков по-умолчанию, они индицируют, где модуль был найден. Если загрузчик возвращает не-нулевое значение, `require()` присваивает возвращённое значение `package.loaded[modname]`. Иначе, `package.loaded[modname]` присваивается `true`. Второй возвращаемый результат указывает на то, каким способом был найден модуль.

__package.config__

Строка, описывающая конфигурации пакетов:

 + Первая строка - сепаратор директорий (`/` по-умолчанию для _Linux_).
 + Вторая строка - символ сепарации темплейтов путей (`;` по-умолчанию).
 + Третья строка обозначает символы замещения в темплейте (`?` по-умолчанию).
 + Четвёртая строка в _Windows_ замещается директорией исполняемого файла (`!` по-умолчанию).
 + Пятая строка - знак игнорирования всего последующего текста при сборке с `luaopen_` (`-` по-умолчанию).

__package.cpath__

Строка с путём, используемым в `require()` для поиска загрузчика _C_.

Инициализируется переменной окружения `LUA_CPATH_5_4` или `LUA_CPATH` (по-умолчанию путь определён в `luaconf.h`).

__package.loaded__

Таблица, используемая в `require()` для контроля над загрузкой модулей.

Является ссылкой на реальную таблицу, хранящуюся в регистре _C_ и индексируемую по ключу `"LUA_LOADED_TABLE"`.

__package.loadlib(libname, funcname)__

Динамически линкует программу-хоста с библиотекой _C_ `libname`.

Если `funcname` - `"*"`, линкуется только библиотека, т.е. символы, экспортируемые библиотекой, становятся доступными для других динамически-слинкованных библиотек. Иначе, ищется функция `funcname` внутри библиотеки и возвращается, как функция _C_. `funcname` должна следовать прототипу `lua_CFunction`.

Это низкоуровневая функция. `libname` - полное имя файла библиотеки _C_.

Доступна не на всех платформах (_dlfcn_), небезопасна.

__package.path__

Строка с путём, используемым `require()` для поиска загрузчика _Lua_.

Инициализируется значением переменной окружения `LUA_PATH_5_4` или `LUA_PATH` (по-умолчанию путь см. в `luaconf.h`).

__package.preload__

Таблица, хранящая загрузчики для конкретных модулей.

Является ссылкой на реальную таблицу, хранящуюся в регистре _C_ по индексу `"LUA_PRELOAD_TABLE"`.

__package.searchers__

Таблица, используемая в `require()` для поиска модулей.

Каждое поле таблицы - _функция поиска_. При поиске модуля, `require()` вызывает каждый поисковик по-возрастанию с именем модуля в качестве аргумента. Если поисковик находит модуль, он возвращает функцию-загрузчик и данные загрузчика, которые передаются модулю.

Инициализируется четыремя функциями поиска.

Первый поисковик ищет загрузчик в таблице `package.preload`.

Второй ищет загрузчик, как библиотеку _Lua_, используя путь, хранящийся в `package.path`. Поиск выполняется, как в функции `package.searchpath()`.

Третий поисковик ищет загрузчик, как библиотеку _C_, используя путь из переменной `package.cpath`. Поиск выполняется, как в функции `package.searchpath()`.

Четвёртый поисковик пробует загрузчик _all-in-one_. Он ищет путь _C_ для библиотеки для корневого имени данного модуля.

__package.searchpath(name, path \[, sep \[, rep\]\])__

Ищет `name` по заданному `path`.

Путь - строка с последовательностью _темплейтов_, разделённых точкой с запятой.

`"./?.lua;./?.ls;/usr/local/?/init.lua"`

### 6.4. Манипуляция строками

__string.byte(s \[, i \[, j\]\])__

Возвращает внутренние числовые коды символов `s[i], s[i+1], ..., s[j]`. `i` по-умолчанию `1`. `j` по-умолчанию `i`.

__string.char(...)__

Принимает ноль и более целых чисел. Возвращает строку с длиной, равной числу аргументов, в которой каждый символ имеет внутренний числовой код, эквивалентный соответствующему аргументу.

__string.dump(function \[, strip\])__

Возвращает строку, содержащую двоичное представление данной функции, так что дальше `load()` на данной строке вернёт копию функции (но с новыми _upvalue_). Если `strip` - `true`, двоичное представление может не включать отладочной информации для экономии места.

Функции с _upvalue_ имеют только число сохранённых _upvalue_.

__string.find(s, pattern \[, init \[, plain\]\])__

Ищет первое включение `pattern` в строке `s`. Если находит, `.find()` возвращает индексы в `s`, где начало и конец первого вхождения паттерна. Иначе, вернёт `fail`. Опциональный аргумент `init` указывает место начала поиска (по-умолчанию `1`). `true` в качестве аргумента `plain` отключает поиск паттерна и ищется именно подстрока.

__string.format(formatstring, ...)__

Возвращает форматированную версию переменного числа аргументов после описания в первом аргументе. Формат строки следует правилам функции `sprintf()` __ISO *C*__. Спецификаторы конверсий и модификаторы `F`, `n`, `*`, `h`, `L` и `l` не поддерживаются, но есть дополнительный спецификатор `q`. Ширина и точность ограничены двумя цифрами.

Спецификатор `q` форматирует булевы значения, _nil_, числа и строки так, что результатом является валидная для исходного кода _Lua_ константа. Напр.,

```lua
string.format('%q', 'a string with "quotes" and \n new line')
```

результирует

```
"a string with \"quotes\" and \
new line"
```

__string.gmatch(s, pattern \[, init\])__

Возвращает функцию итератора такую, что при каждом её вызове, возвращается следующий захват из `pattern` над строкой `s` (см. [[#6.4.1. Паттерны]]). Если `pattern` не указывает захватов, всё совпадение продуцируется при каждом вызове. Третий опциональный аргумент `init` указывает, откуда начать поиск (по-умолчанию `1`).

Пример, где цикл итерирует по всем словам из строки `s`, печатая каждое отдельно:

```lua
s = "hello world from Lua"
for w in string.gmatch(s, "%a+") do
	print(w)
end
```

Пример сбора всех пар `key=value` из заданной строки в таблицу:

```lua
t = {}
s = "from=world, to=Lua"
for k, v in string.gmatch(s, "(%w+)=(%w+)") do
	t[k] = v
end
```

`^` в начале паттерна не является "якорем".

__string.gsub(s, pattern, repl \[, n\])__

_Global Substitution_. Возвращает копию `s`, в которой все (или первые `n`, если указано) совпадения с паттерном `pattern` были замещены строкой `repl`, которая может быть строкой, таблицей или функцией. Также возвращается общее число совпадений вторым аргументом.

Если `repl` - строка, её значение используется для замены. `%` работает, как эскейп-символ: любая последовательность в `repl` в форме `%d`, где `d` между `1` и `9`, означает значения `d`-й захваченной подстроки; `%0` означает совпадение целиком; `%%` означает символ `%`.

Если `repl` - таблица, первое совпадение используется в качестве её ключа и она применяется для каждого совпадения.

Если `repl` - функция, это функция вызывается при каждом совпадении, со всеми захваченными подстроками, переданными в качестве аргументов, по-порядку.

Примеры:

```lua
x = string.gsub("hello world", "%w+", "%1 %1")
--> x="hello hello world world"

x = string.gsub("hello world", "%w+", "%0 %0", 1)
--> x="hello hello world"

x = string.gsub("hello world from Lua", "(%w+)%s*(%w+)", "%2 %2")
--> x="world hello Lua from"

x = string.gsub("home = $HOME, user = $USER", "%$(%w+)", os.getenv)
--> x="home = /home/roberto, user = roberto"

x = string.gsub("4+5 = $return 4+5$", "%$(.-)%$", function (s)
	return load(s)()
	end)
--> x= "4+5 = 9"

local t = {name="lua", version="5.4"}
x = string.gsub("$name-$version.tar.gz", "%$(%w+)", t)
--> x="lua-5.4.tar.gz"
```

__string.len(s)__

Принимает строку и возвращает её длину. Нуль-символы считаются.

__string.lower(s)__

Принимает строку и возвращает её копию со всеми большими буквами переведёнными в нижний регистр.

__string.match(s, pattern \[, init\])__

Ищет первое совпадение паттерна `pattern` в строке `s`. Если находит, `.match()` возвращает захваты из паттерна. Опциональный `init` указывает, откуда начинать поиск (`1` по-умолчанию).

__string.pack(fmt, v1, v2, ...)__

Возвращает двоичную строку со значениями `v1, v2, ...`, сериализованную в двоичную форму исходя из форматирующей строки `fmt` (см. [[#6.4.2. Форматирование строк для упаковки и распаковки]]).

__string.packsize(fmt)__

Возвращает размер строки, результирующей из `string.pack()` с заданным форматом. Форматирующая строка не может иметь опций `s` или `z`.

__string.rep(s, n \[, sep\])__

Возвращает строку, которая является конкатенацией `n` копий строки `s`, разделённых строкой `sep`. Разделитель по-умолчанию отсутствует.

__string.reverse(s)__

Возвращает строку, где `s` в обратном порядке.

__string.sub(s, i \[,j\])__

Возвращает подстроку `s`, которая начинается с `i` и продолжается до `j`. Если `j` нет, то предполагается, что это `-1` (длина строки).

__string.unpack(fmt, s \[, pos\])__

Возвращает значения, запакованные в `s` в соответствии с форматирующей строкой `fmt` (см. [[#6.4.2. Форматирование строк для упаковки и распаковки]]). `pos` опционален и помечает начало чтения из `s` (`1` по-умолчанию). Также возвращаются индексы первых непрочитанных байтов в `s`.

__string.upper(s)__

Переводит символы строки в верхний регистр.

#### 6.4.1. Паттерны

__Класс символа__

Используется для представления набора символов.

 + _x_: (где _x_ не является _магическим символом_ `^`, `$`, `(`, `)`, `%`, `.`, `[`, `]`, `*`, `+`, `-`, `?`) представляет символ _x_.
 + `.`: представляет все символы.
 + `%a`: представляет все буквы.
 + `%c`: представляет все управляющие символы.
 + `%d`: представляет все цифры.
 + `%g`: представляет все печатаемые символы, кроме пробела.
 + `%l`: представляет все буквы в нижнем регистре.
 + `%p`: представляет все символы пунктуации.
 + `%s`: представляет все пробельные символы.
 + `%u`: представляет все буквы в верхнем регистре.
 + `%w`: представляет все числовые и буквенные символы.
 + `%x`: представляет все шестнадцатеричные цифры.
 + `%`_x_: (где _x_ - любой не числовой и буквенный символ) представляет символ _x_.
 + `[set]`: представляеи класс, в котором все символы объединяются в набор. Дипапзон может быть указан при помощи `-` между началом и концом. Все классы, указанные выше, можно использовать, как компоненты набора. Все другие символы представляют сами себя.
 + `^[set]`

Для всех классов выше, соответствующий класс, обозначенный c большой буквы, обозначает противоположность.

__Предметы паттерна__

 + Единственный класс символов, который совпадает с любым символом класса.
 + Единственный класс символов с последующим `*`, который совпадает с нулём или более символов класса. Эти повторяющиеся предметы всегда будут совпадать с длиннейшей возможной последовательностью.
 + Единственный класс символов с последующим `+`, который совпадает с последовательностью одного или более символов класса. Эти повторяющиеся предметы всегда будут совпадать с длиннейшей возможной последовательностью.
 + Единственный класс символов с последующим `-`, который совпадает с последовательностью нуля или более символов класса. Эти повторяющиеся предметы всегда будут совпадать с кратчайшей возможной последовательностью.
 + Единственный класс символов с последующим `?`, который совпадает с нулём или одним символом класса. При возможности, всегда совпадает с единственным вхождением.
 + `%`_n_ для _n_ от `1` до `9`; совпадает с подстрокой, равной _n_-й захваченной строке.
 + `%b`_xy_, где _x_ и _y_ два разных символа; данный предмет совпадает со строками, начинающимися с _x_ и заканчивающимися на _y_ и где _x_ и _y_ _сбалансированны_.
 + `%f[set]`, _паттерн фронтира_. Данный предмет совпадает с любой пустой строкой в любой позиции так, что следующий символ принадлежит `set` и предыдущий символ не принадлежит `set`.

__Паттерн__

`^` в начале паттерна прикрепляет совпадение к началу строки субъекта. `$` в конце паттерна прикрепляет совпадение к концу строки субъекта.

__Захваты__

Паттерн может содержать под-паттерны, включенные в скобки; называются они _захватами_. При совпадении, подстроки субъектной строки, которые совпадают с захватами, сохраняются для будущего использования. Захваты нумеруются в соответствии с их левыми скобками. Напр., в паттерне `"(a*(.)%w(%s*))"` часть строки, совпадающая с `"a*(.)%w(%s*)"`, сохраняется в первый захват; символ, совпадающий с `"."`, сохраняется во второй захват; совпадение для `%s*` сохраняется в третий.

__Несколько совпадений__

Функция `string.gsub()` и итератор `string.gmatch()` совпадают с несколькими вхождениями заданного паттерна в субъекте. Для этих функций новое совпадение считается вадидным, только если оно заканчивается на один байт после конца предыдущего совпадения.

```lua
string.gsub("abs", "()a*()", print);
--> 1 2
--> 3 3
--> 4 4
```

#### 6.4.2. Форматирование строк для упаковки и распаковки

См. `string.pack()`, `string.packsize()` и `string.unpack()`.

 + `<`: устанавливает порядок байт _little endian_.
 + `>`: устанавливает порядок байт _big endian_.
 + `=`: устанавливает нативный порядок байт.
 + `![n]`: устанавливает максимальное выравнивание по `n` (нативное выравнивание по-умолчанию).
 + `b`: байт со знаком.
 + `B`: беззнаковый байт.
 + `h`: `short` со знаком.
 + `H`: беззнаковый `short`.
 + `l`: `long` со знаком.
 + `L`: беззнаковый `long`.
 + `j`: `lua_Integer`.
 + `J`: `lua_Unsigned`.
 + `T`: `size_t`.
 + `i[n]`: `signed int` `n` байт.
 + `I[n]`: `unsigned int` `n` байт.
 + `f`: `float`.
 + `d`: `double`.
 + `n`: `lua_Number`.
 + `cn`: строка фиксированного размера в `n` байт.
 + `z`: нуль-терминированная строка.
 + `s[n]`: строка с её размером в начале, закодированным, как `unsigned int` в `n` байт (`size_t` по-умолчанию).
 + `x`: один байт заполнения.
 + `Xop`: пустрой предмет, который выравнивается в соответствии с `op`.
 + ` `: пробел (игнорируется).

### 6.5. Поддержка _UTF-8_

__utf8.char(...)__

__utf8.charpattern__

`"[\0-\x7F\xC2-\xFD][\x80-\xBF]*"`

__utf8.codes(s \[, lax\])__

```lua
for p, c in utf8.codes(s) do body end
```

__utf8.codepoint(s \[, i \[, j \[, lax\]\]\])__

__utf8.len(s \[, i \[, j \[, lax\]\]\])__

__utf8.offset(s, n \[, i\])__

### 6.6. Манипуляция таблицами

__table.concat(list \[, sep \[, i \[,  j\]\]\])__

Для списка, где все элементы - строки или числа, возвращает строку `list[i]..sep..list[i+1]...sep...list[j]`.

__table.insert(list, \[pos,\] value)__

Вставляет элемент `value` на позицию `pos` в `list`, сдвигая вверх элементы от `list[pos]`. `pos` по-умолчанию - `#list + 1`.

__table.move(a1, f, e, t \[, a2\])__

Перемещает элементы из таблицы `a1` в таблицу `a2`, выполняя эквивалент множественного присвоения `a2[t],... = a1[f], ..., a1[e]`. Для `a2` по-умолчанию используется `a1`.

Возвращает `a2`.

__table.pack(...)__

Возвращает новую таблицу со всеми аргументами, помещёнными по ключам `1`, `2` и т.д. и с полем `n` с общим количеством аргументов.

__table.remove(list \[, pos\])__

Удаляет из `list` элеменит на позиции `pos`, возвращая значение удалённого элемента. Когда `pos` между `1` и `#list`, элементы от `list[pos+1]` сдвигаются вниз. По-умолчанию `pos` - `#list + 1`.

__table.sort(list \[, comp\])__

Слоьтоуеь элементы списка по заданному порядку, _на месте_, от `list[1]` до `list[#list]`. Если `comp` задан, он должен быть функцией, которая принимает два элемента списка и возвращает `true`, когда первый элемент должен стоять до второго. Если `comp` не задан, используется оператор `<`.

__table.unpack(list \[, i \[, j\]\])

Возвращает элементы из заданного списка. Эквивалентно

```lua
return list[i], list[i+1], ..., list[j]
```

По-умолчанию `i` - `1`, а `j` - `#list`.

### 6.7. Математические функции

__math.abs(x)__

__math.acos(x)__

__math.asin(x)__

__math.atan(y \[, x\])__

__math.ceil(x)__

Возвращает наименьшее интегральное значение, большее или равное `x`.

__math.cos(x)__

__mas.deg(x)__

Конвертирует угол `x` из радиан в градусы.

__math.exp(x)__

Возвращает значение e<sup>x</sup>.

__math.floor(x)__

Возвращает наибольшее интегральное значение, меньшее или равное `x`.

__math.fmod(x, y)__

__math.huge__

Значение `HUGE_VAL`.

__math.log(x \[, base\])__

__math.max(x, ...)__

__math.maxinteger__

__math.min(x, ...)__

__math.mininteger__

__math.modf(x)__

__math.pi__

__math.rad(x)__

Конвертирует угол `x` из градусов в радианы.

__math.random(\[m \[, n\]\])__

__math.randomseed(\[x \[, y\]\])__

__math.sin(x)__

__math.sqrt(x)__

__math.tan(x)__

__math.tointeger(x)__

__math.type(x)__

__math.ult(m, n)__

### 6.8. Ввод и вывод

__io.close(\[file\])__

__io.flush()__

__io.input(\[file\])__

__io.lines(\[filename, ...\])__

__io.open(filename \[, mode\])__

 + `r`
 + `w`
 + `a`
 + `r+`
 + `w+`
 + `a+`

__io.output(\[file\])__

__io.popen(prog \[, mode\])__

__io.read(...)__

__io.tmpfile()__

__io.type(obj)__

__io.write(...)__

__file\:close()__

__file\:flush()__

__file\:lines(...)__

```lua
for c in file:lines(1) do body end
```

__file\:read(...)__

 + `n`
 + `a`
 + `l`
 + `L`
 + _number_

__file\:seek(\[whence \[, offset\]\])__

 + `set`
 + `cur`
 + `end`

__file\:setvbuf(mode \[, size\])__

 + `no`
 + `full`
 + `line`

__file\:write(...)__

### 6.9. Работа с __ОС__

__os.clock()__

__os.date(\[format \[, time\]\])__

__os.difftime(t2, t1)__

__os.execute(\[command\])__

 + `exit`
 + `signal`

__os.exit(\[code \[, close\]\])__

__os.getenv(varname)__

__os.remove(filename)__

__os.rename(oldname, newname)__

__os.setlocale(locale \[, category\])__

__os.time(\[table\])__

__os.tmpname()__

### 6.10. Библиотека отладки

__debug.debug()__

__debug.gethook(\[thread\])__

__debug.getinfo(\[thread,\] f \[, what\])__

__debug.getlocal(\[thread,\] f, local)__

__debug.getmetatable(value)__

__debug.getregistry()__

__debug.getupvalue(f, up)__

__debug.getuservalue(u, n)__

__debug.sethook(\[thread,\] hook, mask \[, count\])__

 + `c`
 + `r`
 + `l`

__debug.setlocal(\[thread,\] level, local, value)__

__debug.setmetatable(value, table)__

__debug.setupvalue(f, up, value)__

__debug.setuservalue(udata, value, n)__

__debug.traceback(\[thread,\] \[message \[, level\]\])__

__debug.upvalueid(f, n)__

__debug.upbaluejoin(f1, n1, f2, n2)__

## 7. Интерпретатор _Lua_

`lua [options] [script [args]]`

 + `-e stat`: выполнить `stat`.
 + `-i`: войти в интерактивный режим после запуска `script`.
 + `-l mod`: "запрос" `mod` и присвоение результата глобальному `mod`.
 + `-l g=mod`: "запрос" `mod` и присвоение результата глобальному `g`.
 + `-v`: печать информации о версии.
 + `-E`: игнорировать переменные окружения.
 + `-W`: включить предупреждения.
 + `--`: перестать обрабатывать опции.
 + `-`: выполнить `stdin`, как файл и остановить обрабатывать опции.

## 8. Полный синтаксис _Lua_

```
chunk ::= block

block ::= {stat} [retstat]

stat ::= ';' |
	varlist '=' explist |
	functioncall |
	label |
	break |
	goto Name |
	do block end |
	while exp do block end |
	repeat block until exp |
	if exp then block {elseif exp then block} [else block] end |
	for Name '=' exp ',' exp [',' exp] do block end |
	for namelist in explist do block end |
	function funcname funhcbody |
	local function Name funcbody |
	local attnamelist ['=' explist]

attnamelist ::= Name attrib {',' Name attrib}

attrib ::= ['<' Name '>']

retstat ::= return [explist] [';']

label ::= '::' Name '::'

funcname ::= Name {'.' Name} [':' Name]

varlist ::= var {',' var}

var ::= Name | prefixexp '[' exp ']' | prefixexp '.' Name

namelist ::= Name {',' Name}

explist ::= exp {',' exp}

exp ::= nil | false | true | Numeral | LiteralString | '...' | functiondef | prefixexp | tableconstructor | exp binop exp | unop exp

prefixexp ::= var | functioncall | '(' exp ')'

functioncall ::= prefixexp args | prefixexp ':' Name args

args ::= '(' [explist] ')' | tableconstructor | LiteralString

functiondef ::= function funcbody

funcbody ::= '(' [parlist] ')' block end

parlist ::= namelist [',' '...'] | '...'

tableconstructor ::= '{' [fieldlist] '}'

fieldlist ::= field {fieldsep field} [fieldsep]

field ::= '[' exp ']' '=' exp | Name '=' exp | exp

fieldsep ::= ',' | ';'

binop ::= '+' | '-' | '*' | '/' | '//' | '^' | '%' | '&' | '~' | '|' | '>>' | '<<' | '..' | '<' | '<=' | '>' | '>=' | '==' | '~=' | and | or

unop ::= '-' | not | '#' | '~'
```

## Ссылки

https://www.lua.org/manual/5.4

#development #lua #programming