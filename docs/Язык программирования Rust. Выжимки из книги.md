---
tags:
  - rust
  - programming
  - development
---

# Язык программирования _Rust_. Выжимки из книги

## Содержание

 + [[#1. Начало]]
	 + [[#1.1. Установка]]
	 + [[#1.2. Hello, World!]]
	 + [[#1.3. Hello, Cargo!]]
 + [[#2. Игра "угадай число"]]
 + [[#3. Основные концепты языка программирования]]
	 + [[#3.1. Переменные и мутабельность]]
	 + [[#3.2. Типы данных]]
	 + [[#3.3. Функции]]
	 + [[#3.4. Комментарии]]
	 + [[#3.5. Поток управления]]
 + [[#4. "Владение"]]
	 + [[#4.1. Что из себя представляет "владение"]]
	 + [[#4.2. Ссылки и "заимствования"]]
	 + [[#4.3. Тип _slice_]]
 + [[#5. Использование структур]]
	 + [[#5.1. Определение и инстанциирование структур]]
	 + [[#5.2. Пример использования]]
	 + [[#5.3. Синтаксис методов]]
 + [[#6. Перечисления и соответствия паттернам]]
	 + [[#6.1. Определение перечисления]]
	 + [[#6.2. Использование управляющей конструкции _match_]]
	 + [[#6.3. Короткий поток управления с использованием `if let`]]
 + [[#7. Управление растущими проектами с использованием пакетов, "крэйтов" и модулей]]
	 + [[#7.1. Пакеты и "крэйты"]]
	 + [[#7.2. Определение модулей для контроля над областью видимости и приватностью]]
	 + [[#7.3. Пути для ссылки на предмет в дереве модулей]]
	 + [[#7.4. Использование путей в областях видимости при помощи ключевого слова _use_]]
	 + [[#7.5. Разделение модулей по разным файлам]]
 + [[#8. Основные "коллекции"]]
	 + [[#8.1. Хранение списков значений в векторах]]
	 + [[#8.2. Хранение текста в кодировке UTF-8 в строках]]
	 + [[#8.3. Хранение ключей с ассоциированными значениями в хэш-картах]]
 + [[#9. Обработка ошибок]]
	 + [[#9.1. Необратимые ошибки и _panic!_]]
	 + [[#9.2. Обратимые ошибки и _Result_]]
	 + [[#9.3. Использование _panic!_]]
 + [[#10. Обобщённые типы, "трейты" и время жизни]]
	 + [[#10.1. Обобщённые типы данных]]
	 + [[#10.2. Трейты определение общего поведения]]
	 + [[#10.3. Валидация ссылок и время жизни]]
 + [[#11. Написание "автотестов"]]
	 + [[#11.1. Как писать тесты]]
	 + [[#11.2. Контроль выполнения тестов]]
	 + [[#11.3. Структурирование тестов]]
 + [[#12. I/O-проект программа командной строки]]
	 + [[#12.1. Чтение аргументов командной строки]]
	 + [[#12.2. Чтение из файла]]
	 + [[#12.3. Рефакторинг для модульности и обработки ошибок]]
	 + [[#12.4. Разработка функциональной части библиотеки с использованием тестирования]]
	 + [[#12.5. Работа с переменными окружения]]
	 + [[#12.6. Запись сообщений об ошибках в `stderr` вместо `stdout`]]
 + [[#13. Особенности парадигмы функционального программирования итераторы и замыкания]]
	 + [[#13.1. Замыкания анонимные функции, которые захватывают свои окружения]]
	 + [[#13.2. Обработка последовательности объектов итераторами]]
	 + [[#13.3. Улучшение I/O-проекта]]
	 + [[#13.4. Сравнение производительности циклы против итераторов]]
 + [[#14. Больше о _Cargo_ и _Crates.io_]]
	 + [[#14.1. Кастомизация сборок при помощи профилей релизов]]
	 + [[#14.2. Публикация "крэйта" в _Crates.io_]]
	 + [[#14.3. Рабочие пространства _Cargo_]]
	 + [[#14.4. Установка двоичных файлов из _Crates.io_ при помощи `cargo install`]]
	 + [[#14.5. Расширение _Cargo_ при помощи пользовательских команд]]
 + [[#15. Умные указатели]]
	 + [[#15.1. Использование `Box<T>` для указания на данные в "куче"]]
	 + [[#15.2. Обращение к умным указателям, как к к обычным ссылкам, при помощи трейта _Deref_]]
	 + [[#15.3. Исполнение кода на очистку с трейтом _Drop_]]
	 + [[#15.4. `Rc<T>` умный указатель со счётчиком ссылок]]
	 + [[#15.5. `RefCell<T>` и паттерн внутренней мутабельности]]
	 + [[#15.6. Цикличные ссылки и утечка памяти]]
 + [[#16. Конкуренция]]
	 + [[#16.1. Использование потоков для одновременного выполнения кода]]
	 + [[#16.2. Использование обмена сообщениями для передачи данных между потоками]]
	 + [[#16.3. Конкуренция с разделяемым состоянием]]
	 + [[#16.4. Расширяемая конкуренция с трейтами `Sync` и `Send`]]
 + [[#17. ООП в _Rust_]]
	 + [[#17.1. Характеристики ООП]]
	 + [[#17.2. Использование объектов трейтов]]
	 + [[#17.3. Имплементация паттернов Объектно-Ориентированного Дизайна]]
 + [[#18. Паттерны и совпадения]]
	 + [[#18.1. Все использования паттернов]]
	 + [[#18.2. Опровержимость когда паттерн не совпадает]]
	 + [[#18.3. Синтаксис паттернов]]
 + [[#19. Продвинутые возможности]]
	 + [[#19.1. "Небезопасный" _Rust_]]
	 + [[#19.2. Продвинутые "трейты"]]
	 + [[#19.3. Продвинутые типы]]
	 + [[#19.4. Продвинутые функции и замыкания]]
	 + [[#19.5. Макросы]]
 + [[#20. Заключительный проект многопоточный Web-сервер]]
 + [[#21. Приложение]]
	 + [[#21.1. A - Ключевые слова]]
	 + [[#21.2. B - Операторы и символы]]
	 + [[#21.3. C - Производные трейты]]
 + [[#Ссылки]]

## 1. Начало

### 1.1. Установка

___Linux_ и _macOS___

`curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh`

___Windows___

Ссылка на установщик: https://www.rust-lang.org/tools/install.

Для доступа к остальному инструментарию нужно установить [Visual Studio 2022](https://visualstudio.microsoft.com/downloads/). При установке ___VS___, необходимо указать:

 + "Desktop Development with C++"
 + __SDK__ для _Windows 10_ или _11_
 + Пакеты локализации

__Устранение проблем__

Узнать версию _rustc_:

`rustc --version`

__Обновление и деинсталляция__

Для обновления достаточно выполнить следующую команду:

`rustup update`

Для деинсталляции:

`rustup self uninstall`

__Документация__

Для чтения документации без доступа к сети, нужно выполнить следующую команду:

`rustup doc`

### 1.2. Hello, World!

Создайте файл `main.rs` со следующим содержимым:

```rust
fn main()
{
    println!("Hello, world!");
}
```

Для компиляции, необходимо выполнить команду `rustc main.rs` в директории с исходным кодом. В результате будет скомпилирован двоичный файл `main`.
### 1.3. Hello, Cargo!

_Cargo_ - это пакетный менеджер системы сборки _Rust_. Он может выполнять такие задачи, как: сборка проекта из исходного кода, загрузка библиотек (зависимостей), сборка данных библиотек.

Проверка номера версии _Cargo_:

`cargo --version`

__Создание проекта при помощи _Cargo___

```bash
cargo new hello_cargo
cd hello_cargo
```

Первая команда создаёт новую директорию с именем _hello_cargo_.

В директории проекта будут файлы `Cargo.toml` и `src/main.rs`.

Также будет инициализирован новый _Git_-репозиторий вместе с файлом `.gitignore`. Файлы _Git_ не будут сгенерированы, если запустить `cargo new` с указанием существующего _Git_-репозитория. Переопределить данное поведение можно командой `cargo new --vcs=git`.

Содержимое `Cargo.toml`:

```toml
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
```

Формат данного файла конфигурации - ___TOML___ (_Tom's Obvious, Minimal Language_).

`[package]` - заголовок секции, определяющий конфигурацию пакета.

Следующие три строки определяют информацию, которую _Cargo_ использует для компиляции пакета: имя, версия и версия _Rust_ для использования (см [[#21.5. E - Издания]]).

`[dependencies]` - это начало секции, в которой должен быть перечислен список зависимостей пакета. В _Rust_ пакеты с кодом называются "_крэйтами_".

Содержимое `src/main.rs`:

```rust
fn main() {
    println!("Hello, world!");
}
```

_Cargo_ сгенерировал программу "Hello, world!".

_Cargo_ ожидает видеть исходный код в директории `src` проекта и конфигурационный `.toml`-файл проекта в "верхней" директории.

"Верхняя" директория также может содержать _README_, файлы лицензий, конфигурационные файлы и всё, что не связано с кодом.

__Сборка и запуск проекта _Cargo___

Команда `cargo build`, запущенная в директории `hello_cargo`, соберёт проект. Будет создан двоичный файл `target/debug/hello_cargo` с отладочной версией программы.

Первый запуск `cargo build` создаст файл `Cargo.lock` в директории проекта. Этот файл отслеживает точную версию и зависимости проекта. Вручную менять его содержимое не следует, _Cargo_ занимается этим сам.

Команда `cargo run` скомпилирует код и сразу же его запустит.

Если изменить исходный код, _Cargo_ перекомпилирует проект.

Команда `cargo check` проверяет, можно ли скомпилировать код, но не компилирует его.

__Релизная версия__

Команда `cargo build --release` скомпилирует код с оптимизациями. Исполняемый файл будет находиться в директории `target/release` внутри проекта. Оптимизации повлияют на время выполнения программы в лучшую сторону, но время компиляции будет дольше.

## 2. Игра "угадай число"

Создание проекта при помощи _Cargo_:

```bash
cargo new guessing_game
cd guessing_game
```

`Cargo.toml`:

```toml
[package]
name = "guessing_game"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
rand = "0.8.5"
```

Исходный код:

```rust
use rand::Rng;
use std::cmp::Ordering;
use std::io;




fn main()
{
    let secret_number = rand::thread_rng().gen_range(1..=100);

    println!("Guess the number!");

    loop
    {
        let mut guess = String::new();

        println!("Please input your guess.");

        io::stdin()
            .read_line(&mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse
        {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("You guessed: {guess}");

        match guess.cmp(&secret_number)
        {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }
}
```

В исходном коде используется библиотека ввода/вывода `io`, являющаяся частью стандартной библиотеки `std`. В область видимости вводится она следующим образом:

```rust
use std::io;
```

По-умолчанию, _Rust_ имеет набор объектов, определённых в стандартной библиотеке, которые включаются в область видимости каждой программы. Этот набор называется "_прелюдия_", см. [документацию стандартной библиотеки](https://doc.rust-lang.org/std/prelude/index.html).

Если библиотеки нет в "_прелюдии_", она должна быть включена в область видимости при помощи ключевого слова `use`.

`fn` определяет новую функцию. Пустые скобки `()` указывают на то, что функция не принимает аргументы, фигурная скобка `{` обозначает начало тела функции.

`println!` - макроопределение, выводящее строки на экран.

Вызов функции `stdin` из модуля `io` обрабатывает ввод пользователя.

Если бы мы не импортировали библиотеку `io` при помощи `use std::io;` в начале программы, мы всё-ещё могли бы использовать функцию `stdin`, написав полный путь её вызова: `std::io::stdin`. Функция `stdin` возвращает экземпляр `std:io:Stdin`, который репрезентует обработчик ввода в терминал.

`.read_line(&mut guess)` вызывает метод `read_line` стандартного обработчика ввода для того, чтобы считать ввод пользователя. `&mut guess` передаётся в качестве аргумента при вызове метода для того, чтобы сложить в эту строку пользовательский ввод.

Метод `.expect()` используется для обработки ошибок. Метод `.read_line()` возвращает значение типа `Result`, который является _перечислением_ (возможные значения: `Ok` и `Err`).

Значения типов `Result` имеют методы. Один из них - `.expect()`. Если значение объекта типа `Result` будет `Err`, `.expect()` аварийно остановит выполнение программы и выведет сообщение, переданное данному методу в качестве аргумента.

Макрос `println!()` использует "плейсхолдеры" для вывода значений переменных. Варианты использования:

 + `println!("{x}")` - напечатает значение переменной `x`
 + `println!("{}", x + y)` - напечатает значение выражения `x + y`

Включение библиотеки `rand` в исходный файл:

```rust
use rand::Rng;
```

"Трейт" `Rng` определяет методы, которые имплементирует __ГСЧ__, и данный "трейт" должен быть в области видимости.

```rust
let secret_number = rand::thread_rng().gen_range(1..=100);
```

Функция `rand::thread_rng()` даёт нам объект __ГСЧ__: локальный для текущего потока и выделенный __ОС__. Далее вызывается метод `.gen_range(1..=100)`, который нам предоставляет объект __ГСЧ__. Этот метод определён "трейтом" `Rng`, который мы включили в область видимости при помощи `use rand::Rng;`. Метод `.gen_range()` принимает выражение типа диапазон в качестве аргумента. Выражение типа диапазон определяется в общем случае синтаксисом `start..=end` и включает в себя нижнюю и верхнюю границы.

Включение типа `Ordering` в область видимости:

```rust
use std::cmp::Ordering;
```

`Ordering` является перечислением и имеет три значения: `Less`, `Greater` и `Equal`. Метод `.cmp()` сравнивает два значения и может быть вызван для всех сравнимых типов.

"Шэдоуинг" происходит здесь:

```rust
let guess: u32 = match guess.trim().parse()
```

"Шэдоуинг" позволяет переиспользовать имена уже определённых переменных. Где `guess.trim().parse()` - использование уже определённой переменной `guess`, содержащей строку. Метод `.trim()` для переменной типа `String` удаляет все пробелы, содержащиеся в начале и конце строки, возвращая `String`. Метод `.parse()` для переменной типа `String` конвертирует строку в другие типы. Метод `.parse()` может быть применён только к строкам, содержащим числа и знаки, используемые в исчислении. `.parse()` возвращает значение типа `Result`.

```rust
let guess: u32 = match guess.trim().parse()
{
    Ok(num) => num,
    Err(_) => continue,
};
```

Здесь мы сами выбираем, как обрабатывать `Result`, возвращаемый из метода `.parse()`. Если `Result` - `Ok`, с ассоциированным с ним числом `num`, мы возвращаем `num` в `guess`. Если `Result` - `Err`, то мы пропускаем цикл и переходим к следующей итерации. Нижнее подчёркивание (`Err(_)`) значит, что нам нужны все значения, ассоциированные с `Err` вне зависимости от информации, хранящейся в них.

## 3. Основные концепты языка программирования

### 3.1. Переменные и мутабельность

По-умолчанию, все переменные в _Rust_ иммутабельны (неизменяемы во время выполнения).

Для определения переменных используется синтаксис `let <имя переменной>[: <тип данных>] [mut] [ = <значение переменной>]`.

`x` - иммутабельная переменная со значением `1`, `y` - мутабельная переменная со значением `2`:

```rust
let x = 1;
let mut y = 2;
```

__Константы__

Константы могут быть определены в любой области видимости, включая глобальную.

Константам может быть задано только константное выражение и никогда - результат значения, вычисляемого во время выполнения программы.

Синтаксис:

`const: <ИМЯ_КОНСТАНТЫ>: <тип данных> = <константное выражение>`

Пример:

```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```

__"Шэдоуинг"__

Можно "затенить" переменную, используя её же имя и используя `let`, переопределив её:

```rust
fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("x in the inner scope: {x}");
    }

    println!("x: {x}");
}
```

Переопределение будет валидным в пределах области видимости. Если в следующей области видимости переменная была "затенена", по выходу из неё и передаче управления далее, будет использовано значение, которое переменная имела до входа в ту область видимости, из которой только что был осуществлён выход.

"Шэдоуинг" полезен, к примеру, при использовании одной переменной, но имеющих разные типы при переопределении:

```rust
let spaces = "   ";
let spaces = spaces.len();
```

### 3.2. Типы данных

__Целочисленные__

| Размер | Со знаком | Без знака |
| - | - | - |
| 8 бит | `i8` | `u8` |
| 16 бит | `i16` | `u16` |
| 32 бита | `i32` | `u32` |
| 64 бита | `i64` | `u64` |
| 128 бит | `i128` | `u128` |
| Разрядность архитектуры | `isize` | `usize` |

Литералы для целочисленных типов в _Rust_:

| Литерал числа | Пример |
| - | - |
| Десятеричное число | `98_222` |
| Шестнадцатеричное число | `0xff` |
| Восьмеричное число | `0o77` |
| Двоичное число | `0b1111_0000` |
| Символ (только для `u8`) | `b'A'` |

Разрешается использование `_` для визуального разделения.

При переполнении целочисленной переменной возможно два исхода (в зависимости от режима компиляции). Если переполнение переменной произошло в программе, скомпилированной, как "отладочная", то произойдёт аварийное завершение. Если переполнение произошло в программе, скомпилированной с флагом `--release`, аварийного завершения не будет. Вместо этого, значение переменной будет "циклично" обёртываться (т.е. для `u8` со значением `255`, прибавление к её значению числа `2` будет выполнено так, что после этого значение будет равно `1` и т.д.). Стандартная библиотека предоставляет набор методов для базовых численных типов:

 + семейство методов `warpping_*` для всех режимов компиляции
 + можно вернуть значение `None` при переполнении при помощи методов `checked_*`
 + можно вернуть значение и булево значение, показывающее, было ли переполнение, при помощи методов `overflowing_*`
 + присвоить минимальное или максимальное значение для данного типа при помощи методов `saturating_*`

__Переменные с плавающей точкой__

+ `f32`
+ `f64`

__Математические операции__

 + сложение
 + вычитание
 + умножение
 + деление
 + вычисление остатка

__Булевы значения__

Тип `bool` значения принимает 2 возможных значения: `true` и `false`. Размер 1 байт.

__Символьный тип__

Тип `char` - примитивный строковой тип. Пример:

```rust
fn main() {
    let c = 'z';
    let z: char = 'Z';
}
```

Литералы `char` обозначаются одинарными кавычками. Размер `char` - 4 байта, репрезентует скалярное значение _Unicode_.

__Составные типы__

__Кортежи__

Кортеж - общий способ группирования нескольких значений разных типов в один составной тип. Кортежи имеют фиксированный размер.

Синтаксис: разделённый запятыми список значений внутри скобок. Каждое значение внутри кортежа имеет тип, типы внутри кортежа не обязательно должны быть одинаковыми. Пример:

```rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```

`([тип данных], [тип данных], ...)`

Для того, чтобы извлечь отдельные значения, можно использовать совпадение паттернов для деструктуризации кортежа:

```rust
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {y}");
}
```

Обратиться к отдельному элементу кортежа можно через "точку" `.` с последующим указанием индекса элемента в кортеже:

```rust
fn main() {
    let x: (i32, f64, u8) = (600, 6.4, 1);
    let five_hundred = x.0;
    let six_point_four = x.1;
    let one = x.2;
}
```

Кортежи без значений имеют специальное название: _юниты_. Значение и соответствующий ему тип обозначаются, как `()` и репрезентуют пустое значение или пустой тип возвращаемого значения. Выражения возвращают юнит, если нельзя вернуть любое другое значение.

__Массивы__

Массивы в _Rust_ имеют фиксированный размер.

Пример:

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
}
```

_Векторы_ похожи на массивы, но распологаются в куче и могут изменять размер.

Синтаксис определения может включать в себя тип элементов массива и его размер:

`let <имя переменной>[: [<тип переменных>; <размер массива>] = [<значение1>, <значение2>, ...]]`

```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```

Возможна инициализация всех элементов одним значением:

`let a = [3; 5];`, где 3 - значение, 5 - размер массива.

Обратиться к элементу массива можно при помощи имени массива и индекса элемента массива в квадратных скобках.

Обращение к несуществующему элементу массива приведёт к аварийному завершению программы.

### 3.3. Функции

Функция `main` является входной точкой в программе.

Синтаксис:

`fn <имя функции>([<параметр1>: <тип данных 1>, <параметр2>: <тип данных 2>, ...]) [-> <тип возвращаемого значения>] { <тело функции> [return <значение>] }`

Пример:

```rust
fn print_something(value: i32, lavel: char) -> i32 {}
```

Место определения функции в исходном коде значения не имеет. Значение имеет только то, что функция должна находиться в области видимости её вызова.

__"Заявления" и выражения__

Тела функций состоят из серий заявлений, опционально оканчивающихся выражениями.  _Rust_ - основанный на выражениях язык.

 + __Заявления__ - инструкции, выполняющие некоторые действия  и не возвращающие значений (создание переменной `y` и присвоение ей значения `let y = 6;`).
 + __Выражения__ имеют результирующее значение.

Определение функции - есть заявление.

Заявления не возвращают значений. К примеру, нельзя присвоить заявление `let` другой переменной (`let x = (let y = 6);` приведёт к ошибке компиляции)

Выражения могут быть частью заявлений.

Вызов макроопределения - это выражение. Вызов функции - это выражение. Новый блок кода (блок области видимости) - это выражение:

```rust
fn main() {
    let y = {
        let x = 3;
        x + 1
    };
}
```

В примере выше, выражение-результат действий внутри блока кода, присваеваемое переменной `y`, будет равно `4`-м. Если же поставить терминирующую точку с запятой `;` после `x + 1`, блок кода из выражения превратится в заявление, и, соответственно, результата никакого не будет.

__Возвращаемые значения функций__

Объявление стрелки `->` в определении функции говорит о том, что она имеет возвращаемое значение. Возвращаемое значение - синоним последнего выражения в теле функции. Также можно использовать ключевое слово `return` и указать значение для того, чтобы вернуть его из любой точки функции.

Примеры:

```rust
fn five() -> i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {x}");
}
```

```rust
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {x}");
}

fn plus_one(x: i32) -> i32 {
    x + 1
}
```

В примере выше та же ситуация, что и с выражениями внутри новых блоков кода: если поставить терминирующую точку с запятой `;` после выражения `x + 1`, то выражение превратится в заявление без результата.

### 3.4. Комментарии

Комментарии обозначаются двумя косыми чертами `//`. Ставить их нужно на каждой строке с комментарием.

### 3.5. Поток управления

__Выражения `if`__

Синтаксис: `if <условие> { <блок кода 1> } [else { <блок кода 2> }]`.

__Использование `if` в заявлениях `let`__

Пример:

```rust
fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {number}");
}
```

Если блоки кода в ветках `if` при присвоении значения переменной результируют разные типы, будет получена ошибка компиляции.

__Циклы__

Управление внутри циклов происходит при помощи команд `break` (для выхода из цикла) и `continue` (для перехода к следующей итерации).

__`loop`__

Синтаксис: `loop { <тело цикла> }`.

`loop` будет повторять тело цикла до явного выхода из него (напр. при помощи `break`).

__Возвращение значений из циклов__

Для того, чтобы вернуть значение из цикла, можно добавить выражение после ключевого слова `break`, которое и будет возвращаемым из цикла значением.

Пример:

```rust
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;
        if counter == 10 {
            break counter * 2;
        }
    };

    println!("Result {result}");
}
```

__Метки циклов__

`break` и `continue` применяется во внутренних циклах. Опционально можно пометить цикл и далее использовать метку для `break` и `continue`. Синтаксис: `'<метка цикла>: <цикл> { <тело цикла> }`.

Пример:

```rust
fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {count}");
        let mut remaining = 10;
        
        loop {
            println!("remaining = {remaining}");
            if remaining == 9 {
                break;
            }
            if count = 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

    count += 1;
    }
    println!("End count = {count}");
}
```

__Условные циклы `while`__

Синтаксис: `while <условие> {<тело цикла>}`

Пример:

```rust
fn main() {
    let mut number = 3;
    while number != 0 {
        println!("{number}!");
        
        number -= 1;
    }

    println!("LIFTOFF!");
}
```

__Циклы для наборов `for`__

Синтаксис: `for <итерируемая переменная> in <набор> {<тело цикла>}`

Примеры:

```rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {element}");
    }
}
```

```rust
fn main() {
    for number in (1..4).rev() {
        println!("{number}");
    }
    println!("LIFTOFF!!!");
}
```

, где `(1..4)` - тип `Range`.

## 4. "Владение"

_Владение_ - это набор правил для управления памятью.

### 4.1. Что из себя представляет "владение"

__Правила владения__

 + Каждое значение в _Rust_ имеет _владельца_
 + Может существовать только один владелец в данный момент времени
 + Когда владелец уходит из области видимости, значение отбрасывается

__Область видимости переменных__

```rust
{ // s здесь не валидна, пока ещё не определена
    let s = "hello"; // s валидна отсюда
// манипуляции с s...
} // область видимости закончилась, s снова не валидна
```

__Тип `String`__

Создать строку из строкового литерала можно при помощи функции `from()`, находящейся в пространстве имён `String`:

```rust
let s = String::from("hello");
```

Данный тип может быть мутабельным, если предполагается изменение размера выделенной для строки памяти:

```rust
let mut s = String::from("hello");
s.push_str(", world!"); // push_str() добавляет литерал к строке
println!("{}", s);
```

Строковые литералы находятся в стеке, строки выделяются из кучи.

__Управление памятью__

`String::from()` запрашивает память для строки.

Для освобождения памяти не используется ни сборщик мусора (который сладит за выделенной памятью и освобождает неиспользуемые участки), ни ручное освобождение памяти. В _Rust_ выделенная память автоматически освобождается, как только переменная, которая _владеет_ выделенной памятью покидает область видимости:

```rust
{
    let s = String::from("hello"); // s валидна
// манипуляции с s
} // конец области видимости; s невалидна
```

Как только переменная выходит из области видимости, _Rust_ вызывает специальную функцию `drop()`. В _C++_ подобное поведение (деаллокация ресурсов после окончания жизни объекта) называется ___RAII___ (_Resource Acquisition Is Initialization_).

__Переменные и перемещение данных__

Разные переменные могут взаимодействовать с одними и теми же данными разными способами.

```rust
let x = 5;
let y = x;
```

В примере выше переменной `x` присваивается значение `5`, переменной `y` присваивается копия значения переменной `x`.

```rust
let s1 = String::from("hello");
let s2 = s1;
```

Репрезентация переменной `s1` типа `String` со значением `"hello"` в памяти:

```
s1
+----------+-------+      +-------+-------+
| name     | value |      | index | value |
+----------+-------+      +-------+-------+
| ptr      | ------|----->| 0     | h     |
+----------+-------+      +-------+-------+
| len      | 5     |      | 1     | e     |
+----------+-------+      +-------+-------+
| capacity | 5     |      | 2     | l     |
+----------+-------+      +-------+-------+
                          | 3     | l     |
                          +-------+-------+
                          | 4     | o     |
                          +-------+-------+
```

, где `len` - количество используемой в `String` памяти, `capacity` - общее количество памяти в байтах, которое получил `String` от аллокатора, `ptr` - указатель на выделенную строку.

Когда мы присваиваем значение `s1` переменной `s2`, копируются данные `String`, находящиеся в стеке (указатель на выделенную строку `ptr`, `len` и `capacity`). Данные из кучи _не копируются_. При этом, `s1` становится не валидной переменной (для исключения _двойного освобождения_ при выводе `s1` и `s2` из области видимости). Переменная "_перемещается_" (`s1` перемещается в `s2`).

__Взаимодействие переменных и данных с `clone`__

Если нам действительно нужна "глубокая" копия данных из кучи, выделенных для `String`, можно использовать общий метод `.clone()`:

```rust
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
```

В примере выше выделенные ресурсы копируются для `s2`.

__Данные стека: `Copy`__

```rust
let x = 5;
let y = x;

println!("x = {}, y = {}", x, y);
```

В примере выше мы не вызываем `.clone()`, но `x` всё-ещё валидна и не была перемещена в `y`. Причина этому - известный на время компиляции размер переменной, по причине чего хранится она в стеке.

В _Rust_ есть специальная аннотация - трейт `Copy`, который может быть применён к типам, которые расположены в стеке (напр.: целочисленные типы). Если тип имплементировал трейт `Copy`, переменные, которые его используют, не перемещаются, а копируются, что делает их валидными после присвоения значения переменной другим переменным.

_Rust_ не даст применить трейт `Copy` к типу, если он или любая его составляющая имеет трейт `Drop`. Если типу необходимо действие на случай выхода переменной из области видимости и мы добавили аннотацию `Copy` для данного типа, мы получим ошибку компиляции.

По-умолчанию, трейт `Copy` имеют скалярные типы данных и всё, что не требует выделения памяти, например:

 + Целочисленные типы
 + `bool`
 + Числа с плавающей точкой
 + Символьный тип
 + Кортежи, если они содержат только те типы, которым назначен трейт `Copy`

__Владение и функции__

Механизм передачи значений функциям похож на механизм присвоения значения переменной. Передача переменной функции или переместит значение, или скопирует, как и присвоение.

```rust
fn main() {
    let s = String::from("hello"); // s входит в область видимости
    takes_ownership(s); // значение s перемещается в функцию...
// ... и далее s невалидна
    let x = 5; // x входит в область видимости
    makes_copy(x); // x перемещается в функцию, но i32 имеет трейт Copy - соответственно, x далее будет валидна, т.к. данные копируются в область видимости функции
} // x выходит из области видимости, затем s. Посколько значение s было перемещено, ничего не произойдёт

fn takes_ownership(some_string: String) { // some_string входит в область видимости
    println!("{}", some_string);
} // some_string выходит из области видимости и вызывается drop(). Память освобождается

fn makes_copy(some_integer: i32) { // some_integer входит в область видимости
    println!("{}", some_integer);
} // some_integer выходит из области видимости, ничего не происходит
```

Использование переменной `s` после вызова `takes_ownership()` приведёт к ошибке компиляции.

__Возвращаемые значения и области видимости__

Возвращаемые значения могут передавать владение.

```rust
fn main() {
    let s1 = gives_ownership(); // gives_ownership() перемещает своё возвращаемое значение в s1
    let s2 = String::from("hello"); // s2 входит в область видимости
    let s3 = takes_and_gives_back(s2); // s2 перемещается в функцию takes_and_gives_back(), которая, в свою очередь, перемещает возвращаемое значение в s3
} // s3 выходит из области видимости и освобождается. s2 была перемещена, с ней ничего не происходит. s1 выходит из области видимости и освобождается

fn gives_ownership() -> String { // gives_ownership переместит возвращаемое значения в функцию, вызвавшую gives_ownership
    let some_string = String::from("yours"); // some_string входит в область видимости
    some_string // some_string возвращается из функции
}

fn takes_and_gives_back(a_string: String) -> String { // a_string входит в область видимости
    a_string // a_string возвращается и перемещается в вызвавшую функцию
}
```

Владение переменной следует одному паттерну: присвоение значения другой переменной перемещает его. Когда переменная с данными в куче выходит из области видимости, данные сами освобождаются при помощи `drop()`, если владение данными не было передано другой переменной (перемещено).

Если хочется использовать данные переменной, но не хочется передавать владение функции, то можно использовать кортежи:

```rust
fn main() {
    let s1 = String::from("hello");
    let (s2, len) = calculate_length(s1);
    println!("Len of '{}' is {}", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len();
    (s, length)
}
```

### 4.2. Ссылки и "заимствования"

Ссылка - это примерно то же, что и указатель, по которому можно получить доступ к данным. В отличие от указателя, ссылка гарантированно указывает на валидные данные конкретного типа. Пример:

```rust
fn main() {
    let s1 = String::from("hello");
    let len = calculate_length(&s1);
    println!("Len of '{}' is {}", s1, len)
}

fn calculate_length(s: &String) -> usize {
    s.len()
} // s выходит из области видимости. Поскольку переменная не владеет данными, на которые ссылается, память не будет освобождена
```

, где `&String` - ссылка на `&String`.

`&` - ссылка, `*` - разыменование.

Плскольку владение `s1` не передаётся в функцию `calculate_length()` (передаётся только ссылка на `s1`), мы можем дальше пользоваться данной переменной, после вызова данной функции.

Создание ссылки иначе можно назвать _заимствованием_.

Ссылки по-умолчанию иммутабельны. Если в примере выше попробовать изменить строку, ссылку на которую мы передали в функцию `calculate_length()` внутри неё же, мы получим ошибку компиляции.

__Мутабельные ссылки__

```rust
fn main() {
    let mut s = String::from("hello");
    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```

Мутабельные ссылки имеют ограничения: не может существовать более одной мутабельной ссылки на объект. Это предотвращает состояние гонок за ресурсы (когда два или более указателя пытаются одновременно получить доступ к данным и нет механизма синхронизации).

Можно создать несколько областей видимости для использования мутабельных ссылок:

```rust
let mut s = String::from("hello");

{
    let r1 = &mut s;
} // r1 выходит из области видимости и далее можно создать мутабельную ссылку на s
let r2 = &mut s;
```

То же правило действует и в случае комбинирования мутабельных и немутабельных ссылок:

```rust
let mut s = String::from("hello");

let r1 = &s; // нет проблем
let r2 = &s; // нет проблем
let r3 = &mut s; // проблема
```

Несколько немутабельных ссылок допустимы, поскольку нет ожидания того, что данные, на которые они указывают, будут изменены.

Область видимости ссылок начинается с их объявления и заканчивается последним их использованием:

```rust
let mut s = String::from("hello");

let r1 = &s;
let r2 = &s;
println!("{} and {}", r1, r2);

let r3 = &mut s; // нет проблем
println!("{}", r3);
```

__Повисшие ссылки__

Сохранение указателя на освобождённую память создаёт повисшие ссылки. В _Rust_ компилятор гарантирует отсутствие повисших ссылок. Компилятор удостоверяется в том, что данные не выйдут за область видимости до того, как из области видимости выйдет ссылка.

```rust
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    let s = String::from("hello");
    &s
}
```

Пример выше не скомпилируется, поскольку `s` создана внутри `dangle()`. Когда тело функции `dangle()` заканчивается, `s` освобождается. Попытка вернуть ссылку на `s` не будет успешна. Решение проблемы - вернуть `String`, а не `&String`:

```rust
fn no_dangle() -> String {
    let s = String::from("hello");
    s
}
```

### 4.3. Тип _slice_

"Слайсы" дают возможность ссылаться на последовательность элементов в коллекции, а не на всю коллекцию в целом. Слайс - это подтип ссылок, так что владеть ничем он не может.

__Строковые слайсы__

Строковой слайс (`&str`) - это ссылка на часть объекта типа `String`, интерпретируемая, как байтовая строка:

```rust
let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11];
```

`hello` - это ссылка на часть `s`, диапазон которой указан, как `[0..5]`. Слайсы создаются при помощи диапазона внутри квадратных скобок (`[starting_index..ending_index]`). Структура слайса внутри хранит указатель на начальную позицию и размер слайса (`ending_index - starting_index`).

```
           s
+----------+-------+    +-------+-------+
| name     | value |    | index | value |
+----------+-------+    +-------+-------+
| ptr      | ------|--->| 0     | h     |
+----------+-------+    +-------+-------+
| len      | 11    |    | 1     | e     |
+----------+-------+    +-------+-------+
| capacity | 11    |    | 2     | l     |
+----------+-------+    +-------+-------+
                        | 3     | l     |
                        +-------+-------+
                        | 4     | o     |
     world              +-------+-------+
+------+-------+        | 5     |       |
| name | value |        +-------+-------+
+------+-------+   ---->| 6     | w     |
| ptr  | ------|---|    +-------+-------+
+------+-------+        | 7     | o     |
| len  | 5     |        +-------+-------+
+------+-------+        | 8     | r     |
                        +-------+-------+
                        | 9     | l     |
                        +-------+-------+
                        | 10    | d     |
                        +-------+-------+
```

Синтаксис диапазона `..` в _Rust_ позволяет опустить начальное значение диапазона, если он должен начинаться с индекса `0` (от начала и до индекса):

```rust
let s = String::from("hello");
let slice = &s[..2];
```

Можно опустить и индекс последнего байта из диапазона (от индекса и до конца):

```rust
let s = String::from("hello");
let slice = &s[3..];
```

Можно отбросить начальное и конечное значения при указании диапазона слайса. Тогда слайсом будет вся строка:

```rust
let s = String::from("hello");
let slice = &s[..];
```

Функция поиска первого слова:

```rust
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes;

    for (i, &item) in bytes.uter().enumerate() {
        if item = b' ' {
            return &s[0..i]
        }
    }

    &s[..]
}
```

__Строковые литералы, как слайсы__

Строковые литералы являются слайсами (т.е. при объявлении `let s = "Hello, world!";`, тип переменной `s` будет `&str`).

__Строковые слайсы, как параметры__

Можно улучшить объявление `first_word()`, изменив параметры функции:

```rust
fn first_word(s: &str) -> &str
```

Таким образом, функции можно передавать как строковые слайсы, так и ссылки на `String` целиком.

__Другие слайсы__

Существуют более общие слайсы.

```rust
let a = [1, 2, 3, 4, 5];

let slice = &a[1..3];

assert_eq!(slice, &[2, 3]);
```

## 5. Использование структур

Структуры позволяют упаковывать вместе и именовать различные значения разных типов.

### 5.1. Определение и инстанциирование структур

Определение структуры:

```rust
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
```

Создание экземпляра структуры:

```rust
fn main() {
    let user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };
}
```

Изменение поля в структуре (обращение к полю через `.`):

```rust
fn main() {
    let mut user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };

    user1.email = String::from("anotheremail@example.com");
}
```

Отдельные поля в структуре нельзя пометить, как мутабельные.

Как и с любым другим выражением, можно сконструировать новый экземпляр структуры, как последнее выражение в теле функции, которая вернёт этот самый новый экземпляр:

```rust
fn build_user(email: String, username: String) -> User {
    User {
        active: true,
        username: username,
        email: email,
        sign_in_count: 1,
    }
}
```

__Использование короткой инициализации полей__

Можно отбросить имена полей и использовать имена переданных в функцию аргументов, если они совпадают:

```rust
fn build_user(email: String, username: String) -> User {
    User {
        active: true,
        username,
        email,
        sign_in_count: 1,
    }
}
```

__Создание экземпляров из других экземпляров с использованием синтаксиса обновления структуры__

```rust
fn main() {
// ...user1...
    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from("anotherexample@test.com"),
        sign_in_count: user1.sign_in_count,
    };
}
```

При помощи синтаксиса обновления структуры, можно добиться того же результата, что и выше, но с меньшим количеством кода:

```rust
fn main {
// ...user1...
    let user2 = User {
        email: String::from("anotherexample@test.com"),
        ..user1
    };
}
```

`..` обозначает, что оставшиеся незаполненные поля должны принять то же значения, что и поля в указанном после `..` экземпляре.

Обновление структуры через две точки `..` должно указываться в последнюю очередь для присвоения полям оставшихся значений из указанной структуры.

Синтаксис обновления структуры использует `=` как присвоение; это потому что обновление перемещает данные. После обновления и создания экземпляра `user2` не получится использовать структуру `user1`, поскольку поля были перемещены. Но, если бы мы использовали при обновлении только поля `active` и `sign_in_count`, то переменная `user1` оставалась бы валидной, поскольку поля имеют типы фиксированного размера и, следовательно, данные не перемещаются (типы данных для полей `active` и `sign_in_count` имеют трейт `Copy`).

__Использование кортежных структур без именованных полей для создания различных типов__

_Rust_ позволяет создавать структуры, похожие на кортежи (_кортежные структуры_). Кортежные структуры не имеют имён для полей, указываются лишь их типы. Они полезны, если необходимо дать имя кортежу и отделить его от всех остальных, когда как именование полей структуры будет излишнем.

```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}
```

Переменные `black` и `origin` имеют различные типы. Функция, принимающая параметр типа `Color` не сможет принять `Point` в качестве аргумента.

__Структуры без полей, подобные юнитам__

Можно определить структуру без полей. Ведут они себя подобно _юнитам_ (`()`). Подобные юнитам структуры полезны, когда нужно реализовать трейт для какого-либо типа, но хранить данные в самом типе не предполагается.

```rust
struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}
```

__Владение данными структур__

Структуры могут иметь поля типа ссылок на данные, владельцами которых являются другие объекты. Для этого используется _время жизни_. Время жизни должно говорить нам о том, что данные в поле типа ссылки валидны, пока валидна сама структура.

```rust
struct User {
    active: bool,
    username: &str,
    email: &str,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        active: true,
        username: "username123",
        email: "mail@test.com",
        sign_in_count: 1,
    };
}
```

Пример выше не скомпилируется, поскольку не было указано время жизни. См [[#10.3. Валидация ссылок и время жизни]].

### 5.2. Пример использования

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale),
        height: 50,
    };

    dbg!(&rect1);
}
```

Макрос `dbg!()` используется вместо макроса `println!()`, поскольку `println!()` использует форматирование для вывода `Display`. Вставка спецификатора `:?` внутрь фигурных скобок для `println!()` говорит о том, что `println!()` должен использовать форматирование для вывода `Debug`. Трейт `Debug` позволяет вывести значения полей структуры в удобном формате и передать не значения полей по-отдельности, а сразу всю структуру. Для того, чтобы добавить трейт `Debug` для нашей структуры, нужно явно это указать, добавив строку `#[derive(Debug)]` прямо перед определением структуры. Для более удобочитаемого вывода в `println!()` можно использовать спецификатор форматирования `:#?`. Макрос `dbg!()` берёт владение на себя (в отличии от `println!()`, которое берёт ссылку), печатает имя файла и номер строки, где был совершён вызов `dbg!()` вместе с результатом выражения. Далее, возвращает владение. Вывод `dbg!()` идёт в `stderr`.

Вдобавок к трейту `Debug`, _Rust_ предоставляет набор трейтов, используемых с атрибутом `derive`, которые могут добавить полезное поведение для пользовательских типов.

### 5.3. Синтаксис методов

Методы похожи на функции: определяются при помощи ключевого слова `fn` и имени, могут иметь параметры и возвращаемое значение. Методы определяются в контексте структур (или перечислений, или трейтов) и их первый параметр - всегда `self`, который представляет экземпляр структуры, метод которой был вызван.

__Определение методов__

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("The area of the rectangle is {} square pixels.", rect1.area());
}
```

Для определения методов, используется ключевое слово `impl` с последующим указанием имени структуры и блока с функциями внутри. Метод из структуры вызывается через точку `.` с последующим указанием имени метода и параметров в круглых скобках.

`&self` - это быстрый доступ к `self: &Self`. В блоке `impl`, тип `Self` - это алайас типа, которому принадлежит `impl`. Методы должны иметь параметры `self` типа `Self` в качестве первого аргумента. Методы могут брать владение над `self`, заимствовать `self` иммутабельно (как в примере выше) или заимствовать `self` мутабельно, как любой другой параметр.

Имя метода может совпадать с именем одного из полей структуры:

```rust
impl Rectangle {
    fn width(&self) -> bool {
        self.width > 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    if rect1.width() {
        println!("The rectangle has a nonzero width; it is {}", rect1.width);
    }
}
```

Такие методы (с именем, совпадающим с именем поля и возвращающие значение поля) называются _getters_. Такие методы полезны, потому что поле можно сделать приватным, а _getter_ - публичным.

В _Rust_ есть _автоматическое разыменование_. Т.е. `p1.distance(&p2)` и `(&p1).distance(&p2)` - одно и то же.

__Методы с несколькими параметрами__

```rust
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn can_hold(&self, other: &rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
    println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));
}
```

__Ассоциированные функции__

Все функции, определённые в блоке `impl` называются _ассоциированными функциями_. Можно определить _ассоциированную функцию_, которая не принимает `self` в качестве параметра (и потому не являющуюся методом), потому что нет необходимости иметь экземпляр типа, чтобы с ним работать.

```rust
impl Rectangle {
    fn square(size: u32) -> Self {
        Self {
            width: size,
            height: size,
        }
    }
}
```

Для вызова данной функции используется синтаксис `::` (`let sq = Rectangle::square(3)`). Функция входит в пространство имён структуры. `::` используется для ассоциированных функций и для пространств имён модулей.

__Несколько блоков `impl`__

Каждая структура может иметь несколько блоков `impl`.

## 6. Перечисления и соответствия паттернам

Перечисления позволяют определить тип, перечисляя его возможные варианты.

### 6.1. Определение перечисления

Значения переменных типа перечисление могут быть только указанных в определении вариантов.

```rust
enum IpAddrKind {
    V4,
    V6,
}
```

__Значения перечислений__

Создать два экземпляра `IpAddrKind` можно таким образом:

```rust
let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
```

Можно определить функцию, которая принимает в качестве аргумента перечисление `IpAddrKind`:

```rust
fn route(ip_kind: IpAddrKind) {}
```

И вызвать её с любым из вариантов:

```rust
route(IpAddrKind::V4);
route(IpAddrKind::V6);
```

Можно использовать перечисления внутри структур для того, чтобы связать несколько значений (связали `kind` и `address`):

```rust
enum IpAddrKind {
    V4,
    V6,
}

struct IpAddr {
    kind: IpAddrKind,
    address: String,
}

let home = IpAddr {
    kind: IpAddrKind::V4
    address: String::from("127.0.0.1"),
};

let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from("::1"),
}
```

Вместо помещения перечислений внутрь структур, можно хранить данные прямо в вариантах перечислений:

```rust
enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from("127.0.0.1"));
let loopback = IpAddr::V6(String::from("::1"));
```

Имя каждого варианта перечисления становится функцией, конструирующей экземпляр перечисления. Т.е. `IpAddr::V4()` - вызов функции, которая принимает аргумент типа `String` и возвращает экземпляр перечисления типа `IpAddr`.

Каждый вариант в перечислении может иметь собственный набор типов и их количество, типы и количество ассоциированных с вариантом данных:

```rust
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String)
}

let home = IpAddr::V4(127, 0, 0, 1);
let loopback = IpAddr::V6(String::from("::1"));
```

В стандартной библиотеке реализация перечисления для IP-адресов ассоциирует данные структур для конкретного IP-адреса с вариантом перечисления:

```rust
struct Ipv4Addr {
// ...
}

struct Ipv6Addr {
// ...
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
```

Ассоциировать с вариантом перечисления можно любой тип данных.

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```

В примере выше

 + `Quit` не имеет ассоциированных данных
 + `Move` имеет именованные поля, как в структуре
 + `Write` включает только `String`
 + `ChangeColor` включает три значения `i32`

```rust
struct QuitMessage; // юнит
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // кортежная структура
struct ChangeColorMessage(i32, i32, i32); // кортежная структура
```

Можно ассоциировать методы с перечислениями:

```rust
impl Message {
    fn call(&self) {
    }
}

let m = Message::Write(String::from("hello"));
m.call();
```

Тело метода использует `self` для получения значения, с которым мы вызвали метод. В примере выше `m` имеет значение `Message::Write(String::from("hello"))`, которое и попадёт в `m.call()`.

__Перечисление `Option` и его преимущества перед пустыми значениями__

`Option` - перечисление, предоставляемое стандартной библиотекой. `Option` представляет общий сценарий, когда значение может быть чем-то, или ничем.

К примеру, если запросить первый объект из непустого списка, будет получено значение. Если запросить первый объект из пустого списка, значение возвращено не будет.

В _Rust_ нет значения `NULL`, но есть перечисление, которое может репрезентовать значение, как присутствующее или отсутствующее.

```rust
enum Option<T> {
    None,
    Some(T),
}
```

Перечисление `Option<T>` включено в прелюдию, как и его варианты. Можно использовать `Some` и `None` без префикса `Option::`.

Синтаксис `<T>` - параметр общего типа. Вариант `Some` может содержать данные любого типа и каждый конкретный тип, который помещается вместо `T` делает типы `Option<T>` разными:

```rust
let some_number = Some(5);
let some_char = Some('e');

let absent_numver: Option<i32> = None;
```

`some_number` имеет тип `Option<i32>`, `some_char` имеет тип `Option<char>`. Для `absent_number` должен быть записан тип `Option` целиком: компилятор не сможет определить тип `Option` только по указанию значения `None`.

```rust
let x: i8 = 5;
let y: Option<i8> = Some(5);
let sum = x + y;
```

Пример выше не скомпилируется, потому что мы пытаемся сложить переменные типа `i8` и `Option<i8>`. Нужно сконвертировать `Option<T>` в `T` прежде, чем выполнять с `T` операции.

### 6.2. Использование управляющей конструкции _match_

`match` позволяет сравнивать одно значение с последовательностью паттернов и выполнять код в зависимости от результатов сравнения. Паттерны могут состоять из значений, имён переменных, регулярных выражений и т.д.

```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```

`match` похож на условное выражение `if` но `if` выражение должно результировать булев тип, когда в `match` тип может быть любым.

Ветви `match` имеют две части: паттерн и код. В примере выше первая ветвь имеет паттерн со значением `Coin::Penny`, далее оператор `=>`, который разделяет паттерн и код. Код в данном случае - значение `1`. Каждая ветвь разделена запятой.

`match` сравнивает по порядку.

Код, ассоциированный с каждой ветвью - выражение, результат выражения после совпадения возвращается, как результат `match`.

Если нужно написать несколько строк кода для ветви, используются фигурные скобки, а запятая далее опциональна:

```rust
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        }
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```

__Паттерны, закрепляемые за значениями__

```rust
#[derive(Debug)]
enum UsState {
    Alabama,
    Alaska,
// ...
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println("State quarter from {:?}!", state);
            25
        }
    }
}
```

Если мы вызовем `value_in_cents(Coin::Quarter(UsState::Alaska))`, `coin` будет `Coin::Quarter(UsState::Alaska)`.

__Использование с `Option <T>`__

В примере ниже, если значение внутри `Option<i32>` существует, мы добавляем к нему единицу. Если его не существует, мы не совершаем никаких операций и `Option<i32>` остаётся, как `None`.

```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
```

__`match` исчерпывающий__

Паттерны ветвей в `match` должны покрывать все возможные паттерны. Код ниже не скомпилируется, потому что мы не обрабатываем случай с `None`.

```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        Some(i) = > Some(i + 1),
    }
}
```

__Catch-all-паттерны и плейсхолдер `_`__

```rust
let dice_roll = 9;
match dice_roll {
    3 => add_fancy_hat(),
    7 => remove_fancy_hat,
    other => move_player(other),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
fn move_player(num_spaces: u8) {}
```

В примере выше, паттерн покрытия всех значений, кроме `3` и `7`, называется `other`. Код скомпилируется, несмотря на то, что мы не перечислили все возможные значения `u8`, потому что последний паттерн будет иметь все неперечисленные значения. Паттерн для `other` называется _catch-all_-паттерн и должен помещаться в самом конце `match`.

_Rust_ имеет паттерн, который используется, как _catch-all_-паттерн, но не результирует значений. Это плейсхолдер `_`. Используя его, мы говорим компилятору, что значения использовать мы не будем и избежим предупреждений при компиляции.

```rust
let dice_roll = 9;
match dice_roll {
    3 => add_fancy_hat(),
    7 => remove_fancy_hat(),
    _ => reroll(),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
fn reroll() {}
```

```rust
let dice_roll = 9;
match dice_roll {
    3 => add_fancy_hat(),
    7 => remove_fancy_hat(),
    _ => (),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
```

В примере выше, в случае `_`, не произойдёт ничего (результирующее выражение будет _юнит_).

### 6.3. Короткий поток управления с использованием `if let`

Синтаксис `if let` может обработать значения, совпадающие с теми или иными паттернами в более коротком виде.

Два следующих примера равнозначны:

```rust
let config_max = Some(3u8);
match config_max {
    Some(max) => println!("The maximum is configured to be {}", max),
    _ => (),
}
```

```rust
let config_max Some(3u8);
if let Some(max) = config_max {
    println!("The maximum is configured to be {}", max);
}
```

Два следующих примера равнозначны:

```rust
let mut count = 0;
match coin {
    coin::Quarter(state) => println!("State quarter from {:?}!", state),
    _ => count += 1,
}
```

```rust
let mut count = 0;
if let Coin::Quarter(state) = coin {
    println!("State quarter from {:?}!", state);
} else {
    count += 1;
}
```

## 7. Управление растущими проектами с использованием пакетов, "крэйтов" и модулей

Пакет может содержать несколько бинарных крейтов и, опционально, один библиотечный крэйт. Покуда проект растёт, можно извлекать части в разные сепарированные крэйты, которые становятся внешними зависимостями.

 + __Пакеты__: особенность _Cargo_, позволяющая собирать, тестировать и делиться крэйтами
 + __Крэйты__: дерево модулей, которое производит библиотеку или исполняемый файл
 + __Модули__ и __use__: дают контроль над организацией, областями видимости и приватностью путей
 + __Пути__: способ именования объектов (структуры, функции, модули)

### 7.1. Пакеты и "крэйты"

_Крэйт_ - единица компиляции в _Rust_.

Крэйт может быть двоичным или библиотечным. Двоичный крэйт - программа, которая компилируется в исполняемый файл. Каждый должен иметь точку входа `main()`.

Библиотечный крэйт не имеет точки входа `main()`.

Коренной крэйт - исходный файл, с которого компилятор начинает делать коренной модуль текущего крэйта.

Пакет - набор одного или более крэйтов. Пакет содержит файл `Cargo.toml`, который определяет, как собирать крэйты.

### 7.2. Определение модулей для контроля над областью видимости и приватностью

__Шпаргалка по модулям__

 + __Начало с корневого крейта__: когда компилируется крейт, компилятор в первую очередь смотрит в коренной крейт (обычно это `src/lib.rs` для библиотечного крейта или `src/main.rs` для двоичного крейта)
 + __Объявление модулей__: в корневом файле крейта можно определить новые модули; к примеру, чтобы определить модуль "garden", нужно использовать синтаксис `mod garden;`. Компилятор будет искать код модуля в следующих местах:
	 + "Инлайн" с фигурными скобками после `mod garden`
	 + В файле `src/garden.rs`
	 + В файле `src/garden/mod.rs`
 + __Определение сабмодулей__: в любом файле, кроме коренного крейта, можно определить сабмодули. К примеру, можно объявить `mod vegetables;` в `src/garden.rs`. Компилятор будет искать код сабмодуля в:
	 + "Инлайн" с фигурными скобками после `mod vegetables`
	 + В файле `src/garden/vegetables.rs`
	 + В файле `src/garden/vegetables/mod.rs`
 + __Пути к коду в модулях__: как только модуль становится частью крэйта, можно ссылаться на код в модуле из любого другого места крэйта, пока это позваляют правила приватности, используя путь к коду. К примеру, тип `Asparagus` в модуле _garden vegetables_ будет выглядеть, как `crate::garden::vegetables::Asparagus`
 + __Приватные и публичные__: код в пределах модуля приватный относительно его родительского модуля по-умолчанию. Для того, чтобы сделать модуль публичным, он должен быть задекларирован, как `pub mod`. Для того, чтобы объекты в пределах публичного модуля были публичными, нужно использовать `pub` в их определениях.
 + __Ключевое слово `use`__: В пределах области видимости, ключевое слово `use` создаёт короткие пути к объектам для уменьшения повторений длинных путей. В любой области видимости можно обратиться к `crate::garden::vegetables::Asparagus`, но можно использовать `use crate::garden::vegetables::Asparagus;` и, таким образом, ввести в текущую область видимости тип `Asparagus`.

В примере ниже структура двоичного крейта `backyard`:

```
backyard
|
+-Cargo.lock
|
+-Cargo.toml
|
+-src
  |
  +-garden
  | +
  | |
  | +-vegetables.rs
  |
  +-garden.rs
  |
  +-main.rs
```

`src/main.rs`:

```rust
use crate::garden::vegetables::Asparagus;

pub mod garden;

fn main() {
    let plant = Asparagus {};
    println!("I'm growing {:?}!", plant);
}
```

`pub mod garden;` говорит компилятору о том, что нужно включить код `src/garden.rs`.

`src/garden.rs`:

```rust
pub mod vegetables;
```

`pub mod vegetables;` означает, что нужно включить `src/garden/vegetables.rs`.

`src/garden/vegetables.rs`:

```rust
#[derive(Debug)]
pub struct Asparagus {}
```

__Группирование связанного кода в модули__

_Модули_ дают нам возможность расположить код в крэйте для удобочитаемости и переиспользования. Модули также дают возможность контролировать _приватность_ объектов, т.к. код модуля приватен по-умолчанию. Приватные объекты - внутренняя реализация, недоступная снаружи.

Крэйт можно структуризовать, организуя разные функции во вложенных модулях. Создаём новую библиотеку `restaurant`, выполнив `cargo new restaurant --lib`.

Модуль `front_of_house`, содержащий другие модули, которые содержат функции:

```rust
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}
        fn serve_order() {}
        fn take_payment() {}
    }
}
```

Тело модуля `front_of_house` содержит модули `hosting` и `serving`. Модули могут включать в себя определения и для других объектов: структур, перечислений, констант, трейтов и функций.

Древовидная структура модуля:

```
crate
|
+-front_of_house
  |
  +-hosting
  | |
  | +-add_to_waitlist
  | |
  | +-seat_at_table
  |
  +-serving
    |
    +-take_order
    |
    +-serve_order
    |
    +-take_payment
```

Корнем модуля является скрытый модуль под названием `crate`.

### 7.3. Пути для ссылки на предмет в дереве модулей

Путь имеет две формы:

 + _Абсолютный путь_ - это полный путь начиная от корня крэйта; для кода из внешнего крэйта, абсолютный путь начинается с имени крэйта, а для кода текущего крэйта, он начинается с литерала `crate`
 + _Относительный путь_ начинается с текущего модуля и использует `self`, `super` или идентификатор текущего модуля

Абсолютные и относительные пути используют разделитель `::` между идентификаторами.

Функция `eat_at_restaurant()` является частью публичного API крэйта, потому она помечается словом `pub`.

`src/lib.rs`:

```rust
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
// Абсолютный путь
    crate::front_of_house::hosting::add_to_waitlist();
// Относительный путь
    front_of_house::hosting::add_to_waitlist();
}
```

В примере выше ошибка при компиляции: модуль `hosting` приватный. Пути правильные, но нет доступа к приватным секциям. В _Rust_ все объекты приватны по отношению к родительскому модулю по-умолчанию.

Объекты в родительских модулях не могут использовать приватные объекты внутри дочерних модулей, но объекты в дочерних модулях могут использовать объекты модулей предков. Дочерние модули оборачивают и скрывают детали реализации, но могут видеть контекст, в которых они определены.

__Выставление путей наружу при помощи `pub`__

Попытка предоставления доступа к функции `add_to_waitlist()` для функции `eat_at_restaurant()` в `src/lib.rs`:

```rust
mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
// Абсолютный путь
    crate::front_of_house::hosting::add_to_waitlist();
// Относительный путь
    front_of_house::hosting::add_to_waitlist();
}
```

В примере выше всё-ещё будет ошибка: содержимое `hosting` всё-ещё приватно; пометив модуль, как публичный, его содержимое всё-ещё остаётся приватным. Функция `add_to_waitlist()` тоже должна быть публичной:

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    crate::front_of_house::hosting::add_to_waitlist();
    front_of_house::hosting::add_to_waitlist();
}
```

__Относительный путь с `super`__

Можно составить относительный путь, начинающийся с родительского модуля, а не с текущего, используя `super` в начале пути. Это аналогично синтаксису `..` в файловых системах. Использование `super` позволяет ссылаться на известный объект в родительском модуле, что позволяет реструктуризовать дерево модуля легче в случае, если родитель переместится в дереве модуля в будущем.

```rust
fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::deliver_order();
    }

    fn cook_order() {}
}
```

Функция `fix_incorrect_order()` находится в модуле `back_of_house`, потому можно использовать `super` для перехода в родительский модуль `back_of_house`, который, в данном случае, является `crate` (корень).

__Публичные структуры и перечисления__

Если `pub` используется перед определением структуры, члены структуры остаются приватными, тогда как сама структура остаётся публичной.

`src/lib.rs`:

```rust
mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer (toast: &str) -> Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("peaches"),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    let mut meal = back_of_house::Breakfast::summer("Rye");
    meal.toast = String::from("Wheat");
    println!("I'd like {} toast please", meal.toast);
// Если раскомментировать строку ниже, возникнет ошибка компиляции
    // meal.seasonal_fruit = String::from("blueberries");
}
```

Для перечислений (`enum`) все варианты становятся публичными, если помечаем перечисление, как публичное:

```rust
mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}
```

### 7.4. Использование путей в областях видимости при помощи ключевого слова _use_

Можно создать короткий путь к функции, используя `use` в области видимости.

Введения модуля в область видимости при помощи `use` в `src/lib.rs`:

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
```

Добавляя `use crate::front_of_house::hosting` в корень крэйта, `hosting` становится валидным именем в данной области видимости. Так, как будто бы модуль `hosting` был определён в корне крэйта.

Код ниже не скомпилируется, поскольку `use` использован в другой области видимости (вне дочернего модуля `customer`):

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

mod customer {
    pub fn eat_at_restaurant() {
        gosting::add_to_waitlist();
    }
}
```

__Создание идиоматических путей `use`__

Неидиоматическое внесение функции `add_to_waitlist()` в область видимости при помощи `use`:

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
}
```

Код выше не даёт понимания того, где определена функция `add_to_waitlist()`.

С другой стороны, когда в область видимости вводятся структуры, перечисления и т.д., идиоматически-верно будет задавать полный путь к объекту (`src/main.rs`):

```rust
use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
```

Исключение - введение в область видимости объектов с одинаковыми именами:

```rust
use std::fmt;
use std::io;

fn function1() -> fmt::Result {
// ...
}

fn function2() -> io::Result<()> {
// ...
}
```

__Предоставление новых имён с ключевым словом `as`__

Ещё одно решение для объектов с одинаковыми именами - использование алайасов. После полного пути, можно вставить ключевое слово `as` и новое локальное имя (алайас) для типа.

```rust
use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -> Result {
// ...
}

fn function2() -> IoResult<()> {
// ...
}
```

__Реэкспорт имён с помощью `pub use`__

При введении нового имени в область видимости при помощи `use`, имя в области видимости приватное. Для того, чтобы стал доступен код, который вызывает наш код, ссылающийся на данное имя так, будто бы оно было определено в области видимости данного кода, можно совместить `pub` и `use`. Таким образом, объект вводится в область видимости и становится доступным для других (для введения другими в область видимости).

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
```

До изменений выше, внешний код вызвал бы функцию `add_to_waitlist()`, используя путь `restaurant::front_of_house::hosting::add_to_waitlist()`. Теперь `pub use` реэкспортировал модуль `hosting` из коренного модуля так, что внешний код может использовать путь `restaurant::hosting::add_to_waitlist()`.

__Использование внешних пакетов__

`Cargo.toml`:

```toml
rand = "0.8.5"
```

Добавив `rand` в качестве зависимости в `Cargo.toml`, мы говорим _Cargo_, что нужно загрузить пакет _rand_ и все его зависимости из _crates.io_ и сделать _rand_ доступным для нашего проекта.

Далее, чтобы ввести в область видимости нашего пакета определения из `rand`, мы используем `use` с именем пакета и перечисляем его объекты, которые хотим ввести в область видимости.

```rust
use rand::Rng;

fn main() {
    let secret_number = rand::tread_rng().get_range(1..=100);
}
```

Стандартная библиотека `std` также является внешним крэйтом для нашего пакета.

```rust
use std::collections::HashMap;
```

__Использование вложенных путей для сокращения списков `use`__

Два примера ниже эквивалентны.

```rust
use std::cmp::Ordering;
use std::io;
```

```rust
use std::{cmp::Ordering, io};
```

Два примера ниже эквивалентны.

```rust
use std::io,
use std::io::Write;
```

```rust
use std::io::{self, Write};
```

__Оператор глобализации `*`__

Пример ниже введёт в область видимости все публичные объекты, определённые в `std::collections`.

```rust
use std:collections::*;
```

### 7.5. Разделение модулей по разным файлам

`src/lib.rs`:

```rust
mod front_of_house;

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
```

`src/front_of_house.rs`:

```rust
pub mod hosting {
    pub fn add_to_waitlist() {}
}
```

Загрузить файл, используя `mod` можно только один раз в дереве модулей.

Далее, можно переместить модуль `hosting` в свой файл. `hosting` - дочерний модуль модуля `front_of_house`.

`src/front_of_house.rs`:

```rust
pub mod hosting;
```

`src/front_of_house/hosting.rs`:

```rust
pub fn add_to_waitlist() {}
```

Альтернативные варианты для `front_of_house`:

 + `src/front_of_house.rs`
 + `src/front_of_house/mod.rs`

Альтернативные варианты для `hosting`:

 + `src/front_of_house/hosting.rs`
 + `src/front_of_house/hosting/mod.rs`

## 8. Основные "коллекции"

 + _Векторы_ позволяют хранить переменное число значений друг с другом
 + _Строки_ - это коллекции символов
 + _Хэш-карты_ позволяют ассоциировать значение с ключом. Это частный случай реализации структуры _карта_.

### 8.1. Хранение списков значений в векторах

Вектор `Vec<T>` может хранить данные только одного типа. Полезны для хранения таких объектов, как строки текста в файле или цены объектов в корзине для покупок.

```rust
let v: Vec<i32> = Vec::new();
```

Начальные значения для вектора можно задать при помощи макроса `vec!`:

```rust
let v = vec![1, 2, 3];
```

__Обновление вектора__

Добавить элементы в вектор можно используя метод `.push()`:

```rust
let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
```

Вектор должен быть, при этом, мутабельным.

__Чтение элементов вектора__

Два способа сослаться на элемент вектора: либо по его индексу, либо используя метод `.get()`:

```rust
let v = vec![1, 2, 3, 4, 5];

let third: &i32 = &v[2];
println!("The third element is {third}");

let third: Option<&i32> = v.get(2);
match third {
    Some(third) => println!("The third element is {third}"),
    None => println!("There is no third element"),
}
```

Элементы вектора индексируются с нуля.

```rust
let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &v[100]; // Здесь программа аварийно остановится
let does_not_exist = v.get(100); // Здесь .get() вернёт вариант None
```

В примере ниже будет попытка добавить элемент в вектор во время удержания ссылки на объект вектора:

```rust
let mut v = vec![1, 2, 3, 4, 5];
let first = &v[0];
v.push(6);
println!("The first element is: {first}");
```

Код выше не скомпилируется. Ссылка на первый элемент перестанет быть валидной, потому что вектор реаллоцируется после изменения размера и добавления нового элемента.

__Итерирование значений в векторе__

```rust
let v = vec![100, 32, 57];
for i in &v {
    println!("{i}");
}
```

Можно пробежаться по мутабельному вектору и изменить значения элементов (для этого должен быть использован оператор разыменования `*` на итераторе, ссылающимся на текущий элемент в цикле):

```rust
let mut v = vec![100, 32, 57];
for i in &mut v {
    *i += 50;
}
```

__Использование перечислений для хранения нескольких типов__

```rust
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from("blue")),
    SpreadsheetCell::Float(10.12),
]
```

Если нет информации о наборе типов вектора, перечисление для этого не подойдёт. В таком случае, нужно использовать трейты.

__Отбрасывание вектора отбрасывает хранящиеся в нём элементы__

Как и любая другая структура, вектор освобождается, как только выходит из области видимости.

```rust
{
    let v = vec![1, 2, 3, 4];
} // v выходит из области видимости и освобождается
```

### 8.2. Хранение текста в кодировке UTF-8 в строках

Строки имплементированы, как коллекции байт и методы, предоставляющие разнообразный функционал, чтобы интерпретировать эти коллекции, как текст.

__Что есть строка__

В _Rust_ есть только один строковой тип в ядре языка, являющийся строковым слайсом `str`, который обычно заимствуется из `&str`.

Тип `String` предоставляется стандартной библиотекой _Rust_. Он может менять размер, может быть мутабельным, может передавать владение над собой и иметь кодировку UTF-8.

__Создание новой строки__

Большинство операций, доступных для `Vec<T>`, также доступны и для `String`, т.к. `String` - обёртка поверх вектора с дополнительными ограничениями.

```rust
let mut s = String::new();
```

Метод `.to_string()`, который доступен любому типу с трейтом `Display`, создаёт новую строку, инициализированную строковым литералом:

```rust
let data = "initial contents";

let s = data.to_string();

let s = "initial contents".to_string();
```

Также можно использовать функцию `String::from()`, передав ей строковой литерал в качестве аргумента:

```rust
let s = String::from("initial contents");
```

UTF-8 можно использовать в строках:

```rust
let hello = String::from("Здравствуйте");
let hello = String::from("Hola");
let hello = String::from("Hello");
```

__Обновление строк__

`String` может менять размер и содержимое, как и `Vec<T>`. Можно использовать оператор `+` или макрос `format!()` для склейки `String`.

__Дополнение строк при помощи `push_str` и `push`__

Метод `.push_str()` принимает строковой слайс, потому что нам не обязательно владеть параметром.

```rust
let mut s = String::from("foo");
s.push_str("bar");
```

```rust
let mut s1 = String::from("foo");
let s2 = "bar";
s1.push_str(s2);
println!("s2 is {s2}");
```

Метод `.push()` принимает один символ в качестве параметра и добавляет его в `String`:

```rust
let mut s = String::from("lo");
s.push('l');
```

__Конкатенация при помощи `+` или макроса `format!()`__

```rust
let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &s2; // s1 была перемещена сюда и не может быть использована далее
```

Оператор `+` для строк использует метод `.add()` с сигнатурой `fn add(self, s: &str) -> String { ... }`.

В стандартной библиотеке `.add()` использует обобщения и ассоциированные типы.

При вызове `.add()` компилятор использует принуждение при разыменовании так, что `&String` становится `&str` (`&s2` становится `&s2[..]`).

Поскольку в `.add()` используется `self`, переменная `s1` будет перемещена в `.add()` и обращение к ней далее не будет валидным.

Можно соединить несколько строк:

```rust
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");
let s = s1 + "-" + &s2 + "-" + &s3;
```

Для более сложных конкатенаций, используется макрос `format!()`:

```rust
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");
let s = format!("{s1}-{s2}-{s3}");
```

__Индексация в строках__

Код ниже не скомпилируется:

```rust
let s1 = String::from("hello");
let h = s1[0];
```

__Внутреннее представление строк__

Строки представлены мультибайтовыми последовательностями. Каждый символ имеет переменный размер.

__Слайсы строк__

Индексация в строке зачастую - плохая идея, потому что неясно, что возвращать: байт, символ, кластер графемы или слайс.

Можно использовать `[]` с диапазоном для создания строкового слайса, содержащего конкретные байты:

```rust
let hello = "Здравствуйте";
let s = &hello[0..4];
```

`s` - `&str`, содержащий первые 4 байта строки; внутри будет слайс `Зд`, поскольку каждый символ в данном случае занимает по 2 байта.

__Методы итерирования по строкам__

Для каждого скалярного значения Unicode, используется метод `.chars()`. Вызов `.chars()` для строкового литерала "Зд" разделяет и возвращает два значения типа `char`, по которым можно пройтись итератором.

```rust
for c in "Зд".chars() {
    println!("{c}");
}
```

Метод `.byte()` вернёт каждый байт:

```rust
for b in "Зд".bytes() {
    println!("{b}");
}
```

### 8.3. Хранение ключей с ассоциированными значениями в хэш-картах

`HashMap<K, V>` хранит отображение ключей типа `K` на значения типа `V`, используя _хэширующую функцию_, определяющую способ хранения ключей и значений в памяти.

Хэш-карты полезны, когда нужно найти данные без использования индекса, но с использованием ключа любого типа. К примеру, в игре, можно хранить счёт команды, используя хэш-карту, где каждый ключ - название команды, а значение - счёт команды.

__Создание новой хэш-карты__

Используя `new()` можно создать пустую хэш-карту, далее добавляя в неё элементы при помощи `.insert()`.

```rust
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);
```

Также нужно включить `HashMap` из стандартной библиотеки при помощи `use`.

В этой `HashMap` ключи типа `String` и значения типа `i32`. Хэш-карты гомогенны.

__Доступ к значениям хэш-карты__

Значение из хэш-карты можно извлечь при помощи метода `.get()`:

```rust
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

let team_name = String::from("Blue");
let score = scores.get(&team_name).copied().unwrap_or(0);
```

`.get()` возвращает `Option<&V>`. Если для ключа нет значения, вернётся `None`. `.copied` возвращает `Option<i32>` вместо `Option<&i32>`; `.unwap_or()` устанавливает `score` в ноль, если в `scores` нет соответствия для ключа.

Можно проитерировать каждую пару ключ/значение в хэш-карте при помощи цикла `for`:

```rust
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

for (key, value) in &scores {
    println!("{key}: {value}");
}
```

__Хэш-карты и владение__

Для типов с трейтом `Copy`, значения копируются в хэш-карту. Для типов, над которыми можно брать владение, например `String`, значения перемещаются и хэш-карта становится владельцем этих значений:

```rust
use std::collections::HashMap;

let field_name = String::from("Favourite color");
let field_value = String::from("Blue");

let mut map = HashMap::new();
map.insert(field_name, field_value);
// Далее field_name и field_value невалидны, т.к. находятся в хэш-карте
```

Вызов `.insert()` переместил значения переменных в хэш-карту.

__Обновление хэш-карты__

Старое значение в карте можно изменить. Можно сохранить старое значение, а новое добавить только если у ассоциированного ключа нет значения. Старое и новое значение можно скомбинировать.

__Перезапись значений__

Использование `.insert()` может переписать старое значение.

```rust
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Blue"), 25);

println!("{:?}", scores);
```

__Добавление ключа и значения только если ключ отсутствует__

`.entry()` берёт ключ и сверяет параметры. Возвращает перечисление `Entry`, представляющее значение, которое может или не может существовать. Метод `.or_insert()` для `Entry` определён так, что возвращает мутабельную ссылку на значение для соответствующего ключа `Entry`, если ключ существует и, если ключа нет, то вставляет параметр, как новое значение для данного ключа и возвращает мутабельную ссылку на новое значение:

```rust
use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from("Blue"), 10);

scores.entry(String::from("Yellow")).or_insert(50); // Ключа Yellow не существует, потому создаётся новая пара в хэш-карте
scores.entry(String::from("Blue")).or_insert(50); // Ключ Blue уже присутствует, значение остаётся прежним

println!("{:?}", scores);
```

__Вставка значения на основе старого значения__

В примере ниже подсчитывается количество встречаемых в строке слов:

```rust
use std::collections::HashMap;

let text = "hello world wonderful world";

let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}

println!("{:?}", map);
```

__Хэширующие функции__

По-умолчанию, `HashMap` использует хэширующую функцию _SipHash_. Можно её сменить, сменяя тип для трейта `BuildHasher`.

## 9. Обработка ошибок

Ошибки в _Rust_ принадлежат двум категориям: _обратимые_ и _необратимые_. Для обработки обратимых ошибок обычно используется тип `Result<T, E>`, а для необратимых - макрос `panic!()`, который аварийно завершает работу программы.

### 9.1. Необратимые ошибки и _panic!_

По-умолчанию, когда возникает "паника", программа начинает "размотку", т.е. _Rust_ идёт назад по стеку и очищает данные встреченных функций. Это долгий процесс, потому можно отменить выполнение программы без очистки.

Память, использованная программой, должна быть очищена средствами ОС. Можно сделать отмены выполнения программы поведением по-умолчанию, добавив `panic = 'abort'` в секцию `[profile]` файла `Cargo.toml`. Пример:

```toml
[profile.release]
panic = 'abort'
```

Пример `panic!()`:

```rust
fn main() {
    panic!("crash and burn");
}
```

Вызов `panic!()` выводит сообщение об ошибке в последних двух строках. Первая строка показывает сообщение, переданное в `panic!()` и место в исходном коде, где возникла ошибка.

__Бэктрейс__

```rust
fn main() {
    let v = vec![1, 2, 3];
    v[99];
}
```

Для примера выше, где, очевидно, будет "паника" в результате обращения к элементу вектора, для которого не было выделено ресурсов, можно выставить переменную окружения `RUST_BACKTRACE`. Бэктрейс - список функций, которые были вызваны.

Отладочные символы включены по-умолчанию при компиляции без флага `--release`.

### 9.2. Обратимые ошибки и _Result_

Для перечисления `Result` есть два варианта:

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

`T` и `E` - параметры обобщённого типа. `T` вернётся в случае успеха с вариантом `Ok`, `E` вернётся в случае ошибки с вариантом `Err`.

`src/main.rs`:

```rust
use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) => file,
        Err(error) => panic!("Problem opening the file: {:?}", error),
    };
}
```

__Обработка разных ошибок__

```rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("Problem creating the file: {:?}", e),
            },
            other_error => {
                panic!("Problem opening the file: {:?}", other_error);
            }
        },
    };
}
```

Альтернативный вариант примера сверху с использованием замыканий и метода `.unwrap_or_else()`:

```rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("Problem creating the file: {:?}", error);
            })
        } else {
            panic!("Problem opening the file: {:?}", error);
        }
    });
}
```

__Короткие пути для паники при ошибке: `unwrap` и `expect`__

`Result<T, E>` имеет множество методов для различных задач. `.unwrap()` - это метод, похожий на выражение `match`. Если значение `Result` - `Ok`, `.unwrap()` вернёт значение внутри `Ok`. Если `Result` - `Err`, `.unwrap()` вызовет `panic!()`^

```rust
use std::fs::file;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap();
}
```

Метод `.expect()` даёт нам вывести сообщение об ошибке для `panic!()`; используется так же, как и `.unwrap()`:

```rust
use std::fs::file;

fn main() {
    let greeting_file = File::open("hello.txt").expect("hello.txt should be present");
}
```

__Распространение ошибок__

Когда реализация функции вызывает что-то, что может привести к ошибке, вместо того, чтобы обрабатывать ошибку внутри функции, можно вернуть ошибку вызывающему функцию коду и решить, что делать дальше. Это называется распространением ошибки и даёт больше контроля вызывающему коду.

```rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let username_file_result = File::open("hello.txt");

    let mut username_file = match username_file_result {
        Ok(file) => file,
        Err(e) => return Err(e),
    };

    let mut username = String::new();

    match username_file.read_to_string(&mut username) {
        Ok(_) => Ok(username),
        Err(e) => Err(e),
    }
}
```

Функция выше возвращаети результат типа `Result<String, io::Error>`, т.е., значение типа `Result<T, E>`, где обобщённый параметр `T` был заполнен типом `String`, а обобщённый параметр `E` был заполнен типом `io::Error`.

Если функция выполнится без ошибок, вызывающий её код получит значение `Ok`, содержащее строку `String` (имя пользователя, прочитанное из файла).

__Короткий путь распространения ошибок: оператор `?`__

Функциональность кода ниже эквивалентна функциональности кода выше.

```rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let mut username_file = File::open("hello.txt")?;
    let mut username = String::new();
    username_file.read_to_string(&mut username)?;
    Ok(username)
}
```

`?`, размещённый после значения типа `Result`, работает таким же образом, как и `match` для обработки значений `Result`. Если значение `Result` - `Ok`, значение внутри `Ok` вернётся из этого выражения. Если значение - `Err`, `Err` вернётся вызывающей функции.

Отличие от выражений с `match` в том, что значения ошибок с оператором `?`, вызванным для них, проходят через функцию `from()`, определённую в трейте `From` стандартной библиотеки, который используется для конвертирования значений из одного типа в другой. Когда оператор `?` вызывает функцию `from()`, она получает тип ошибки и конвертируется в тип ошибки, определённый в возвращаемом типе текущей функции. Это полезно в том случае, когда функция возвращает один тип ошибок, чтобы представить все способы, которые могут вызвать падение.

```rust
use std::fs::File,
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let mut username = String::new();

    File::open("hello.txt")?.read_to_string(&mut username)?;

    Ok(username)
}
```

В примере выше вместо создания переменной `username_file`, была сделана цепочка вызовов к `.read_to_string()` прямо, как результат `File::open("hello.txt")?`.

Пример ниже - ещё более короткое использование `fs::read_to_string()`:

```rust
use std::fs;
use std::io;

fn read_username_from_file() -> Result<String, io::Error> {
    fn::read_to_string("hello.txt")
}
```

__Для чего может быть использован оператор `?`__

Оператор `?` может быть использован только для функций, тип возвращаемого значения которых совместим с `?`. Это происходит потому что оператор `?` определён для выполнения раннего возврата значения из функции.

Пример ошибочного использования оператора `?`:

```rust
use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")?;
}
```

Пример не скомпилируется, поскольку `main()` возвращает юнит (`()`).

Два способа исправить ошибку выше: либо сделать возвращаемый тип для `main()` совместимым с оператором `?`, либо использовать `match` или один из методов `Result<t, E>` для обработки результата удобным способом.

Использование `?` для значения типа `Option<T>`:

```rust
fn last_char_of_first_line(text: &str) -> Option<char> {
    text.lines().next()?.chars().last()
}
```

Функция выше возвращает `Option<char>`, потому что символ как может находиться в строке, так и может отсутствовать.

Использовать `?` для `Result` можно только в функции, возвращаемый тип которой является `Result`. То же правило и для `Option`. Оператор `?` не сконвертирует автоматически `Result` в `Option` и наоборот; в таких случаях, можно использовать методы `.ok()` для `Result` или `.ok_or()` для `Option`.

Функция `main()` выделяется на фоне остальных. `main()` может вернуть значение типа `Result<(), E>` и, в таком случае, внутри неё можно использовать оператор `?`:

```rust
use std::error::Error;
use std::fs::File;

fn main() -> Result<(), Box<dyn Error>> {
    let greeting_file = File::open("hello.txt")?;

    Ok(())
}
```

`Box<dyn Error>` - это _трейт_. Означает в данном случае "любой тип ошибки". Возвращаемое значение из `main()` будет целочисленным значением (`0` - в случае успеха).

`main()` может вернуть любой тип, который имплементирует трейт `std::process:Termination`, содержащий функцию `report`, возвращающую `ExitCode`.

### 9.3. Использование _panic!_

В случае реализации примеров, прототипов и тестов, часто бывает более разумно использовать `panic!()` вместо возврата `Result`.

`.unwrap()` и `.expect()` очень полезны при прототипировании и тестировании.

__Создание пользовательских типов для валидации__

Пример ниже не является корректным, поскольку цикл с проверкой значения может повлиять на производительность.

```rust
loop {
// ...
    let guess: i32 = match guess.trim().parse() {
        Ok(num) => num,
        Err(_) => continue,
    };

    if guess < 1 || guess > 100 {
        println!("The secret number will be between 1 and 100.");
        continue;
    }

    match guess.cmp(&secret_number) {
// ...
    }
}
```

Тип `Guess`, который поддерживает только значения между `1` и `100`:

```rust
pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess value must be between 1 and 100, got {}.", value);
        }
        Guess { value }
    }

    pub fn value(&self) -> i32 {
        self.value
    }
}
```

В примере выше, `Guess` создаст объект при вызове `.new()` только в том случае, если `new` примет в качестве параметра значение из диапазона от `1` до `100`.

## 10. Обобщённые типы, "трейты" и время жизни

_Обобщения_ - абстрактные замены для конкретных типов или иных свойств. Выразить поведение обобщений можно так, что мы не будем знать, что будет на их месте при компиляции и запуске кода.

Функции могут принимать в качестве параметров обобщения, так же как функция принимает параметры с неизвестным количеством значений. Как пример использования обобщений, можно выделить `Option<T>`, `Vec<T>`, `HashMap<K, V>` или `Result<T, E>`.

__Устранение дублирований экстракцией функции__

 + Обнаружение дублирующегося кода
 + Экстракция дублирующегося кода в функцию и определение аргументов и возврата для определения функции
 + Обновление инстанций дублирующегося кода так, чтобы они вызывали функцию

```rust
fn largest(list: &[i32]) -> &i32 {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&number_list);
    println!("The largest number is {}", result);
}
```

### 10.1. Обобщённые типы данных

Обобщённые типы данных используются для создания определений функций или структур, которые в дальнейшем можно использовать вместе с определёнными типами данных.

__Определения функций__

В примере ниже две функции (`_largest_i32()` и `largest_char()`), которые делают одно и то же для разных типов.

```rust
fn largest_i32(list: &[i32]) -> &i32 {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &[char]) -> &char {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&char_list);
    println!("The largest char is {}", result);
}
```

Для определения обобщённой функции `largest()`, нужно использовать синтаксис определения обобщённого типа (помещение обобщённого типа внутрь треугольных скобок после имени функции и до списка аргументов функции, `fn largest<T>(list: &[T]) -> &T { ... }`):

```rust
fn largest<T>(list: &[T]) -> &T {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("The largest char is {}", result)
}
```

Код выше не скомпилируется, поскольку нужно ограничить типы для обобщённой функции теми типами, которые имеют трейт `PartialOrd`.

__Структуры__

Структуры также могут содержать в себе поля обобщённых типов (определяются при помощи синтаксиса `<>`):

```rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
```

Для примера выше, `x` и `y` должны быть одинакового обобщённого типа.

Можно использовать несколько обобщённых типов:

```rust
struct Point<T, U> {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10};
    let both_float = Point { x: 1.0, y: 4.0};
    let integer_and_float = Point { x: 5, y: 4.0};
}
```

__Перечисления__

Примеры из стандартной библиотеки:

```rust
enum Option<T> {
    Some(T),
    None,
}
```

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

__Методы__

```rust
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}
```

Выше реализован метод `.x()` для `Point<T>`, возвращающий ссылку на данные в поле `x`.

`T` должен быть обозначен сразу после `impl` так, чтобы мы могли использовать `T` в методе, имплементируемом для `Point<T>`. Определяя `T`, как обобщённый тип после `impl`, _Rust_ однозначно определит тип в треугольных скобках в `Point` - это обобщённый тип, а не конкретный.

Можно также определить ограничения для обобщённых типов, когда определяем методы. К примеру, можно определить методы, которые будут у объектов `Point<f32>`, а не у `Point<T>`.

```rust
impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
```

Объекты `Point<T>`, где `T` - любой тип, кроме `f32`, не будут иметь данного метода.

Обобщённые типы в определениях структур не обязательно должны совпадать с обобщёнными типами в определениях методов. В примере ниже параметры `X1` и `Y1` здесь определены после `impl`, потому что они есть в определении структуры. Параметры `X2` и `Y2` определены только для метода `.mixup()`:

```rust
struct Point<X1, Y1> {
    x: X1,
    y: Y1,
}

impl<X1, Y1> Point<X1, Y1> {
    fn mixup<X2, Y2>(self, other: Point<X2, Y2>) -> Point<X1, Y2> {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c' };

    let p3 = p1.mixup(p2);

    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}
```

__Производительность__

_Rust_ сохраняет проихводительность при использовании обобщённых типов с помощью мономорфизации кода во время компиляции.

### 10.2. Трейты: определение общего поведения

Трейты определяют функциональность, которую определённый тип может разделять с другими типами (в некоторых других ЯП трейты могут именоваться интерфейсами).

__Определение трейта__

Поведения типа зачастую определяется методами. Разные типы разделяют одно поведение, если мы определили схожие методы для них. Трейты - есть способ сгруппировать сигнатуры методов для определения набора поведений.

```rust
pub trait Summary {
    fn summarize(&self) -> String;
}
```

После сигнатуры трейта под названием `Summary`, идут фигурные скобки, в которых определяются сигнатуры методов (`.summarize()`), которые определяют поведение типов, которым присвоен данный трейт. После сигнатуры метода, вместо имплементации в фигурных скобках, используется точка с запятой. Каждый тип, имеющий данный трейт, должен предоставить собственную реализацию метода `.summarize()`.

__Реализация трейта для типа__

`src/lib.rs`:

```rust
pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&self) -> String {
        format!("{}: {}", self.username, self.content)
    }
}
```

Имплементация трейта для типа схожа с имплементацией методов. После ключевого слова `impl` идёт название трейта, который хотим реализовать. Далее, используется ключевое слово `for` с последующим указанием имени типа, для которого реализуется трейт. В блок `impl` вставляются сигнатуры методов трейта с их определениями.

```rust
use aggregator::{Summary, Tweet};

fn main() {
    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from("of course, as you probably already know, people",),
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
}
```

Можно реализовать трейт `Summary` для `Vec<T>` внутри крэйта `aggregator`, т.к. `Summary` - локальный по отношению к крэйту `aggregator` трейт.

Внешние трейты не могут быть реализованы для внешних типов. К примеру, невозможно имплементировать трейт `Display` для `Vec<T>` внутри крэйта `aggregator`, т.к. `Display` и `Vec<T>` определены в стандартной библиотеке. Данное свойство называется _когерентность_ (_правило сироты_).

__Реализации по-умолчанию__

Иногда полезно иметь поведение по-умолчанию для некоторых или всех методов трейта вместо реализации всех методов для всех типов. Далее, при имплементации трейта для конкретного типа, можно оставить или переписать (определив метод для трейта, как было показано в примерах выше) поведение метода.

```rust
pub trait Summary {
    fn summarize(&self) -> String {
        String::from("(Read more...)")
    }
}
```

Для использования реализации по-умолчанию для подытоживания реализаций `NewsArticle`, указывается пустой блок `impl` с `impl Summary for NewsArticle {}`.

```rust
let article = NewsArticle {
    headline: String::from("Penguins win the Stanley Cup Championship!"),
    location: String::from("Pittsburgh, PA, USA"),
    author: String::from("Iceburgh"),
    content: String::from("The Pittsburgh Penguins once again are the best hockey team in the NHL.",),
};

println!("New article available! {}", article.summarize());
```

Реализации по-умолчанию могут вызывать другие методы в том же трейте, даже если другие методы не имеют реализации по-умолчанию.

```rust
pub trait Summary {
    fn summarize_author(&self) -> String;

    fn summarize(&self) -> String {
        format!("(Read more from {}...)", self.summarize_author())
    }
}
```

```rust
impl Summary for Tweet {
    fn summarize_author(&self) -> String {
        format!("@{}", self.username)
    }
}
```

```rust
let tweet = Tweet {
    username: String::from("horse_ebooks"),]
    content: String::from("of course, as you probably already know, people",),
    reply: false,
    retweet: false,
};

println!("1 new tweet: {}", tweet.summarize());
```

__Трейты, как параметры__

Трейты можно использовать для определения функций, принимающих множество различных типов.

Функция `notify()` вызовет методы `.summarize()` для методов, входящих в параметр функции `item`, являющийся любым типом с трейтом `Summary`.

```rust
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}
```

__Синтаксис привязки трейта__

Существует возможность использовать "синтаксический сахар" под названием "привязка трейта".

```rust
pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}
```

Пример выше - эквивалент предыдущего примера `notify()`, но более подробен. Привязка трейта помещается с определением параметра обобщённого типа после двоеточия внутри треугольных скобок.

Два примера ниже эквивалентны друг другу. В них используется два параметра, имплементирующих трейт `Summary`.

```rust
pub fn notify(item1: &impl Summary, item2: &impl Summary) {
// ...
}
```

```rust
pub fn notify<T: Summary>(item1: &T, item2: &T) {
// ...
}
```

__Множественная привязка трейтов при помощи `+`__

Можно совмещать более одного трейта, т.е. параметр функции должен иметь реализованными оба указанных трейта, собранных вместе при помощи оператора `+`. Два примера ниже эквивалентны.

```rust
pub fn notify(item: &(impl Summary + Display)) {
// ...
}
```

```rust
pub fn notify<T: Summary + Display>(item: &T) {
// ...
}
```

__Создание привязки трейта при помощи `where`__

Использование большого количества привязки трейтов имеет свои негативные стороны. Каждое обобщение имеет свои привязки трейтов, так что функции с несколькими параметрами обобщённого типа могут содержать множество информации о привязках трейтов между именем функции и списком параметров. Для большей удобочитаемости в данном случае, используется ключевое слово `where`. Два примера ниже эквивалентны.

```rust
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {
// ...
}
```

```rust
fn some_function<T, U>(t: &T, u: &U) -> i32
where
    T: Display + Clone,
    U: Clone + Debug,
{
// ...
}
```

__Возврат типов, имплементирующих трейты__

Синтаксис `impl Trait` можно использовать для тех случаев, когда функции необходимо вернуть любой тип данных, имплементирующий нужный трейт.

```rust
fn returns_summarizable() -> impl Summary {
    Tweet {
        username: String::from("horse_ebooks"),
        content: String::from("of course, as you probably already know, people",),
        reply: false,
        retweet: false,
    }
}
```

Возможность определить возвратный тип только по трейту полезна в контексте использования замыканий и итераторов. Замыкания и итераторы создают типы, о которых знает только компилятор или типы, которые имеют длинное определение.

Ниже ещё пример попытки использования возврата по трейтам (увы, не скомпилируется из-за ограничений синтаксиса `impl Trait`). Но для функции с подобным функционалом могут быть использованы _объекты трейтов_ (см.: [[#17.2. Использования "трейтов" для присвоения объектам значений различных типов]]).

```rust
fn returns_summarizable(switch: bool) -> impl Summary {
    if switch {
        NewsArticle {
            headline: String::from("Penguins win the Stanley Cup Championship!",),
            location: String::from("Pittsburgh, PA, USA"),
            author: String::from("Iceburgh"),
            content: String::from("The Pittsburgh Penguins once again are the best hockey team in the NHL.",),
        }
    } else {
        Tweet {
            username: String::from("horse_ebooks"),
            content: String::from("of course, as you probably already know, people",),
            reply: false,
            retweet: false,
        }
    }
}
```

__Использование трейтов для условной реализации методов__

Используя связывание трейтов в блоке `impl`, который использует параметры обобщённого типа, можно реализовать методы, зависящие от типов, которые имплементируют указанные трейты.

```rust
use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self { x, y }
    }
}

impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}
```

Поскольку стандартная библиотека имеет имплементацию трейта `ToString`, мы можем вызвать метод `.to_string()` для любого типа, который имплементирует трейт `Display`, поскольку трейт `ToString` имплементирован для всех типов, у которых есть имплементация трейта `Display`.

```rust
impl<T: Display> ToString for T {
// ...
}
```

### 10.3. Валидация ссылок и время жизни

Время жизни - ещё одно из обобщений. Вместо того, чтобы удостоверяться в том, что тип имеет нужное нам поведение, время жизни даёт нам гарантию, что ссылки валидны столько, сколько нам это нужно.

Каждая ссылка в _Rust_ имеет собственное время жизни (область видимости, в которой ссылка валидна). В большинстве случаев, время жизни неявно и предполагаемо, как и предполагаемы типа данных. Мы должны указывать типа только когда есть несколько вариантов интерпретации. Точно так же, мы должны указывать время жизни, когда время жизни ссылки может быть неявным. В _Rust_ мы должны указывать взаимоотношения, используя обобщённые параметры времени жизни для того, чтобы удостовериться, что ссылки во время выполнения программы будут валидны.

__Предотвращение появления висящих ссылок при помощи времени жизни__

Основное предназначение времени жизни - исключение появления висящих ссылок. Ниже пример попытки использования ссылки, значение которой вне области видимости (не скомпилируется):

```rust
fn main() {
    let r;

    {
        let x = 5;
        r = &x;
    }

    println!("r: {}", r);
}
```

Значение, на которое ссылается `r`, выходит из области видимости.

Переменная `x` не живёт нужное время, но переменная `r` из "внешней" области видимости валидна для использования в ней же.

__Проверка заимствований__

_Rust_ проверяет заимствования на валидность. В примерах ниже в комментариях показано время жизни переменных. _Rust_ сравнивает размар двух времён жизни (время жизни `'b` короче времени жизни `'a`). Субъект ссылки живёт короче, чем сама ссылка.

```rust
fn main() {
    let r;                // ----------+-- 'a
                          //           |
    {                     //           |
        let x =5;         // -+-- 'b   |
        r = &x;           //  |        |
    }                     // -+        |
                          //           |
    println!("r: {}", r); //           |
}                         // ----------+
```

Пример ниже не имеет ошибок (время жизни для `r` заканчивается раньше, чем для `x`).

```rust
fn main() {
    let x = 5             // ----------+-- 'b
                          //           |
    let r = &x;           // --+-- 'a  |
                          //   |       |
    println!("r: {}", r); //   |       |
                          // --+       |
}                         // ----------+
```

__Обобщённое время жизни в функции__

Ниже пример: функция, возвращающая самый длинный из двух строковых слайсов. Эта функция принимает два строковых слайса и возвращает один.

```rust
fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}
```

Строковые слайсы являются ссылками, а не самими строками, поскольку нам не нужно, чтобы `longest()` овладевала параметрами. Пример ниже не скомпилируется.

```rust
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

Не скомпилируется он потому, что для возвращаемого типа нужно указать обобщённый параметр времени жизни, поскольку _Rust_ не может знать, будет ли возврат принадлежать `x` или `y`.

__Аннотация времени жизни__

Обозначение времени жизни не изменяет его для ссылок. Оно, скорее, описывает отношение времени жизни нескольких ссылок по отношению друг к другу.

Имя параметра времени жизни должно начинаться с апострофа (`'`), обычно очень короткое. Обычно используют `'a` для первой аннотации времени жизни. Параметр времени жизни помещается после `&` для ссылки с использованием пробела для отделения типа данных от ссылки.

Ниже несколько примеров.

```rust
&i32 // ссылка
&'a i32 // ссылка с явным временем жизни
&'a mut i32 // мутабельная ссылка с явным временем жизни
```

__Аннотация времени жизни в сигнатурах функций__

Для использования аннотации времени жизни в функциях, необходимо указать обобщённый параметр времени жизни в треугольных скобках между именем функции и списком параметров (как и в случае с параметрами обобщённых типов).

Для функции `longest()` из примера выше нам нужна сигнатура для того, чтобы выразить следующее: возвращаемая ссылка будет валидна до тех пор, пока оба параметра валидны. Это есть отношение между временем жизни параметров и возвращаемым значением. Функция `longest()` ниже указывает на то, что все ссылки в сигнатуре должны иметь одно время жизи `'a`.

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

Сигнатура функции в примере выше говорит _Rust_ о том, что для некоторого времени жизни `'a` функция принимает 2 параметра, которые являются строковыми слайсами со временем жизни не меньше `'a`. Сигнатура также говорит о том, что строковой слайс, возвращаемый из функции, должен иметь время жизни, не меньше `'a`. На практике это означает, что время жизни ссылки, возвращаемой из `longest()` то же, что и наименьшее из времён жизни значений, переданных в качестве аргументов.

Указывая параметры времени жизни, мы не изменяем их ни в параметрах, ни в возвращаемом значении. Мы указываем, что на этапе проверки заимствований должны отбрасываться любые значения, которые не подходят для данных ограничений. Функция `longest()` не обязана знать, сколько именно будут "жить" `x` и `y`, а только лишь то, что некоторая подходящая область видимости может быть подставлена вместо `'a`.

```rust
fn main() {
    let string1 = String::from("long string is long");

    {
        let string2 = String::from("xyz");
        let result = longest(string1.as_str(), string2.as_str());
        println!("The longest string is {}", result);
    }
}
```

Следующий пример показывает, что время жизни ссылки в `result` должно быть меньшим из двух аргументов. Мы переместим объявление переменной `result` вне внутренней области видимости, но оставим присвоение значения переменной `result` во внутренней области видимости вместе со `string2`. Далее, переместим `println!()`, использующий `result` во внешнюю область видимости. Данный пример не скомпилируется.

```rust
fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {}", result);
}
```

Ошибка компилятора покажет нам, что для `result` в `println!()` `string2` должна быть валидна до конца области видимости. _Rust_ знает об этом, потому что мы обозначили время жизни параметров функции и возвращаемого значения, используя один параметр времени жизни `'a`.

`string1` живёт дольше, чем `string2`, потому `result` будет содержать ссылку на `string1`. Ссылка на `string1` будет валидна для `println!()`. Тем не менее, компилятору не очевидно, что ссылка валидна в данном случае.

__Мышление в контексте времени жизни__

Способ определения времени жизни параметров зависит от назначения функции. К примеру, если мы изменим функцию `longest()` так, чтобы она всегда возвращала только первый параметр, нам не будет нужно определять время жизни для параметра `y`:

```rust
fn longest<'a>(x: &'a str, y: &str) -> &'a str {
    x
}
```

Мы указали параметр времени жизни `'a` для параметра `x` и возвращаемого типа, но не для `y`, потому что время жизни `y` не имеет отношения к параметру `x` и возвращаемому значению.

Когда мы возвращаем ссылку из функции, параметр времени жизни для возвращаемого типа должен совпадать со временем жизни одного из параметров. Если возвращаемая ссылка не ссылается ни на один из параметров, она должна ссылаться на значение, созданное внутри функции. Но это будет висячей ссылкой, поскольку значение выйдет за пределы области видимости в конце функции. Пример ниже не скомпилируется.

```rust
fn longest<'a>(x: &str, y: &str) -> &'a str {
    let result = String::from("really long string");
    result.as_str()
}
```

В рассмотренном примере время жизни возвращаемого значения не связано со временем жизни параметров. `result` выходит из области видимости и очищается в конце функции `longest()`. Нет способа указать параметр времени жизни так, что будет отсутствовать висящая ссылка. В таком случае, лучше всего будет вернуть заимствованные данные, чем ссылку.

В общем и целом, синтаксис времени жизни нужен для связывания различных параметров и возвращаемых значений. Как только они связаны, у _Rust_ есть достаточно информации для того, чтобы позволить проводить безопасные операции.

__Аннотация времени жизни в определениях структур__

В примере ниже структура со ссылкой, для которой нужно указать время жизни.

```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().expect("Could not find a '.'");
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
```

Единственное поле структуры в примере - `part`, содержащее строковой слайс, который является ссылкой. Экземпляр `ImportantExcerpt` не может жить дольше, чем ссылка в поле `part`.

`main()` создаёт экземпляр структуры, в которой содержится ссылка на первое предложение из переменной `novel` типа `String`. Данные в `novel` уже существуют на момент создания `ImportantExcerpt`. `novel` не выходит из области видимости до того, как из области выходит `ImportantExcerpt`, так что ссылка `part` валидна.

__Элизия времени жизни__

Пример функции, скомпилированной без аннотации времени жизни (параметр и возвращаемое значение - ссылки):

```rust
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item = b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```

В ранних версиях _Rust_ (`pre-1.0`) код из примера выше не скомпилировался бы, поскольку каждая ссылка нуждалась в указании времени жизни. Тогда сигнатура функции должна была выглядеть так:

```rust
fn first_word<'a>(s: &'a str) -> &'a str { ... }
```

Но далее, были учтены паттерны, в случае столкновения с которыми время жизни указывать не нужно.

Паттерны, встроенные в анализатор ссылок _Rust_, называются _правилами элизии времени жизни_. Это набор случаев, учитываемых компилятором и, если код соответствует данным случаям, указывать время жизни не обязательно.

Время жизни для параметров методов или функций называется _входным временем жизни_, для возвращаемых значений - _выходным временем жизни_.

Первое правило, которое использует компилятор применяется ко входным временам жизни, второе и третье - к выходным. Если компилятор проходит по всем трём правилам и всё-ещё имеются ссылки, для которых он не может определить время жизни, компиляция останавливается.

Первое правило заключается в том, что компилятор назначает параметр времени жизни для каждого параметра, являющегося ссылкой. Функция с одним параметром получает один параметр времени жизни: `fn foo<'a>(x: &'a i32);`; функция с двумя параметрами получает два разных параметра времени жизни: `fn foo<'a, 'b>(x: &'a i32, y: &'b i32);` и т.д.

Второе правило: если существует только один входной параметр времени жизни, данное время жизни связывается со всеми выходными параметрами времени жизни: `fn foo<'a>(x: &'a i32) -> &'a i32`.

Третье правило: если существует несколько входных параметров времени жизни, но одно изних `&self` или `&mut self` в случае, если это метод, время жизни `self` присваивается всем выходным параметрам времени жизни.

Поэтапно для примера ниже:

```rust
fn first_word(s: &str) -> &str { ... }
```

Правило 1

```rust
fn first_word<'a>(s: &'a str) -> &str { ... }
```

Правило 2

```rust
fn first_word<'a>(s: &'a str) -> &'a str { ... }
```

Для следующего примера действует только первое правило, поскольку функция `longest()` имеет более одного входного времени жизни:

```rust
fn longest(x: &str, y: &str) -> &str { ... }
```

Правило 1

```rust
fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str { ... }
```

Потому и была ошибка при компиляции.

__Аннотация времени жизни в определениях методов__

При реализации методов в структурах со временем жизни, используется тот же синтаксис. Место определения и использования параметров времени жизни зависит от того, связаны они с полями структуры или параметрами методов и возвращаемых значений.

Имена времени жизни для полей структур всегда должны быть определены после `impl` и далее быть использованы после имени структуры, поскольку данные времена жизни являются частью типа структуры.

В сигнатурах методов внутри `impl` ссылки могут быть привязаны ко времени жизни ссылок в полях структуры или же быть независимыми.

```rust
impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }
}
```

В примере ниже применяется третье правило элизии времени жизни.

```rust
impl<'a> ImportantExcerpt<'a> {
    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("Attention please: {}", announcement);
        self.part
    }
}
```

__Статичное время жизни__

Время жизни `'static` является специальным. Оно обозначает, что ссылка может жить на протяжении всего выполнения программы.

```rust
let s: &'static str = "I have a static lifetime.";
```

Текст строки выше хранится прямо в двоичном коде программы, который всегда доступен. Отсюда, время жизни всех строковых литералов `'static`.

__Обобщённые типы данных, привязка трейтов и времена жизни вместе__

Ниже пример функции, которая возвращает длиннейшую из двух строковых слайсов. Но теперь она имеет дополнительный параметр `ann` обобщённого типа `T`, который может быть любым типом, имплементирующим трейт `Display` (ограничение указано при помощи `where`). Данный дополнительный параметр будет напечатан при помощи `{}`, потому трейт `Display` нам и нужен. Время жизни - обобщение, потому объявление параметра времени жизни `'a` и обобщённого типа данных `T` находятся вместе внутри треугольных скобок.

```rust
use std::fmt::Display;

fn longest_with_an_announcement<'a, T>(
    x: &'a str,
    y: &'a str,
    ann: T,
) -> &'a str
where
    T: Display,
{
    println!("Announcement! {}", ann);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

## 11. Написание "автотестов"

### 11.1. Как писать тесты

Тела функций тестов обычно выполняют три действия:

 1. Предоставляют необходимые данные или состояния
 2. Выполняют тот код, который необходимо протестировать
 3. Проверяют результат с ожидаемым

__Анатомия функции тестирования__

Тест в _Rust_ - функция, аннотированная атрибутом `test`. Атрибуты являются метаданными, относящимися к коду _Rust_; один из примеров - атрибут `derive`, использованный со структурами в [[#5. Использование структур]]. При запуске тестов командой `cargo test`, _Rust_ собирает двоичный файл, "проходящий" по тестам в аннотированных функциях и сообщает о проходе по каждому из них.

Каждый раз при создании новой библиотеки при помощи _Cargo_, модуль теста с функциями тестирования в нём генерируется для нас. Этот модуль даёт шаблон для написания собственных тестов так, что не обязательно знать каждую структуру при создании нового проекта.

Пример - создание библиотеки `adder`:

```bash
cargo new adder --lib
cd adder
```

`src/lib.rs`:

```rust
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }
}
```

Внимание на аннотацию `#[test]`: данный атрибут означает, что ниже расположена функция тестирования. Также можно иметь дополнительные функции в модуле `tests` для создания различных сценариев или выполнения общих операций.

Функция в примере использует макрос `assert_eq!()`, проверяющую, что `result` равен четырём.

```bash
cargo test
```

_Cargo_ скомпилировал и запустил тест.

Есть возможность обозначить тест, как игнорируемый, чтобы не выполнять его в частном случае. Можно также в качестве аргумента для `cargo test` задать строку, тесты, совпадающие с которой, будут выполняться (_фильтрация_).

Также есть "бенчмарки" (доступны в nightly).

_Rust_ может компилировать любые примеры кода из документации к нашему __API__.

Далее изменим имя функции `it_works()` на `exploration()`.

`src/lib.rs`:

```rust
#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }
}
```

```bash
cargo test
```

Далее добавим ещё один тест, но в этот раз сделаем такой, что в любом случае он "упадёт". Тест "падает", если функция "паникует". Каждый тест запускается в новом потоке и, когда основной поток видит, что поток теста аварийно завершился, остальные тесты помечаются, как "упавшие".

`src/lib.rs`:

```rust
#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    fn another() {
        panic!("Make this test fail");
    }
}
```

```bash
cargo test
```

Вместо `ok`, строка `test test::another` помечена, как `FAILED`.

__Проверка результата макросом `assert!()`__

Макрос `assert!()`, предоставляемый стандартной библиотекой, полезен при проверке состояния теста на значение `true`. Мы даём макросу `assert!()` аргумент, который раскрывается в булево значение. Если значение `true`, тест проходит, если `false`, макрос вызывает `panic!()`.

Ниже пример теста для метода `.can_hold()` структуры `Rectangle` с использованием макроса `assert!()`.

`src/lib.rs`:

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
```

Метод `.can_hold()` возвращает булево значение, что делает его подходящим для макроса `assert!()`.

Ниже создадим тест, который выполняет `.can_hold()`.

`src/lib.rs`:

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };
        
        assert!(larger.can_hold(&smaller));
    }
}
```

Мы ожидаем выполнения данного теста для данного случая (`.can_hold()` вернёт `true`).

Внутри модуля `tests` мы добавили `use super::*`. Модуль `tests` является обычным модулем, который следует правилам из [[#7. Управление растущими проектами с использованием пакетов, "крэйтов" и модулей]]. Модуль `tests` - внутренний, потому нужно вставить код в его область видимости. `*` используется здесь для того, чтобы всё, что было определено во внешнем модуле, было доступно для внутреннего модуля `tests`.

```bash
cargo test
```

Дальше добавим тест, который проверит, что меньший прямоугольник не может содержать больший:

`src/lib.rs`:

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() { ... }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };
        
        assert!(!smaller.can_hold(&larger));
    }
}
```

```bash
cargo test
```

Теперь изменим один из знаков в методе `.can_hold()` так, что один из тестов не пройдёт:

```rust
// ...
impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width < other.width && self.height > other.height
    }
}
```

```bash
cargo test
```

__Проверка равенства при помощи макросов `assert_eq!()` и `assert_ne!()`__

Тестировать функциональность можно также при помощи сверки результирующего кода. Можно сделать это при помощи `assert!()` и оператора `==`. Но, поскольку это является частой проверкой, существуют макросы `assert_eq!()` и `assert_ne!()`,

Проверка функции `add_two()`, рассмотренной ранее, при помощи макроса `assert_eq!()`.

`src/lib.rs`:

```rust
pub fn add_two(a: i32) -> i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2));
    }
}
```

```bash
cargo test
```

Дальше добавим ошибку в нашу функцию:

```rust
pub fn add_two(a: i32) -> i32 {
    a + 3
}
```

```bash
cargo test
```

Тест её выявил.

В некоторых языках и фреймворках тестирования, параметры для сверки равенства могут называться `expected` и `actual`, но в _Rust_ они называются `left` и `right` (в порядке указания внутри макроса).

Макрос `assert_ne!()` полезен, если мы не уверены, чем будет результат, но точно знаем, чем он быть не должен.

Когда сравнение не проходит, макрос выводит аргументы, используя отладочное форматирование, что значит, что значения, которые сравниваются, должны иметь трейты `PartialEq` и `Debug`. Все примитивные типы и большинство из стандартной библиотеки имеют данные трейты. Для пользовательских структур и перечислений, имплементация `PartialEq` и `Debug` должна быть создана. Поскольку данные типы производные (см. [[#5. Использование структур]]), это делается при помощи аннотации `#[derive(PartialEq, Debug)]` в определении структуры или перечисления.

__Добавление пользовательских сообщений об ошибках__

Можно добавить пользовательское сообщение для падения теста в качестве аргумента для `assert!()`, `assert_eq!()` и `assert_ne!()`. Все аргументы, перечисленные после необходимых для макроса, проходят в макрос `format!()`, так что можно передавать форматированные строки, содержащие плейсхолдеры `{}` и значения, предназначенные для данных плейсхолдеров.

`src/lib.rs`:

```rust
pub fn greeting(name: &str) -> String {
    format!("Hello {}!", name)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting("Carol");
        assert!(result.contains("Carol"));
    }
}
```

```rust
pub fn greeting(name: &str) -> String {
    String::from("Hello!")
}
```

```bash
cargo test
```

Ниже пример использования пользовательских сообщений:

```rust
#[test]
fn greeting_contains_name() {
    let result = greeting("Carol");
    assert!(
        result.contains("Carol"),
        "Greeting did not contain name, value was: {}",
        result
    );
}
```

```bash
cargo test
```

__Проверка аварийных состояний при помощи `should_panic`__

В дополнение к проверки возвращаемых значений, важно проверять, что наш код обрабатывает ошибки так, как мы ожидаем.

Мы можем написать тест, который удостоверяет нас в том, что попытка произвести какое-либо действия должна привести к аварийному завершению.

Атрибут `should_panic` в функции теста нужен для этой задачи. Тест проходит, если код внутри функции приводит к аварийному завершению.

`src/lib.rs`:

```rust
pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess value must be between 1 and 100, got {}.", value);
        }
        
        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}
```

Атрибут `#[should_panic]` помещается после атрибута `#[test]`.

```bash
cargo test
```

Попробуем внести ошибку в код:

```rust
// ...
impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 {
            panic!("Guess value must be between 1 and 100, got {}.", value);
        }
        
        Guess { value }
    }
}
```

```bash
cargo test
```

Тест выше не пройдёт, потому что там, где ожидается аварийное завершение, оно отсутствует.

Тест с `should_panic` может быть неточным и пройти, если аварийное завершение вызвано не той причиной, которую ожидаем. Для более точного теста можно добавить опциональный параметр `expected` для атрибута `should_panic`.

`src/lib.rs`:

```rust
// ...
impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 {
            panic!(
                "Guess value must be greater than or equal to 1, got {}.",
                value
            );
        } else if value > 100 {
            panic!(
                "Guess value must be less than or equal to 100, got {}.",
                value
            );
        }
        
        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = "less than or equal to 100")]
    fn greater_than_100() {
        Guess::new(200);
    }
}
```

Тест выше пройдёт, поскольку значения для атрибута `should_panic` внутри параметра `expected` - это подстрока сообщения, которое выдаётся при помощи `panic!()` внутри `Guess::new()`.

Код ниже не пройдёт тестирование.

```rust
// ...
if value < 1 {
    panic!(
        "Guess value must be less than or equal to 100, got {}.",
        value
    );
} else if value > 100 {
    panic!(
        "Guess value must be greater than or equal to 1, got {}.",
        value
    );
}
// ...
```

```bash
cargo test
```

__Использование `Result<T, E>` в тестах__

Здесь `it_works()` возвращает тип `Result<(), String>`. В теле функции, вместо вызова `assert_eq!()`, мы возвращаем `Ok(())`, когда тест проходит и `Err` со строкой `String` внутри, когда тест падает.

```rust
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -> Result<(), String> {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from("two plus two does not equal four"))
        }
    }
}
```

Написание тестов с возвращаемым типом `Result<T, E>` позволяет использовать оператор `?` в теле теста, что может быть подходящим для написания тестов, которые должны упасть, если любая операция внутри них возвращает вариант `Err`.

`#[should_panic]` не может быть использована с тестами, которые возвращают `Result<T, E>`. Для проверки операций, возвращающих `Err`, в таком случае, еспользуется `assert!(value.is_err())` вместо `?`.

### 11.2. Контроль выполнения тестов

`cargo test` компилирует код в тестовом режиме и запускает результирующий тестовый исполняемый файл. Поведение по-умолчанию для тестового исполняемого файла - параллельный запуск всех тестов и захват вывода, генерируемого запускаемыми тестами.

Какие-то опции идут в `cargo test`, а какие-то в исполняемый файл. Для их разделения используется `--`. До `--` идут аргументы для `cargo test`, после - для исполняемого файла. `cargo test --help` выводит помощь по тестированию, `cargo test -- --help` выводит помощь по исполняемому файлу с тестами.

__Параллельный и последовательный запуск тестов__

Поскольку тесты выполняются параллельно, нужно быть уверенным в том, что они не используют общих ресурсов и не зависят друг от друга.

Ниже пример последовательного запуска тестов в 1-м потоке:

```bash
cargo test -- --test-threads=1
```

__Показ вывода функций__

По-умолчанию, если тест проходит, библиотека тестирования _Rust_ захватывает всё, что печатается в стандартный вывод. Если тест "заваливается", мы видим то, что было напечатано в стандартный вывод при вызове функции тестирования.

```rust
fn prints_and_returns_10(a: i32) -> i32 {
    println!("I got the value {}", a);
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn this_test_will_pass() {
        let value = prints_and_returns_10(4);
        assert_eq!(10, value);
    }

    #[test]
    fn this_test_will_fail() {
        let value = prints_and_returns_10(8);
        assert_eq!(5, value);
    }
}
```

При вызове `cargo test` для кода выше, будет выведена, в том числе, и строка из функции `this_test_will_fail()`.

```bash
cargo test
```

Опция `--show-output` для тестового исполняемого файла позволяет вывести и те строки, что находятся в успешно завершённых тестовых функциях:

```bash
cargo test -- --show-output
```

__Запуск подгруппы тестов по имени__

Можно выбрать для запуска только определённые тестовые функции, передав их имена в качестве аргумента.

```rust
pub fn add_two(a: i32) -> i32 {
    a + 2
}

#[chg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        assert_eq!(4, add_two(2));
    }

    #[test]
    fn add_three_and_two() {
        assert_eq!(5, add_two(3));
    }

    #[test]
    fn one_hundred() {
        assert_eq!(102, add_two(100));
    }
}
```

```bash
cargo test
```

__Запуск единичных тестов__

Можно запустить только один тест:

```bash
cargo test one_hundred
```

__Фильтрация для запуска нескольких тестов__

Можно указать только часть имени теста, в таком случае будут запущены все тесты, содержащие данную часть:

```bash
cargo test add
```

Имя модуля (`tests::`), в для которого производится тестирование, тоже является частью имени функций тестирования.

__Игнорирование некоторых тестов, пока они не будут запрошены__

Можно добавить атрибут `ignore` для тех тестовых функций, которые должны выполняться по запросу, но не в общем потоке:

```rust
#[test]
fn it_works() {
    assert_eq!(2 + 2, 4);
}

#[test]
#[ignore]
fn expensive_test() {
// ...
}
```

```bash
cargo test
```

Для того, чтобы запустить только те тесты, у которых есть атрибут `ignored`, нужно запустить команду

```bash
cargo test -- --ignored
```

Для запуска всех тестов (включая игнорируемые), запускается команда

```bash
cargo test -- --include-ignored
```

### 11.3. Структурирование тестов

Юнит-тесты - небольшие тесты, проверяющие один изолированный модуль в единицу времени, могут проверять приватные интерфейсы. Интеграционные тесты полностью внешние по отношению к библиотеке и используют код так, как использовал бы его любой внешний код, используя только API и потенциально проверяя несколько модулей за тест.

__Юнит-тесты__

Юнит-тесты обычно помещают в каждый файл в директории `src` вместе с кодом, который они тестируют. Соглашение - создание модуля с именем `tests` в каждом файле, содержащем тестовые функции и аннотировать модуль при помощи `cfg(test)`.

__Модули тестирования и `#[cfg (test)]`__

Аннотация `#[cfg(test)]` в модулях теста говорит _Rust_ о том, что компилироваться и выполняться тесты будут только тогда, когда запустится `cargo test`, а не при запуске `cargo build`.

`src/lib.rs`:

```rust
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }
}
```

Код выше - автоматически сгенерированный тестовый модуль. Атрибут `cfg` говорит _Rust_ о том, что последующий объект должен быть включен только тогда, когда дана соответствующая опция конфигурации. В данном случае, опция конфигурации для включения кода - `test`. Используя атрибут `cfg`, _Cargo_ скомпилирует наш тестирующий код только если мы запустим тесты при помощи `cargo test`. Это включит также любые вспомогательные функции, которые могут быть в данном модуле вместе с функциями с атрибутом `#[test]`.

__Тестирование приватных функций__

Правила в _Rust_ позволяют тестировать приватные функции.

`src/lib.rs`:

```rust
pub fn add_two(a: i32) -> i32 {
    internal_adder(a, 2)
}

fn internal_adder(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        assert_eq!(4, internal_adder(2, 2));
    }
}
```

В примере выше, мы предоставляем все объекты родительского модуля при помощи `use super::*` и затем тестируем, вызывая `internal_adder()`, являющийся приватным.

__Интеграционные тесты__

Интеграционные тесты вызывают публичный __API__ тестируемой библиотеки. Для создания интеграционных тестов, нужно добавить директорию `tests`.

__Директория `tests`__

Директория `tests` располагается рядом с `src`.

```
adder
|
+-Cargo.lock
|
+-Cargo.toml
|
+-src
| |
| +-lib.rs
|
+-tests
  |
  +-integration_test.rs
```

`tests/integration_test.rs`:

```rust
use adder;

#[test]
fn it_adds_two() {
    assert_eq!(4, adder::add_two(2));
}
```

Каждый файл в директории `tests` является отдельным крэйтом, так что нужно добавлять библиотеку в область видимости каждого из них.

Аннотировать код при помощи `#[cfg(test)]` в интеграционных тестах не нужно.

```bash
cargo test
```

В выводе `cargo test` есть три секции: для юнит-тестов, интеграционных тестов и тестов документации. При падении теста в одной из секций, тестирование завершится.

Можно запустить отдельную функцию интеграционного теста, указав её имя в качестве аргумента. Для запуска всех тестов в отдельном файле интеграционного теста, используется аргумент `--test` с последующим указанием имени файла:

```bash
cargo test --test integration_test
```

__Сабмодули в интеграционных тестах__

Вспомогательные функции для нескольких тестов можно сгруппировать в отдельных файлах.

`tests/common.rs`:

```rust
pub fn setup() {
// ...
}
```

```bash
cargo test
```

Нужно создать файл `mod.rs` с общими функциями внутри директории `common`. Файлы в субдиректориях директории `tests` не будут скомпилированы, как отдельные крэйты или иметь секций в выводе при тестировании.

```
|
+-Cargo.lock
|
+-Cargo.toml
|
+-src
| |
| +-lib.rs
|
+-tests
  |
  +-common
  | |
  | +-mod.rs
  |
  +-integration_test.rs
```

После создания `tests/common/mod.rs`, можно использовать его в любом файле интеграционного тестирования, как модуль (`mod common`):

`tests/integration_test.rs`:

```rust
use adder;

mod common;

#[test]
fn it_adds_two() {
    common::setup();
    assert_eq!(4, adder::add_two(2));
}
```

__Интеграционные тесты для двоичных крэйтов__

Если наш проект является двоичным крэйтом и содержит только `src/main.rs` и не имеет `src/lib.rs`, мы не можем создать интеграционные тесты в директории `tests` и предоставить функции из `src/main.rs` в область видимости интеграционного теста, используя `use`. Только библиотечные крэйты могут предоставить функции, доступный для крэйтов.

## 12. I/O-проект: программа командной строки

### 12.1. Чтение аргументов командной строки

```rust
use std::env;

fn main() {
    let args: Vec<string> = env::args().collect();

    let query = &args[1];
    let file_path = &args[2];

    println!("Searching for {}", query);
    println!("In file {}", file_path);
}
```

### 12.2. Чтение из файла

```rust
use std::env;
use std::fs;

fn main() {
// ...
    println!("In file {}", file_path);

    let contents = fs::read_to_string(file_path)
        .expect("Should have been able to read the file");

    println("With text:\n{contents}");
}
```

### 12.3. Рефакторинг для модульности и обработки ошибок

__Экстракция парсера аргументов__

```rust
fn main() {
    let args: Vec<String> = env::args().collect();

    let (query, file_path) = parse_config(&args);
// ...
}

fn parse_config(args: &[String]) -> (&str, &str) {
    let query = &args[1];
    let file_path = &args[2];

    (query, file_path)
}
```

__Группировка значений конфигурации__

```rust
fn main() {
    let args: Vec<String> = env::args().collect();

    let config = parse_config(&args);

    println!("Searching for {}", config.query);
    println!("In file {}", config.file_path);

    let contents = fs::read_to_string(config.file_path)
        .expect("Should have been able to read the file");

// ...
}

struct Config {
    query: String,
    file_path: String,
}

fn parse_config(args: &[String]) -> Config {
    let query = args[1].clone();
    let file_path = args[2].clone();

    Config { query, file_path }
}
```

> [!warning]
> Следует избегать использования метода `.clone()`.

__Создание конструктора для `Config`__

```rust
fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::new(&args);

// ...
}

// ...

impl Config {
    fn new(args: &[String]) -> Config {
        let query = args[1].clone();
        let file_path = args[2].clone();
        
        Config { query, file_path }
    }
}
```

__Улучшение сообщения об ошибке__

```rust
// ...
fn new(args: &[String]) -> Config {
    if args.len() < 3 {
        panic!("not enough arguments");
    }
// ...
```

__Возвращаем `Result` вместо вызова `panic!()`__

```rust
impl Config {
    fn build(args: &[String]) -> Result<Config, &'static str> {
        if args.len() < 3 {
            return Err("not enough arguments");
        }
        
    let query = args[1].clone();
    let file_path = args[2].clone();
    
    Ok(Config { query, file_path })
    }
}
```

__Вызов `Config::build` и обработка ошибок__

```rust
use std::process;

fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::build(&args).unwrap_or_else(|err| {
        println!("Problem parsing arguments: {err}");
        process::exit(1);
    });
// ...
```

__Экстракиця логики из `main`__

```rust
fn main() {
// ...
    println!("Searching for {}", config.query);
    println!("In file {}", config.file_path);

    run(config);
}

fn run(config: Config) {
    let contents = fs::read_to_string(config.file_path)
        .expect("Should have been able to read the file");

    println!("With text:\n{contents}");
}
// ...
```

__Возврат ошибок из `run()`__

```rust
use std::error::Error;

// ...

fn run(config: Config) -> Result<(), Box<dyn Error>> {
    let contents = fs::read_to_string(config.file_path)?;

    println!("With text:\n{contents}");

    Ok(())
}
```

__Обработка ошибок из `run()` в `main()`__

```rust
fn main() {
// ...
    println!("Searching for {}", config.query);
    println!("In file {}", config.file_path);

    if let Err(e) = run(config) {
        println!("Application error: {e}");
        process::exit(1);
    }
}
```

__Разбиение кода в библиотечный крэйт__

`src/lib.rs`:

```rust
use std::error::Error;
use std::fs;

pub struct Config {
    pub query: String,
    pub file_path: String,
}

impl Config {
    pub fn build(args: &[String]) -> Result<Config, &'static str> {
// ...
    }
}

pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
// ...
}
```

`src/main.rs`:

```rust
use std::env;
use std::process;

use minigrep::Config;

fn main() {
// ...
    if let Err(e) = minigrep::run(config) {
// ...
    }
}
```

### 12.4. Разработка функциональной части библиотеки с использованием тестирования

__Написание падающего теста__

`src/lib.rs`:

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_result() {
        let query = "duct";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.";

        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
    }
}
```

`src/lib.rs`:

```rust
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    vec![]
}
```

__Написание кода для прохождения теста__

__Итерация по строкам методом `.lines()`__

`src/lib.rs`:

```rust
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    for line in contents.lines() {
// ...
    }
}
```

__Поиск по строкам для запроса__

`src/lib.rs`:

```rust
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    for line in contents.lines() {
        if line.contains(query) {
// ...
        }
    }
}
```

__Сортировка нужных строк__

`src/lib.rs`:

```rust
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
```

__Использование функции `search()` в `run()`__

`src/lib.rs`:

```rust
pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
    let contents = fs::read_to_string(config.file_path)?;

    for line in search(&config.query, &contents) {
        println!("{line}");
    }

    Ok(())
}
```

### 12.5. Работа с переменными окружения

__Написание падающего теста для регистронезависимогой функции `search()`__

`src/lib.rs`:

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn case_sensitive() {
        let query = "duct";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.
Duct tape.";
        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
    }

    #[test]
    fn case_insensitive() {
        let query = "rUsT";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.
Trust me.";

        assert_eq!(
            vec!["Rust:", "Trust me."],
            search_case_insensitive(query, contents)
        );
    }
}
```

__Реализация `search_case_insensitive()`__

`src/lib.rs`:

```rust
pub fn search_case_insensitive<'a>(
    query: &str,
    contents: &'a str,
) -> Vec<&'a str> {
    let query = query.to_lowercase();
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.to_lowercase().contains(&query) {
            results.push(line);
        }
    }

    results
}
```

```bash
cargo test
```

`src/lib.rs`:

```rust
pub struct Config {
    pub query: String;
    pub file_path: String;
    pub ignore_case: bool,
}
```

`src/lib.rs`:

```rust
pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
    let contents = if config.ignore_case {
        search_case_insensitive(&config.query, &contents)
    } else {
        search(&config.query, &contents)
    };

    for line in results {
        println!("{line}");
    }

    Ok(())
}
```

`src/lib.rs`:

```rust
use std::env;
// ...
impl Config {
    pub fn build(args: &[String]) -> Result<Config, &'static str> {
        if args.len() < 3 {
            return Err("not enough arguments");
        }
        
        let query = args[1].clone();
        let file_path = args[2].clone();
        
        let ignore_case = env::var("IGNORE_CASE").is_ok();
        
        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
```

```bash
IGNORE_CASE=1 cargo run -- to poem.txt
```

### 12.6. Запись сообщений об ошибках в `stderr` вместо `stdout`

__Вывод ошибок в `stderr`__

`src/main.rs`:

```rust
fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::build(&args).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    if let Err(e) = minigrep::run(config) {
        eprintln!("Application error: {e}");
        process::exit(1);
    }
}
```

## 13. Особенности парадигмы функционального программирования: итераторы и замыкания

На _Rust_ влияние оказали также и функциональные __ЯП__. Функциональное программирование часто включает в себя использование функций в качестве значений и передача их в качестве аргументов, их возврата из других функций, присвоение их переменным для последующего запуска и т.д.

Далее речь будет о:

 + _замыканиях_ - функциоподобный конструкт, который можно хранить в переменных;
 + _итераторах_ - способ обработки последовательностей элементов;
 + том, как, используя итераторы и замыкания, улучшить проект из [[#12. I/O-проект программа командной строки]];
 + производительности замыканий и итераторов.

### 13.1. Замыкания: анонимные функции, которые захватывают свои окружения

Замыкания в _Rust_ являются анонимными функциями, которые могут быть сохранены в переменной или переданы в качестве аргумента другим функциям. Можно создать замыкание в одном месте и затем вызвать его в другом для раскрытия в другом контексте. В отличие от функций, замыкания могут захватывать значения из области видимости, в которой они определены. Замыкания позволяют переиспользовать код и управлять поведением.

__Захват окружения замыканиями__

Для начала изучим возможность замыканий захватывать значения из окружения, в котором они определены, для дальнейшего использования. Сценарий: время от времени, наша компания по производству футболок, раздаёт эксклюзивную кому-нибудь из листа рассылки. Люди из списка могут опционально добавить любимый цвет в профиль. Если у человека, выбранного для подарка, есть любимый цвет, то ему дают футболку такого цвета. Если любимый цвет не указан, выдаётся футболка любого цвета, главное - чтобы футболок данного цвета у компании было больше всего.

`src/main.rs`:

```rust
#[derive(Debug, PartialEq, Copy, Clone)]
enum ShirtColor {
    Red,
    Blue,
}

struct Inventory {
    shirts: Vec<ShirtColor>,
}

impl Inventory {
    fn giveaway(&self, user_preference: Option<ShirtColor>) -> ShirtColor {
    user_preference.unwrap_or_else(|| self.most_stocked())
    }

    fn most_stocked(&self) -> ShirtColor {
        let mut num_red = 0;
        let mut num_blue = 0;
        
        for color in &self.shirts {
            match color {
                ShirtColor::Red => num_red += 1,
                ShirtColor::Blue => num_blue += 1,
            }
        }
        if num_red > num_blue {
            ShirtColor::Red
        } else {
            ShirtColor::Blue
        }
    }
}

fn main() {
    let store = Inventory {
        shirts: vec![ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],
    };

    let user_pref1 = Some(ShirtColor::Red);
    let giveaway1 = store.giveaway(user_pref1);
    println!(
        "The user with preference {:?} gets {:?}",
        user_pref1, giveaway1
    );

    let user_pref2 = None;
    let giveaway2 = store.giveaway(user_pref2);
    println!(
        "The user with preference {:?} gets {:?}",
        user_pref2, giveaway2
    );
}
```

`store`  в `main()` имеет две синие футболки и одну красную для раздачи. `.giveaway()` вызывается для пользователя с предпочтительным красным цветом и для пользователя без предпочтений.

В `.giveaway()` мы получили параметр предпочтения типа `Option<ShirtColor>` и вызвали метод `.unwrap_or_else()` на `user_preference`. `.unwrap_or_else()` для `Option<T>` определён в стандартной библиотеке. Он принимает один аргумент: замыкание без аргументов, возвращающее значение `T` (тот же тип, что хранится в варианте `Some` для `Option<T>`, в данном случае - `ShirtColor`). Если `Option<T>` - вариант `Some`, `.unwrap_or_else()` возвращает значение из `Some`. Если `Option<T>` - вариант `None`, `.unwrap_or_else()` вызывает замыкание и возвращает значение, возвращаемое замыканием.

Мы обозначаем выражение замыкания `|| self.most_stocked()` как аргумент для `.unwrap_or_else()`. Данное замыкание не принимает параметров. Тело замыкания вызывает `self.most_stocked()`. Мы определяем замыкание здесь, а реализация `.unwrap_or_else()` вызывает замыкание далее, если нужен результат.

Замыкание захватывает иммутабельную ссылку на `self` экземпляра `Inventory` и передаёт её с кодом, который мы указали для метода `.unwrap_or_else()`, Функции не могут захватить своё окружение таким образом.

__Аннотация замыканий__

Для замыканий обычно не указывается тип параметров или возвращаемых значений, как для функций (`fn`). Замыкания не используются с "открытым" интерфейсом, как у функций: они хранятся в переменных, не имеют имени и не доступны для вызова пользователями из библиотек.

Замыкания обычно короткие и релевантны только внутри узкого контекста, а не в каком-то общем случае.  Компилятор может сделать вывод о том, какие типы параметров у замыкания и каким является возвращаемый тип (редким случаем является то, что для замыкания нужно указать типы аргументов и возвращаемых значений).

Как с переменными, можно указать типы, если нам нужно повысить ясность кода взамен указания большего количества подробностей. Пример аннотации типов для замыкания ниже:

`src/main.rs`:

```rust
let expensive_closure = |num: u32| -> u32 {
    println!("calculating slowly...");
    thread::sleep(Duration::from_secs(2));
    num
};
```

В примере ниже мы определяем функцию,  которая добавляет 1 к параметру и замыкания с идентичным поведением, для сравнения.

```rust
fn add_one_v1 (x: u32) -> u32 { x + 1 }
let add_one_v2 = |x: u32| -> u32 { x + 1 };
let add_one_v3 = |x| { x + 1 };
let add_one_v4 = |x| x + 1 ;
```

В первой строке определение функции. Во второй строке полное определение замыкания. В третьей строке мы убрали аннотации типов из определения замыкания. В четвёртой строке мы убрали фигурные скобки, поскольку тело замыкания имеет в себе лишь одно выражение. `add_one_v3` и `add_one_v4` должны быть вызваны в коде для успешной компиляции, поскольку типы будут определены только на основании использования замыкания.

Для определения замыканий, компилятор попытается определить конкретный тип для каждого параметра и возвращаемого значения. В примере ниже, при второй попытке вызова замыкания `example_closure`, мы получим ошибку, поскольку в первый раз мы передаём в `example_closure` `String`, после чего компилятор считает, что тип аргумента и возврата для замыкания тоже является `String`.

`src/main.rs`:

```rust
let example_closure = |x| x;

let s = example_closure(String::from("hello"));
let n = example_closure(5);
```

__Захват ссылок и передача владения__

Замыкания могут захватывать значения из их окружения трёмя путями, которые напрямую отображаются на те три пути, какими функция принимает параметры: иммутабельное заимствование, мутабельное заимствование и передача владения. Замыкание решит, какой из трёх способов использовать в зависимости от того, что делает тело функции с захваченными значениями.

В примере ниже определяется и вызывается замыкание, захватывающее иммутабельную ссылку на вектор `list`.

`src/main.rs`:

```rust
fn main() {
    let list = vec![1, 2, 3];
    println!("Before defining closure: {:?}", list);

    let only_borrows = || println!("From closure: {:?}", list);

    println!("Before calling closure: {:?}", list);
    only_borrows();
    println!("After calling closure: {:?}", list);
}
```

Пример выше также демонстрирует, что переменная может быть привязана к определению замыкания. И, далее, мы можем вызвать замыкание, используя имя переменной и скобки так, будто бы это функция.

Поскольку мы можем иметь несколько иммутабельных ссылок на `list` в одно и то же время, `list` всё-ещё доступен из кода до определения замыкания, после определения замыкания, до вызова замыкания и после вызова замыкания.

Далее, мы изменим тело замыкания так, что оно добавит элемент в вектор `list`. Теперь замыкание будет захватывать мутабельную ссылку.

`src/main.rs`:

```rust
fn main() {
    let mut list = vec![1, 2, 3];
    println!("Before defining closure: {:?}", list);

    let mut borrows_mutably = || list.push(7);

    borrows_mutably();
    println!("After calling closure: {:?}", list)
}
```

В примере выше нет вызова `println!()` между определением и вызовом замыкания `borrows_mutably`: когда `borrorws_mutably` определяется, оно захватывает мутабельную ссылку на `list`. Мы не используем замыкание снова после того, как оно было вызвано, так что мутабельное заимствование заканчивается. Иммутабельное заимствование для вывода между определением замыкания и вызовом замыкания невозможен, поскольку никакие другие заимствования непозволительны, когда есть мутабельное заимствование.

Если нужно заставить замыкание взять владение над значениями из окружения, в котором оно определено, даже если тело замыкания не запрашивает его, можно использовать ключевое слово `move` до списка параметров.

Данный способ обычно полезен при передачи замыкания новому потоку для перемещения данных так, чтобы ими владел новый поток.

`src/main.rs`:

```rust
use std::thread;

fn main() {
    let list = vec![1, 2, 3];
    println!("Before defining closure: {:?}", list);

    thread::spawn(move || println!("From thread: {:?}", list))
        .join()
        .unwrap();
}
```

Мы создали новый поток и передали ему замыкание в качестве аргумента. Тело замыкания печатает содержимое `list`. Несмотря на то, что телу замыкания достаточно иммутабельного `list`, нам нужно указать, что `list` должен быть перемещён внутрь замыкания, написав `move` в начале определения замыкания. Новый поток может быть завершён до конца основного, или наоборот. Если основной поток завершается раньше, иммутабельная ссылка на `list` в новом потоке станет невалидной. По этой причине, компилятор требует, чтобы `list` был перемещён в замыкание, переданное новому потоку так, чтобы ссылка оставалась валидной.

__Перемещение захваченных значений из замыканий и трейты `Fn`__

Как только замыкание захватывает ссылку или овладевает значением из окружения, где определено замыкание, код в теле замыкания определяет то, что происходит со ссылками или значениями только тогда, когда замыкание вызывается. Тело замыкания может: перемещать захваченное значение из замыкания, изменять захваченное значение, не перемещать и не изменять значение или с самого начала ничего не захватывать из окружения.

Способ захвата и обработки значений их окружения влияет на то, какие трейты замыкание реализует, а трейты - на то, как функции и структуры могут определить, какой тип замыканий они могут использовать. Замыкания автоматически реализуют один, два или все три трейта `Fn`, добавляя их по-очереди, в зависимости от того, как тело замыкания обрабатывает значения.

 1. `FnOnce` применяется к замыканиям, которые могут быть вызваны единожды. Все замыкания имеют хотя бы этот трейт, поскольку все замыкания могут быть вызваны. Замыкания, перемещающие захваченные значения из своего тела имеют только `FnOnce`.
 2. `FnMut` применяется к замыканиям, не перемещающим захваченные значения из своего тела, но которые могут изменять захваченные значения. Данные замыкания могут быть вызваны более одного раза.
 3. `Fn` применяется к замыканиям, которые не перемещают захваченные значения из своего тела и не изменяют захваченных значений, как и к замыканиям, которые не захватывают ничего из окружения в принципе. Данные замыкания могут быть вызваны более одного раза без изменения их окружения, что важно в случаях вызова замыканий несколько раз параллельно.

```rust
impl<T> Option<T> {
    pub fn unwrap_or_else<F>(self, f: F) -> T
    where
        F: FnOnce() -> T
    {
        match self {
            Some(x) => x,
            None => f(),
        }
    }
}
```

В примере выше `T` - обобщённый тип, репрезентующий значение в варианте `Some` для `Option`. Данный тип `T` также является возвращаемым значением `unwrap_or_else()`: код, вызывающий `unwrap_or_else()` для `Option<String>`, к примеру, получит `String`.

Далее, `unwrap_or_else()` имеет дополнительный параметр обобщённого типа `F`. `F` - тип параметра `f`, который является замыканием, которое мы предоставляем функции `unwrap_or_else()`.

Трейтом, привязанным к типу `F` является `FnOnce() -> T`, что значит, что `F` должна быть вызвана единожды, не принимать никаких аргументов и вернуть `T`. Т.е. `unwrap_or_else()` вызывает `f` один раз.

> [!note]
> Функции могут реализовать все три трейта `Fn`. Если нам не нужно захватывать значения из окружения, мы можем использовать имя функции вместо замыкания, когда нужно что-то, что реализует один из трейтов `Fn`. К примеру, для значения типа `Option<Vec<T>>`, мы вызовем `unwrap_or_else(Vec::new)`, чтобы получить новый, пустой вектор, если значение None.

Теперь рассмотрим стандартный метод `.sort_by_key()` для слайсов, чтобы узнать, как он отличается от `unwrap_or_else()` и почему `.sort_by_key()` использует `FnMut` вместо `FnOnce`. Замыкание получает один аргумент в виде ссылки на текущий объект в слайсе и возвращает значение типа `K`, которое может быть упорядочено. Данная функция полезна, когда нужно отсортировать слайс по конкретному атрибуту каждого объекта. Ниже у нас есть список экземпляров `Rectangle` и мы используем `.sort_by_key()`, чтобы рассортировать их по атрибуту `high` от наименьшего к наибольшему.

`src/main.rs`:

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() [
    let mut list = {
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    list.sort_by_key(|r| r.width);
    println("{:#?}", list);
}
```

`src/main.rs`:

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut sort_operations = vec![];
    let value = String::from("by key called");

    list.sort_by_key(|r| {
        sort_operations.push(value);
        r.width
    });
    println!("{:#?}", list);
}
```

`.sort_by_key()` принимает замыкания `FnMut` потому, что вызывает их несколько раз: каждый раз для каждого объекта из слайса. Замыкание `|r| r.width` не захватывает, не изменяет и не перемещает ничего из окружения.

Ниже код с ошибкой. Замыкание в примере реализует только трейт `FnOnce`, поскольку перемещает значение из окружения.

`src/main.rs`:

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut sort_operations = vec![];
    let value = String::from("by key called");

    list.sort_by_key(|r| {
        sort_operations.push(value);
        r.width
    });
    println!("{:#?}", list);
}
```

Код выше пытается положить строку из окружения замыкания в вектор `sort_operations`. Замыкание захватывает `value` и перемещает его из замыкания, передавая владение `value` вектору `sort_operations`. Данное замыкание может быть вызвано единожды; второй вызов не сработает, поскольку `value` больше не будет находиться в окружении, чтобы иметь возможность быть помещённой в `sort_operations` снова. Таким образом, данное замыкание реализует только `FnOnce`.

Для исправления данной ошибки, нужно изменить тело замыкания так, чтобы значения из окружения не перемещались. Для счётчика вызовов `.sort_by_key()`, можно использовать переменную, которая будет постоянно находиться в окружении. В примере ниже замыкание, передаваемое в `.sort_by_key()`, захватывает только мутабельную ссылку на счётчик `num_sort_operations` и потому может быть вызвано более одного раза.

`src/main.rs`:

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut num_sort_operations = 0;
    list.sort_by_key(|r| {
        num_sort_operations += 1;
        r.width
    });
    println!("{:#?}, sorted in {num_sort_operations} operations", list);
}
```

### 13.2. Обработка последовательности объектов итераторами

Паттерн итераторов позволяет выполнять задачу на последовательности объектов. Итератор ответственен за логику перебора каждого элемента и определения того, когда последовательность закончена.

Итераторы в _Rust_ "ленивые". Они не будут иметь никакого эффекта, пока не будет вызван метод, поглощающий итератор для его использования.

Код ниже создаёт итератор для элементов вектора `v1`, вызывая метод `.iter()`, определённый для `Vec<T>`. Сам по себе данный код ничего не делает.

```rust
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();
```

Итератор помещён в переменную `v1_iter`.

```rust
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();

for val in v1_iter {
    println!("Got: {}", val);
}
```

Итераторы позволяют использовать одну логику для разных видов последовательностей.

__Трейт `Iterator` и метод `.next()`__

Все итераторы реализуют трейт `Iterator`, определённый в стандартной библиотеке. Определение трейта:

```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;
// ...
}
```

`type Item` и `Self::Item` определяют _ассоциированный тип_ для трейта. `Item` является типом, возвращаемым из итератора (возвращается при вызове метода `.next()`).

`Iterator` требует от тех, кто его реализует, определить только один метод: `.next()`, который возвращает один элемент итератора, обёрнутый в `Some` и, когда итератор заканчивается, возвращает `None`.

Метод `.next()` может быть вызван из итератора напрямую:

`src/lib.rs`:

```rust
#[test]
fn iterator_demonstration() {
    let v1 = vec![1, 2, 3];

    let mut v1_iter = v1.iter()

    assert_eq!(v1_iter.next(), Some(&1));
    assert_eq!(v1_iter.next(), Some(&2));
    assert_eq!(v1_iter.next(), Some(&3));
    assert_eq!(v1_iter.next(), None);
}
```

`v1_iter` пришлось сделать мутабельным: вызов `.next()` на итераторе изменяет внутреннее состояние, которое определяет место в последовательности, на котором он сейчас находится. Цикл `for` в примере до этого завладел итератором и сделал его мутабельным.

Значения, получаемые от вызова `.next()` - иммутабельные ссылки на значения в векторе. Метод `.iter()` производит итератор по иммутабельным ссылкам. Если мы хотим создать итератор, который овладевает `v1` и возвращает значения, которыми владеет, можно вызвать метод `.into_iter()`, И, если мы хотим перемещаться по мутабельным ссылкам, мы можем вызвать `.iter_mut()`.

__Методы, поглощающие итераторы__

Трейт `Iterator` имеет несколько различных методов со стандартными реализациями в стандартной библиотеке (см. документацию __API__ стандартной библиотеки, посвящённую трейту `Iterator`). Некоторые из тех методов вызывают `.next()`.

Методы, которые вызывают `.next()`, называются _поглощающими адапторами_, поскольку их вызов проходится по итератору. Например, `.sum()`, который овладевает итератором и проходится по элементам, постоянно вызывая `.next()`, поглощая итератор. Во время прохода, он добавляет элемент к общему количеству и возвращает его, когда итератор становится полностью поглощённым.

`src/lib.rs`:

```rust
#[test]
fn iterator_sum() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    let total: i32 = v1_iter.sum();

    assert_eq!(total, 6);
}
```

Мы не можем использовать `v1_iter` после вызова `.sum()`, поскольку `.sum()` овладевает итератором, для которого его вызываем.

__Методы, продуцирующие итераторы__

_Адапторы итераторов_ - методы, определённые для трейта `Iterator`, которые не поглощают его, но создают разные итераторы, изменяя аспекты оригинального.

Пример ниже - адаптор `.map()`, который принимает замыкание и вызывает его для каждого элемента, по которому итератор проходится. `.map()` в результате возвращает новый итератор, в котором находятся модифицированные элементы.

`src/main.rs`:

```rust
let v1: Vec<i32> = vec![1, 2, 3];

v1.iter().map(|x| x + 1);
```

Код выше выдаст предупреждение.

Придётся использовать метод `.collect()`, чтобы поглотить итератор и собрать результирующие значения в отдельном месте (в новом векторе `v2`):

`src/main.rs`:

```rust
let v1: Vec<i32> = vec![1, 2, 3];

let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();

assert_eq!(v2, vec![2, 3, 4]);
```

Поскольку `.map()` принимает замыкания, мы можем указать любую операцию, какую мы хотим применить для каждого элемента.

Не стоит забывать, что, поскольку итераторы "ленивы", нужно вызвать один из поглощающих адапторов, чтобы достать результаты из адапторов итераторов.

__Использование замыканий, захватывающих окружение__

Многие адапторы итераторов принимают замыкания в качестве аргументов и обычно замыкания определяются как те, что захватывают окружение.

В примере ниже метод `.filter()` принимает замыкание. Замыкание получает элемент из итератора и возвращает `bool`. Если замыкание возвращает `true`, значение будет включено в итерацию, продуцируемую `.filter()`. Если замыкание возвращает `false`, значение не будет включено. `.filter()` с замыканием захватывает переменную `shoe_size` из окружения чтобы пройтись по набору экземпляров структуры `Shoe`. Вернёт он только `Shoes` с нужным нам `size`.

`src/lib.rs`:

```rust
#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn filters_by_size() {
        let shoes = vec![
            Shoe {
                size: 10,
                style: String::from("sneaker"),
            },
            Shoe {
                size: 13,
                style: String::from("sandal"),
            },
            Shoe {
                size: 10,
                style: String::from("boot"),
            },
        ];
        
        let in_my_size = shoes_in_size(shoes, 10);
        
        assert_eq!(
            in_my_size,
            vec![
                Shoe {
                    size: 10,
                    style: String::from("sneaker")
                },
                Shoe {
                    size: 10,
                    style: String::from("boot")
                },
            ]
        );
    }
}
```

`shoes_in_size()` овладевает вектором структур `Shoe` и значением `shoe_size` в качестве параметров. Возвращает она только вектор, содержащий `Shoe` с нужным нам `size`.

В теле `shoes_in_size()` мы вызываем `.into_iter()` для создания итератора, который овладевает вектором. Далее мы вызываем `.filter()` чтобы адаптировать этот итератор в новый итератор, который содержит элементы, для которых замыкание возвращает `true`.

Замыкание захватывает параметр `shoe_size` из окружения и сравнивает со значением `size` в каждом `Shoe`, сохраняя только нужные. Вызов `.collect()` поглощает значения от адаптора итераторов и помещает их в вектор, который далее возвращает функция.

### 13.3. Улучшение I/O-проекта

__Убираем `clone` при помощи итератора__

`src/lib.rs`:

```rust
impl Config {
    pub fn build(args: &[String]) -> Result<Config, &'static str> {
        if args.len() < 3 {
            return Err("not enough arguments");
        }
        
        let query = args[1].clone();
        let file_path = args[2].clone();
        
        let ignore_case = env::var("IGNORE_CASE").is_ok();
        
        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
```

__Использование вернувшегося итератора напрямую__

`src/main.rs`:

```rust
fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::build(&args).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {err}");
        process::exit(1);
    });
// ...
}
```

`src/main.rs`:

```rust
fn main() {
    let config = Config::build(env::args()),unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {err}");
        process::exit(1);
    });
// ...
}
```

`src/lib.rs`:

```rust
impl Config {
    pub fn build(
        mut args: impl Iterator<Item = String>,
    ) -> Result<Config, &'static str> {
// ...
    }
}
```

__Использование методов трейта `Iterator` вместо индексации__

`src/lib.rs`:

```rust
impl Config {
    pub fn build(
        mut args: impl Iterator<Item = String>,
    ) -> Result<Config, &'static str> {
        args.next();
        
        let query = match args.next() {
            Some(arg) => arg,
            None => return Err("Didn't get a query string"),
        };
        
        let file_path = match args.next() {
            Some(arg) => arg,
            None => return Err("Didn't get a file path"),
        };
        
        let ignore_case = env::var("IGNORE_CASE").is_ok();
        
        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
```

__Создание более чистого кода с адапторами итераторов__

`src/lib.rs`:

```rust
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
```

`src/lib.rs`:

```rust
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    contents
        .lines()
        .filter(|line| line.contains(query))
        .collect()
}
```

### 13.4. Сравнение производительности: циклы против итераторов

```rust
let buffer: &mut [i32];
let coefficients: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coefficients.iter()
        .zip(&buffer[i - 12..i])
        .map(|(&c, &s)| c * s as i64)
        .sum::<i64>() >> qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}
```

## 14. Больше о _Cargo_ и _Crates.io_

_Cargo_ также может:

 + Настроить сборку при помощи профилей релизов
 + Публиковать библиотеки в _Crates.io_
 + Организовывать большие проекты при помощи рабочих пространств
 + Устанавливать двоичные файлы из _Crates.io_
 + Расширять _Cargo_ пользовательскими командами

### 14.1. Кастомизация сборок при помощи профилей релизов

Профили релизов - это предопределённые и настраиваемые профили с разными конфигурациями, которые позволяют иметь больше контроля над опциями компиляции кода.

Основные профили _Cargo_: `dev` используется при запуске `cargo build`; `release` используется при запуске `cargo build --release`.

_Cargo_ имеет значения по-умолчанию для каждого профиля, которые применяются если не было добавлено никаких секций `[profile.*]` в файл `Cargo.toml` проекта.

`Cargo.toml`:

```toml
[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
```

`opt-level` управляет количеством оптимизаций, которые _Rust_ применит к коду (уровень имеет значения от `0` до `3`).

### 14.2. Публикация "крэйта" в _Crates.io_

__Создание полезных комментариев для документации__

Комментарии документации используют нотацию `///` и поддерживают разметку _Markdown_. Генерируемая в _HTML_ документация описывает публичный __API__ и способ использования крэйта. Размещаются комментарии документации прямо до элемента, которого они описывают.

`src/lib.rs`:

```rust
/// Adds one to the number given.
///
/// # Examples
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -> i32 {
    x + 1
}
```

В примере выше мы даём описание тому, что делает функция `add_one()`, начиная с заголовка `Examples`, а затем пишем код, демонстрирующий использование функции.

Команда ниже сгенерирует документацию в _HTML_ и поместит её в `target/doc`:

```bash
cargo doc
```

Команда ниже соберёт текущую документацию и откроет её в браузере:

```shell
cargo doc --open
```

__Часто используемые секции__

 + __Examples__: как в примере выше.
 + __Panics__: сценарии в них таковы, что документируемая функция аварийная. Вызывающие функцию должны быть уверены, что не попадут в данную ситуацию.
 + __Errors__: если функция возвращает `Result`, описываются типы ошибок, которые могут возникнуть и при каких условиях ошибка может быть возвращена. Это полезно для обработки ошибок.
 + __Safety__: если функция небезопасна (`unsafe`), должна быть секция, объясняющая данное решение.

__Комментарии в качестве тестов__

Добавление примеров с кодом в документацию может помочь продемонстрировать работу библиотеки. `cargo test` запустит примеры кода из документации в качестве тестов.

__Комментирование внутренних элементов__

`//!` добавляет документацию внутрь элементов, содержащих другие элементы. Данные комментарии обычно используются внутри коренного крэйта  (`src/lib.rs`) или внутри модуля для описания его в целом.

`src/lib.rs`:

```rust
//! # My Crate
//!
//! `my_crate` is a collection of utilities to make performing certain
//! calculations more convenient.

/// Adds one to the number given.
// ...
```

Кода после `//!` нет, как можно заметить.

__Экспорт подходящего публичного API при помощи `pub use`__

Можно реэкспортировать элементы, чтобы создать публичную структуру, отличающуюся от приватной, используя `pub use`. Реэкспорт берёт публичный элемент из одной локации и делает его публичным в другой локации так, будто бы он был определён в ней.

`src/lib.rs`:

```rust
//! # Art
//!
//! A library for modelling artistic concepts.

pub mod kinds {
/// The primary colors according to the RYB color model.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

/// The secondary colors according to the RYB color model.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use crate::kinds::*;

/// Combines two primary colors in equal amounts to create
/// a secondary color.
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -> SecondaryColor {
// ...
    }
}
```

`src/main.rs`:

```rust
use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}
```

Для примера выше, который использует крэйт `art`, нужно знать, что `PrimaryColor` находится в модуле `kinds`, а `mix()` в `utils`. Структура крэйта `art` более релевантна для его разработчиков, а не для тех, кто его использует.

`pub use` реэкспортирует нужные нам элементы на верхний уровень:

`src/lib.rs`:

```rust
//! # Art
//!
//! A library for modeling artistic concepts.

pub use self::kinds::PrimaryColor;
pub use self::kinds::SecondaryColor;
pub use self::utils::mix;

pub mod kinds {
// ..
}

pub mod utils {
// ...
}
```

`src/main.rs`:

```rust
use art::mix;
use art::PrimaryColor;

fn main() {
// ...
}
```

В случаях множества вложенных модулей, реэкспорт типов в верхний уровень с помощью `pub use` будет весьма удобным решением. Ещё один способ использования `pub use` - реэкспорт определений из крэйтов, которые являются зависимостями текущего крэйта так, что определения крэйта станут частью публичного __API__ текущего крэйта.

__Настройка аккаунта _Crates.io___

До публикации нужно создать аккаунт на [_Crates.io_](https://crates.io) и получить токен __API__.

```bash
cargo login <token>
```

Данная команда положит токен в `~/.cargo/credentials`.

__Дополнение метаданных для нового крэйта__

До публикации крэйту нужно дать уникальное имя:

`Cargo.toml`:

```toml
[package]
name = "guessing_game"
```

Для публикации также обязательно нужно указать описание и тип лицензии.

`Cargo.toml`:

```toml
[package]
name = "guessing_game"
license = "MIT"
```

Можно указать отдельно файл лицензии, используя поле `license-file`, если нужной лицензии нет в [__SPDX__](http://spdx.org/licenses).

`Cargo.toml`:

```toml
[package]
name = "guessing_game"
version = "0.1.0"
edition = "2021"
descriprion = "A fun game where you guess what number the computer has chosen."
license = "MIT OR Apache-2.0"

[dependencies]
```

[Документация Cargo](https://doc.rust-lang.org/cargo) описывает и другие метаданные, которые можно использовать для проекта.

__Публикация в _Crates.io___

Публикация перманентна. Версия не может быть переписана и код не может быть удалён. Но нет ограничений для версий крэйтов, которые можно публиковать.

```bash
cargo publish
```

__Публикация новой версии существующего крэйта__

Посли внесения изменений, достаточно изменить поле `version` в `Cargo.toml` крэйта и выполнить `cargo publish` ([рекомендации по версионированию](http://semver.org)).

__Устаревание версий в _Crates.io_ и `cargo yank`__

Можно предотвратить использование в качестве зависимости опубликованного кода будущими проектами. При этом, существующие проекты, которые зависят от этого крэйта, всё-ещё смогут им пользоваться.

"Выдернуть" код определённой версии из опубликованного крэйта можно, запустив `cargo yank` и указав нужную версию.

```bash
cargo yank --vers 1.0.1
```

Добавив опцию `--undo`, можно отменить данное действие.

```bash
cargo yank --vers 1.0.1 --undo
```

### 14.3. Рабочие пространства _Cargo_

_Cargo_ предлагает возможность управлять несколькими связанными пакетами, которые разрабатываются "в тандеме".

__Создание рабочего пространства__

_Рабочее пространство_ - это набор пакетов, имеющих общие _Cargo.lock_ и директорию вывода. В примере ниже будет создано рабочее пространство для двоичного файла и двух библиотек.

```bash
mkdir add
cd add
```

Ниже создаётся файл `Cargo.toml`, который будет конфигурировать всё рабочее пространство (к примеру, нет секции `[package]` - вместо неё `[workspace]`).

`Cargo.toml`:

```toml
[workspace]

members = [
    "adder",
]
```

```bash
cargo new adder
```

Рабочее пространство может быть собрано целиком при помощи `cargo build`.

```
add
|
+-Cargo.lock
|
+-Cargo.toml
|
+-adder
| |
| +-Cargo.toml
| |
| +-src
|   |
|   +-main.rs
|
+-target
```

Пакет `adder` не имеет собственной директории `target`. Скомпилированные артефакты (даже если мы запустим `cargo build` в `adder`) будут помещены в `add/target`.

__Создание ещё одного пакета в рабочем пространстве__

Сначала добавим элемент в поле `members` `.toml`-файла рабочего пространства.

`Cargo.toml`:

```toml
[workspace]

members = [
    "adder",
    "add_one",
]
```

Затем сгенерируем новую библиотеку:

```bash
cargo new add_one --lib
```

```
|
+-Cargo.lock
|
+-Cargo.toml
|
+-add_one
| |
| +-Cargo.toml
| |
| +-src
|   |
|   +-lib.rs
|
+-adder
| |
| +-Cargo.toml
| |
| +-src
|   |
|   +-main.rs
|
+-target
```

`add_one/src/lib.rs`:

```rust
pub fn add_one(x: i32) -> i32 {
    x + 1
}
```

Далее добавим в зависимости двоичного крэйта созданную библиотеку:

`adder/Cargo.toml`:

```toml
[dependencies]
add_one = { path = "../add_one" }
```

Введём `add_one` в область видимости:

`adder/src/main.rs`:

```rust
use add_one;

fn main() {
    let num = 10;
    println!("Hello, world! {num} plus one is {}", add_one::add_one(num));
}
```

Можно указать, какой пакет из рабочего пространства мы хотим запустить, указав его после ключа `-p` для `cargo run`:

```bash
cargo run -p adder
```

__Связываем внешний пакет с рабочим пространством__

`Cargo.lock` в верхней директории один. С его помощью удостоверяемся, что все крэйты будут использовать одни и те же версии своих зависимостей.

`add_one/Cargo.toml`:

```toml
[dependencies]
rand = "0.8.5"
```

```bash
cargo build
```

Чтобы добавить `rand` для `adder`, нужно тем же способом отредактировать его `Cargo.toml`.

__Добавляем тест в рабочее пространство__

`add_one/src/lib.rs`:

```rust
pub fn add_one(x: i32) -> i32 {
    x + 1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(3, add_one(2));
    }
}
```

```bash
cargo test
```

Для тестов отдельного крэйта указывается ключ `-p` с указанием имени крэйта, для которого хотим провести тестирование:

```bash
cargo test -p add_one
```

Публиковать крэйты в _Crates.io_ нужно раздельно (сделать это можно также используя ключ `-p` с указанием имени крэйта).

### 14.4. Установка двоичных файлов из _Crates.io_ при помощи `cargo install`

`cargo install` позволяет устанавливать и использовать двоичные крэйты локально. Они не заменят системные пакеты.

Все двоичные файлы, установленные при помощи `cargo install`, помещаются в коренную директорию установщика (`$HOME/.cargo/bin` по-умолчанию).

```bash
cargo install ripgrep
```

### 14.5. Расширение _Cargo_ при помощи пользовательских команд

Если существует двоичный файл, расположенный в `$PATH`, с именем `cargo-something`, можно запустить его, как субкоманду `cargo something`. Субкоманды можно перечислить при помощи команды `cargo -- list`.

## 15. Умные указатели

_Умные указатели_ - это структуры данных, которые действуют, как указатели, но имеют дополнительные метаданные и возможности.

Ссылки заимствуют данные, а умные указатели владеют данными, на которые они указывают.

Частный случай умных указателей - типы `String` и `Vec<T>`.

Умные указатели часто реализованы при помощи структур. Они также имеют трейты `Deref` и `Drop`. `Deref` позволяет экземпляру умного указателя вести себя, как ссылка. `Drop` позволяет кастомизировать код, который запускается после того, как умный указатель выходит из области видимости.

Умные указатели можно реализовать самостоятельно.

Часто используемые умные указатели стандартной библиотеки:

 + `Box<T>` для выделения ресурсов из кучи
 + `Rc<T>` - считающий количество ссылок тип, разрешающий множественное владение
 + `Ref<T>` и `RefMut<T>`, доступные через `RefCell<T>` - тип, принуждающий к применению правил заимствования во время выполнения вместо применения их при компиляции

Также существует паттерн внутренней мутабельности, предоставляющий __API__ для изменения внутреннего значения иммутабельных типов.

### 15.1. Использование `Box<T>` для указания на данные в "куче"

Самый простой умный указатель - это "_коробка_". Коробки позволяют хранить данные в "куче".

Обычно коробки используются в следующих случаях:

 + Когда имеется тип данных, размер которого не известен на время компиляции, а значение данного типа нужно в контексте, который требует наличия размера.
 + Когда есть большое количество данных, владение над которыми нужно передать так, чтобы данные не были скопированы.
 + Когда нужно владеть значением такого типа, который имплементирует конкретный трейт, а не является конкретным типом.

Первый случай будет рассмотрен здесь. Для второго случая передача данных может занять долгое время из-за копирования в области стека, потому используются указатели, когда сами данные хранятся в куче. Третий случай будет рассмотрен в [[#17. ООП в _Rust_]].

__Использование `Box<T>` для хранения данных в куче__

Пример использования коробки для хранения значения типа `i32` в куче:

`src/main.rs`:

```rust
fn main() {
    let b = Box::new(5);
    println!("b = {}", b);
}
```

Коробка `b` указывает на значение `5`, память для которого была выделена в куче. Когда коробка выходит из области видимости, она деаллоцируется. Освобождается и коробка, и данные, на которые она указывает.

__Разрешение рекурсивных типов при помощи коробок__

Значения _рекурсивного типа_ могут содержать другие значения того же типа, как часть себя. Таким примером может быть _cons list_.

__Больше информации о _cons list___

_Cons list_ - это структура данных из __ЯП__ _Lisp_. Состоит она из вложенных пар и является версией связного списка. Имя происходит от имени функции `cons` (construct function) _Lisp_, которая конструирует новую пару из двух аргументов. Вызывая `cons` для пары, состоящей из значения и ещё одной пары, мы можем сконструировать _cons list_'ы, состоящие из рекурсивных пар.

```
(1, (2, (3, Nil)))
```

Каждый элемент _cons list_'а содержит два элемента: значение текущего элемента и следующий элемент. _Cons list_ конструируется рекурсивным вызовом `cons`. Каноничное имя для обозначения базы рекурсии - `Nil`.

Код ниже не скомпилируется, поскольку для типа `List` не известен размер.

`src/main.rs`:

```rust
enum List {
    Cons(i32, List),
    Nil,
}
```

> [!note]
> В структуре `List` можно хранить и данные обобщённого типа.

Для хранения списка `1, 2, 3` код может быть таким:

`src/main.rs`:

```rust
use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
```

_Rust_ пока ещё не знает, сколько нужно пространства для хранения `List`, потому код выше не скомпилируется.

__Вычисление размера нерекурсивного типа__

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```

Для примера сверху, _Rust_ проходит по каждому варианту и смотрит, какому нужно больше всего ресурсов. Поскольку для перечисления используется один вариант, выделить в стеке для данного типа достаточно только столько, сколько займёт наибольший.

Процесс определения количества памяти для `List` может занять бесконечное количество времени, поскольку компилятор пытается вычислить размер рекурсивно, заглядывая дальше по ссылкам внутри `List`.

__Использование `Box<T>` для получения рекурсивного типа известного размера__

_Rust_ в случае с _cons list_, рассмотренном выше, попросит нас хранить значения не напрямую, а опосредованно, храня указатель на значение следующего элемента.

Поскольку `Box<T>` - указатель, _Rust_ знает, сколько места займёт структура.

`src/main.rs`:

```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}
```

Коробки предоставляют только опосредованность и аллокацию в куче.

`Box<T>` является умным указателем, поскольку имплементирует трейт `Deref`, который позваляет рассматривать его значения, как ссылки. Когда значение типа `Box<T>` выходит из области видимости, данные в куче, на которые оно ссылается, очищаются, поскольку у него есть имплементация трейта `Drop`.

### 15.2. Обращение к умным указателям, как к к обычным ссылкам, при помощи трейта _Deref_

Имплементация трейта `Deref` позволяет настроить поведение опереатора разыменования `*`.

> [!note]
> В примерах ниже пользовательский тип `MyBox<T>` не будет хранить данные в куче, как `Box<T>`.

__Следование указателя ко значению__

Пример разыменования:

`src/main.rs`:

```rust
fn main() {
    let x = 5;
    let y = &x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```

`y` в примере выше - ссылка на `x`.

__Использование `Box<T>` в качестве ссылки__

Разыменование переменной типа `Box<T>` будет работать также, как и разыменование ссылки:

`src/main.rs`:

```rust
fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```

Единственная разница между данным примером и примером выше состоит в том, что сначала создаётся копия переменной `x` в куче, а потом разыменовывается указатель на копию данной переменной, находящуюся в куче.

__Определение собственного умного указателя__

`Box<T>` - кортежная структура с одним элементом. Определим `MyBox<T>` таким же образом и определим для него функцию `new()`:

`src/main.rs`:

```rust
struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}
```

Обобщённый тип для коробки позволяет хранить (и указывать на) значения любого типа. `MyBox` - кортежная структура с одним элементом типа `T`. `MyBox::new()` принимает один параметр типа `T` и возвращает экземпляр `MyBox`, который хранит значение, которое ему передали.

Код ниже не скомпилируется, поскольку _Rust_ не знает, как разыменовывать `MyBox`.

`src/main.rs`:

```rust
fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```

`MyBox<T>` не получается разыменовать, поскольку мы не реализовали для него данную возможность (для этого нужен трейт `Deref`.

__Обращение к типу, как к ссылке, при помощи реализации трейта `Deref`__

Трейт `Deref`, предоставляемый стандартной библиотекой, требует реализации метода `.deref()`, который заимствует `self` и возвращает ссылку на данные внутри.

`src/main.rs`:

```rust
use std::ops::Deref;

impl<T> Deref for MyBox<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
```

`type Target = T;` определяет ассоциированный с `Deref` тип. Ассоциированный тип - это немного другой способ объявлять параметр общего типа (см. [[#19. Продвинутые возможности]]).

`.deref()` возвращает ссылку на значение (ссылка на `self.0`), к которому мы далее хотим получить доступ при помощи `*`.

Метод `.deref()` даёт компилятору возможность взять значение любого типа с трейтом `Deref` и вызвать `.deref()`, чтобы получить ссылку (`&`), которую можно разыменовать.

Когда мы разыменовываем `y`, _Rust_ выполняет следующее:

```rust
*(y.deref())
```

Эта особенность позволяет не обращать внимание на то, разыменовываем ли мы ссылку или же тип, реализующий трейт `Deref`.

Если бы `.deref()` возвращал не ссылку, а значение, значение было бы перемещено из `self`. Но нам не нужно овладевать внутренним значением `MyBox<T>`.

__Скрытое ограничение `Deref` функциями и методами__

Ограничения `Deref` конвертируют ссылку на тип, который имплементирует трейт `Deref` в ссылку на другой тип. К приемеру, они могут конвертировать `&String` в `&str`, поскольку `String` имеет трейт `Deref`, который возвращает `&str`. Ограничения `Deref` - это соглашение, которое _Rust_ выполняет для аргументов функций и методов и работает только для типов с трейтом `Deref`. Это происходит автоматически, когда мы передаём ссылку на значение конкретного типа в качестве аргумента функии или метода, который не совпадает с типом параметра в определении функции или метода. Последовательность вызовов метода `.deref()` конвертирует тип, который мы предоставили в тип, который принимает функция или метод.

`src/main.rs`:

```rust
fn hello(name: &str) {
    println!("Hello, {name}!");
}
```

Мы можем вызвать функцию `hello()` со строковым слайсом в качестве аргумента (`hello("Rust")`). Ограничения `Deref` делают возможным вызов `hello()` со ссылкой на значения типа `MyBox<String>`.

`src/main.rs`:

```rust
fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&m);
}
```

Поскольку мы реализовали трейт `Deref` для `MyBox<T>`, можно превратить `&MyBox<String>` в `&String` при помощи вызова `.deref()`. Стандартная библиотека предоставляет имплементацию трейта `Deref` для `String`, который возвращает слайс. _Rust_ вызывает `.deref()`, чтобы превратить `&String` в `&str`, что совпадает с определением функции `hello()`.

Если бы в _Rust_ не было ограничений `Deref`, пришлось бы писать следующий код:

`src/main.rs`:

```rust
fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&(*m)[..]);
}
```

`*(m)` разыменовывает `MyBox<String>` в `String`. Далее `&` и `[..]` берут строковой слайс от `String`, который равен строке целиком, чтобы соответствовать сигнатуре функции `hello()`.

Количество вызовов `Deref::deref()` определяется на этапе компиляции.

__Как ограничения `Deref` взаимодействуют с мутабельностью__

Как трейт `Deref` может перегрузить оператор `*` для иммутабельных ссылок, так трейт `DerefMut` может перегрузить оператор `*` для мутабельных ссылок.

_Rust_ выполняет ограничения `Deref`, когда он находит имплементации типов и трейтов в трёх случаях:

 + Из `&T` в `&U`, когда `T: Deref<Target=U>`
 + Из `&mut T` в `&mut U`, когда `T: DerefMut<Target=U>`
 + Из `&mut T` в `&U`, когда `T: Deref<Target=U>`

В первом случае, если есть `&T`, а `T` имеет трейт `Deref` в `U`, можно получить `&U` прозрачно. Второй случай - то же самое, но для мутабельных ссылок.

Третий случай сложнее. _Rust_ будет ограничивать мутабельную ссылку в иммутабельную. Но обратное невозможно: иммутабельные ссылки никогда не могут ограничиваться в мутабельные. Из-за правил заимствования, если у нас есть мутабельная ссылка, данная мутабельная ссылка только она может указывать на конкретные данные (одна ссылка - одни данные). Конвертация одной мутабельной ссылки в одну иммутабельную не нарушает правил заимствования. Конвертация иммутабельной ссылки в мутабельную ссылку будет требовать, чтобы изначальная иммутабельная ссылка была единственной иммутабельной ссылкой на конкретные данные, но правила заимствования этого не гарантируют. 

### 15.3. Исполнение кода на очистку с трейтом _Drop_

Второй важный трейт для умных указателей - `Drop`, который позволяет настроить поведение при выходе значения из области видимости.

Трейт `Drop` требует реализации метода `.drop()`, который принимает мутабельную ссылку на `self`. В примере ниже структура `CustomSmartPointer` реализует трейт `Drop`.

`src/main.rs`:

```rust
struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&mut self) {
        println!("Dropping CustomSmartPointer with data: {}!", self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from("my stuff"),
    };
    let d = CustomSmartPointer {
        data: String::from("other stuff"),
    };
    println!("CustomSmartPointers created.");
}
```

В тело функции `drop()` помещается код, который выполняется при выходе экземпляра из области видимости. В примере выше `drop()` автоматически вызовется при выходе переменных `c` и `d` из области видимости. Сама же функция `drop()` выведет содержимое переменных `c` и `d` типа `CustomSmartPointer`. Переменные очищаются в обратном от их создания порядке, т.е. `d` очищается перед `c`.

__Ранний отброс значений при помощи `std::mem::drop`__

Стандартный функционал `.drop()` отключить немного сложно. Отключение `.drop()` в принципе обычно не обязательно; весь смысл трейта `Drop` в том, что он обрабатывается автоматически. Тем не менее, может возникнуть необходимость очистить значение заранее. Один из таких примеров - использование умных указателей для управления блокировками: может понадобиться вызвать `.drop()`, который освобождает блокировку тау, что другой код в той же области видимости может занять блокировку. _Rust_ не позволяет вызвать `.drop()` вручную; вместо этого нужно вызвать функцию `std::mem::drop()`, предоставленную стандартной библиотекой.

Если мы попытаемся вызвать метод `.drop()` трейта `Drop` самостоятельно, код не скомпилируется.

`src/main.rs`:

```rust
fn main() {
    let c =CustomSmartPointer {
        data: String::from("some data"),
    };
    println!("CustomSmartPointer created.");
    c.drop();
    println!("CustomSmartPointer dropped before the end of main.");
}
```

`.drop()` является деструктором. Попытка вызова `.drop()` приведёт к ошибке двойного освобождения, поскольку данный метод уже автоматически вызывается в конце функции.

Мы не можем отключить автоматический вызов `.drop()` и не можем вызывать `.drop()` самостоятельно. Поэтому для ранней очистки нужно использовать `std::mem::drop()`.

`std::mem::drop` отличается от метода `.drop()` трейта `Drop`. В `std::mem::drop` мы передаём аргумент со значением, которое хотим освободить. Функция находится в прелюдии по-умолчанию. Код ниже уже скомпилируется.

`src/main.rs`:

```rust
fn main() {
    let c = CustomSmartPointer {
        data: String::from("some data"),
    };
    println!("CustomSmartPointer created.");
    drop(c);
    println!("CustomSmartPointer dropped before the end of main.");
}
```

### 15.4. `Rc<T>`: умный указатель со счётчиком ссылок

В большинстве случаев владение очевидно: мы знаем, какая переменная владеет значением. Тем не менее, существуют случаи, когда одно значение может иметь несколько владельцев. К примеру, в графах, несколько граней могут указывать на один и тот же узел, и данным узлом концептуально владеют все грани, указывающие на него. Узел не должен быть очищен, пока существует хотя бы одна грань, указывающая на него.

Множественное владение доступно с использованием типа `Rc<T>` (_reference counting_). `Rc<T>` следит за количеством ссылок на значение, чтобы определить, используется ли данное значение или нет. Если ссылки отсутствуют, значение может быть очищено.

При использовании `Rc<T>` мы выделяем данные в куче для нескольких частей нашей программы и мы не можем определить во время компиляции, какая часть завершит использовать данные первой.

`Rc<T>` используется для однопоточных сценариев.

__Использование `Rc<T>` для разделения ресурсов__

В примере ниже мы пытаемся создать список `a`, содержащий элемент `5`, затем `10`. Далее создаём ещё два списка: `b`, начинающийся с элемента `3` и `c`, начинающийся с элемента `4`. Затем списки `b` и `c` продолжатся с первого элемента списка `a`. Пример ниже для такого случая не скомпилируется.

`src/main.rs`:

```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}
```

Варианты `Cons` владеют данными, которые они содержат, так что при создании списка `b`, `a` перемещается в `b` и `b` овладевает `a`. Далее, когда мы пытаемся использовать `a` снова при создании `c`, у нас ничего не выходит, поскольку `a` был перемещён.

Можно изменить определение `Cons` так, чтобы в нём содержались ссылки, но тогда нам нужно будет указывать параметры времени жизни. Указав параметры времени жизни, мы определим, что каждый элемент в списке будет существовать, пока существует весь список. Это может подойти для случая выше, но не для всех сценариев.

Вместо этого, мы изменим определение `List` так, чтобы использовался тип `Rc<T>` вместо `Box<T>`. Каждый вариант `Cons` теперь содержит значение и `Rc<T>`, указывающий на `List`. Когда мы создаём `b`, вместо передачи ему владения над `a`, мы клонируем `Rc<List>`, находящийся в `a`, таким образам, увеличивая число ссылок с одной на две и давая возможность `a` и `b` разделять владение данными в `Rc<List>`. Мы также клонируем `a`, когда создаём `c`, увеличивая число ссылок с двух до трёх. Каждый вызов `Rc::clone()` увеличивает счётчик ссылок на данные в `Rc<List>` и они не будут очищены, пока счётчик не обнулится.

`src/main.rs`:

```rust
enum List {
    Cons(i32, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&a));
    let c = Cons(4, Rc::clone(&a));
}
```

Нужно добавить `use`, чтобы принести `Rc<T>` в область видимости, поскольку его нет в прелюдии. В `main()` мы создаём список, содержащий `5` и `10` и помещаем его в новый `Rc<List>` в `a`. Далее мы создаём `b` и `c`, вызывая `Rc::clone()` и передавая ссылку на `Rc<List>` в `a` в качестве аргумента.

Мы могли бы вызвать `a.clone()` вместо `Rc::clone(&a)`, но соглашение в _Rust_ говорит об использовании `Rc::clone()` для таких случаев. Реализация `Rc::clone()` не создаёт "глубокую копию" данных, как `.clone()` для многих типов. `Rc::clone()` только инкрементирует счётчик ссылок, что не занимает много времени. Глубокое копирование данных может занять много времени. `Rc::clone()` визуально разделяет клонирование с созданием глубоких копий и клонирование, увеличивающее счётчик ссылок.

__Клонирование `Rc<T>` увеличивает счётчик ссылок__

В примере ниже мы можем видеть, как меняется счётчик ссылок, когда одна из них (`c`) выходит из области видимости.

`src/main.rs`:

```rust
fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("count after creating a = {}", Rc::strong_count(&a));
    let b = Cons(3, Rc::clone(&a));
    println!("count after creating b {}", Rc::strong_count(&a));
    {
        let c = Cons(4, Rc::clone(&a));
        println!("count after creating c = {}", Rc::strong_count(&a));
    }
    println!("count after c goes out of scope = {}", Rc::strong_count(&a));
}
```

Количество ссылок мы получаем при помощи функции `strong_count()`.

В примере выше, каждый вызов `clone()` увеличивает счётчик ссылок. Когда `c` выходит из области видимости, количество ссылок уменьшается на единицу. Трейт `Drop` уменьшает количество ссылок автоматически при выходе ссылки `Rc<T>` из области видимости.

В конце `main()` `a` и `b` выходят из области видимости и счётчик ссылок обнуляется, после чего `Rc<List>` полностью очищается.

С иммутабельными ссылками `Rc<T>` позволяет разделять данные для чтения между разными частями программы. Если бы `Rc<T>` позволял иметь несколько иммутабельных ссылок, это привело бы к нарушению одного из правил заимствований (см. [[#4. "Владение"]]).

### 15.5. `RefCell<T>` и паттерн внутренней мутабельности

_Внутренняя мутабельность_ - паттерн в _Rust_, который позволяет изменять данные даже если на них есть иммутабельные ссылки. Обычно, данное действие запрещено правилами заимствований. Для изменения данных, паттерн использует небезопасный код (`unsafe`) внутри структуры данных, чтобы обойти некоторые правила _Rust_.

Мы можем использовать типы со внутренней мутабельностью только когда удостоверены в том, что правила заимствований будут проверяться во время выполнения, чего не может обещать компилятор. Код `unsafe` далее оборачивается в безопасный __API__.

__Проверка правил заимствования только во время выполнения программы при помощи `RefCell<T>`__

В отличие от `Rc<T>`, `RefCell<T>` представляет собой единичного владельца данными.

Правила заимствований для `Box<T>` и ссылок проверяются во время компиляции, а для `RefCell<T>` они должны соблюдаться во время выполнения программы.

`RefCell<T>` полезен, когда есть уверенность в том, что код следует правилам заимствования, но компилятор не может этого понять.

`RefCell<T>` используется только в однопоточных сценариях и выдаст ошибку компиляции при попытке использования его в нескольких потоках.

 + `Rc<T>` позволяет множественное владение одними данными; данные, на которые указывают `Box<T>` и `RefCell<T>` имеют одного владельца.
 + `Box<T>` позволяет проверять мутабельные и иммутабильные заимствования во время компиляции; `Rc<T>` позволяет проверять только иммутабельные заимствования во время компиляции; `RefCell<T>` позволяет проверять мутабельные и иммутабельные заимствования во время выполнения.
 + Поскольку `RefCell<T>` позволяет проверять мутабельные заимствования во время выполнения, можно изменять значения внутри `RefCell<T>`, даже если `RefCell<T>` иммутабельна.

Изменение значений внутри иммутабельных ячеек называется паттерном внутренней мутабельности.

__Мутабельность внутренностей: мутабельное заимствование иммутабельного значения__

Последствием правил заимствований является то, что, имея иммутабельное значение, невозможно заимствовать его мутабельно. Например, код ниже не скомпилируется:

```rust
fn main() {
    let x = 5;
    let y = &mut x;
}
```

Тем не менее, существуют ситуации, в которых может быть полезно для значений быть мутабельными в методах, но иммутабельными для всего остального кода. Код вне методов значения не должен иметь возможность изменять это самое значение. `RefCell<T>` - способ получить внутреннюю мутабельность, но `RefCell<T>` при этом не соблюдает правил заимствования: проверка заимствований в компиляторе это позволяет, но соблюдать их придётся во время выполнения программы. Нарушение правил приведёт к `panic!()`.

__Случаи использования внутренней метабельности: макеты__

Иногда во время тестирования приходится использовать один тип вместо другого для того, чтобы пронаблюдать за поведением и утвердить корректность кода. Данный плейсхолдер называется _тестовым дублёром_. _Макет_ - это специфичный тип для тестовых дублёров, который записывает всё случившееся во время тестирования.

_Rust_ не имеет объектов в том же смысле, что и в других __ЯП__ и _Rust_ не имеет встроенного функционала макетов.

В примере ниже наша библиотека предоставит функционал слежения за тем, как близко оно к максимальному значению и выведения сообщений при достижении одного из порогов. Приложения, использующие нашу библиотеку, должны предоставить механизм отправки сообщений, библиотеке не обязательно знать о деталях. Всё, что ей нужно - нечто, имплементирующее трейт `Messenger`.

`src/lib.rs`:

```rust
pub trait Messenger {
    fn send(&self, msg: &str);
}

pub struct LimitTracker<'a, T: Messenger> {
    messenger: &'a T,
    value: usize,
    max: usize,
}

impl<'a, T> LimitTracker<'a, T>
where
    T: Messenger,
{
    pub fn new(messenger: &'a T, max: usize) -> LimitTracker<'a, T> {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&mut self, value: usize) {
        self.value = value;
        
        let percentage_of_max = self.value as f64 / self.max as f64;
        
        if percentage_of_max >= 1.0 {
            self.messenger.send("Error: You are over your quota!");
        } else if percentage_of_max >= 0.9 {
            self.messenger
                .send("Urgent warning: You've used up over 90% of your quota!");
        } else if percentage_of_max >= 0.75 {
            self.messenger
                .send("Warning: You've used up over 75% of your quota!");
        }
    }
}
```

Важная часть кода выше заключается в том, что трейт `Messenger` имеет один метод `.send()`, который принимает иммутабельную ссылку на `self` и текст сообщения. Данный трейт - это интерфейс, который наш макет должен реализовать так, чтобы макет мог быть использован так же, как реальный объект. Другой важный момент: нам нужно тестировать поведение метода `.set_value()` на `LimitTracker`. Мы можем изменить то, что передаём в параметре `value`, но `.set_value()` не возвращает ничего, что можно было бы проверить. У нас должна быть возможность сказать, что если мы создаём `LimitTracker` с чем-то, что реализует трейт `Messenger` и конкретным значением для `max`, когда мы передаём различные числа для `value`, то мессенджеру было сказано отправить соответствующие сообщения.

Когда нужен макет такой, что вместо отправки письма или текстового сообщения при вызове `send()`, будет производиться только наблюдение за сообщениями, которые нужно отправить. Мы можем создать новый экземпляр макета, `LimitTracker`, который использует макет, вызвать `.set_value()` на `LimitTracker` и затем проверить, что макет имеет сообщения, которые мы ожидаем в нём увидеть. Пример ниже попытается сделать вышеперечисленное, но проверка заимствований не позволить сделать это.

`src/lib.rs`:

```rust
#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_message: Vec<String>,
    }

    impl MockMessenger {
        fn new() -> MockMessenger {
            MockMessenger {
                sent_messages: vec![],
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&self, message: &str) {
            self.sent_message.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&mock_messenger, 100);
        
        limit_tracker.set_value(80);
        
        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}
```

Код в тесте определяет структуру `MockMessenger`, которая имеет поле `sent_messages` с полем `Vec`, внутри которого `String`, чтобы следить за сообщениями, которые необходимо отправить. Также мы определяем ассоциированную функцию `new()`, чтобы можно было создавать новые значения `MockMessenger`, которые начинаются с пустого списка сообщений. Далее реализуем трейт `Messenger` для `MockMessenger` так, чтобы мы могли передать `MockMessenger` в `LimitTracker`. В определении `.send()` мы берём сообщение, переданное методу в качестве параметра и сохраняем его в списке `sent_messages` структуры `MockMessenger`.

Внутри теста мы проверяем, что происходит, когда `LimitTracker`'у было сказано установить `value` во что-то, что более, чем `75%` от `max`. Для начала мы создаём новый `MockMessenger`, который начнётся с пустого списка сообщений. Далее создаём новый `LimitTracker` и передаём ему ссылку на новый `MockMessenger` и `max` со значением `100`. Мы можем вызвать `.set_value()` на `LimitTracker` со значением `80`, что больше, чем `75%` от `100`. Далее удостоверяемся, что список сообщений, за которым следит `MockMessenger`, имеет одно из сообщений внутри.

Но при тестировании возникнет проблема - мы не можем модифицировать `MockMessenger` так, чтобы он следил за сообщениями, поскольку `.send()` принимает иммутабельную ссылку на `self`. Мы также не можем использовать `&mut self`, потому что из-за этого сигнатура `.send()` не будет совпадать с сигнатурой в определении трейта `Messenger`.

В данной ситуации может помочь внутренняя мутабельность. Мы поместим в `sent_messages` `RefCell<T>`, после чего `.send()` сможет модифицировать `sent_messages` так, чтобы хранить в нём сообщения.

`src/lib.rs`:

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_message: RefCell<Vec<String>>,
    }

    impl MockMessenger {
        fn new() -> MockMessenger {
            MockMessenger {
                sent_messages: RefCell::new(vec![]),
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&self, message: &str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warnint_message() {
// ...
    assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}
```

`sent_messages` теперь имеет тип `RefCell<Vac<String>>` вместо `Vec<String>`. В функции `new()` мы создаём новый экземпляр `RefCell<Vec<String>>`.

Для реализации `.send()` первый параметр - всё-ещё иммутабельное заимствование `self`, что совпадает с определением. Мы можем вызвать `.borrow_mut()` на `RefCell<Vec<String>>` внутри `self.sent_messages()`, чтобы получить мутабельную ссылку на значение внутри `RefCell<Vec<String>>`, что будет являться вектором. Далее мы можем вызвать `.push()` на мутабельную ссылку на вектор, чтобы следить за сообщениями во время теста.

Последнее изменение в проверке: чтобы видеть, как много элементов внутри вектора, мы вызываем `.borrow()` на `RefCell<Vec<String>>`, чтобы получить иммутабельную ссылку на вектор.

__Слежение за заимствованиями во время выполнения при помощи `RefCell<T>`__

При создании иммутабельных и мутабельных ссылок, мы используем синиаксис `&` и `&mut`. С `RefCell<T>` мы используем `.borrow()` и `.borrow_mut()`, являющиеся частью безопасного __API__ `RefCell<T>`. `.borrow()` возвращает умный указатель типа `Ref<T>`, `.borrow_mut()` возвращает умный указатель типа `RefMut<T>`. Оба типа имеют трейт `Deref`, так что можно использовать их, как обычные указатели.

`RefCell<T>` следит за тем, сколько умных указателей `Ref<T>` и `RefMut<T>` активны на данный момент. Каждый вызов `.borrow()` `RefCell<T>` увеличивает счётчик активных иммутабельных заимствований. Когда значение `Ref<T>` выходит из области видимости, счётчик иммутабельных зависимостей уменьшается на единицу. Как и в случае с правилами заимствований для компилятора, `RefCell<T>` позволяет нам иметь множество иммутабельных заимствований или же одно мутабельное заимствование.

При попытке нарушения правил реализация `RefCell<T>` вызовет `panic!()` во время выполнения. В примере ниже мы попытаемся создать два активных мутабельных заимствования для одной области видимости, что приведёт к аварийному завершению программы.

`src/lib.rs`:

```rust
impl Messenger for MockMessenger {
    fn send(&self, message: &str) {
        let mut one_borrow = self.sent_nessages.borrow_mut();
        let mut two_borrow = self.sent_messages.borrow_mut();
        
        one_borrow.push(String::from(message));
        two_borrow.push(String::from(message));
    }
}
```

Выше мы создаём переменную `one_borrow` для умного указателя `RefMut<T>`, вернувшегося из `.borrow_mut()`. Далее создаём ещё одно мутабельное заимствование тем же образом для переменной `two_borrow`. Это создаёт две мутабельные ссылки в одной области видимости, что недопустимо. Код скомпилируется без ошибок, но тест не пройдёт.

Код выдаст ошибку `already borrowed: BorrowMutError`.

У кода будет небольшая просадка в производительности, как результат слежения за заимствованиями во время выполнения, а не во время компиляции.

__Множественное владение мутабельными данными при помощи комбинации `Rc<T>` и `RefCell<T>`__

Общий случай использования `RefCell<T>` - его комбинация с `Rc<T>`. Если у нас есть `Rc<T>`, который содержит `RefCell<T>`, можно получить значение, которое может владеть несколькими объектами и которые можно будет изменять.

В примере ниже при помощи `RefCell<T>` в определении `Cons` можно изменять значения, которые хранятся во всех списках.

`src/main.rs`:

```rust
#[derive(Debug)]
enum List {
    Cons(Rc<RefCell<i32>>, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&a));

    *value.borrow_mut() += 10;

    println!("a after = {:?}", a);
    println!("b after = {:?}", b);
    println!("c after = {:?}", c);
}
```

Мы создаём значение, которое является экземпляром `Rc<RefCell<i32>>` и храним его в переменной `value`, чтобы получить прямой доступ к нему позже. Далее создаём `List` в `a` с вариантом `Cons`, который содержит `value`. Нам нужно склонировать `value` так, что `a` и `value` будут владеть внутренним значением `5`, а не передавать владение из `value` в `a` или не иметь заимствований для `a` из `value`.

Мы оборачиваем список `a` в `Rc<T>` так, что когда создаём списки `b` и `c`, они оба смогут ссылаться на `a`.

После создания списков в `a`, `b` и `c`, мы хотим добавить `10` ко значению в `value`. Мы делаем это при помощи вызова `.borrow_mut()` на `value`, который использует автоматическое разыменование, чтобы разыменовать `Rc<T>` ко внутреннему значению `RefCell<T>`. `.borrow_mut()` возвращает умный указатель `RefMut<T>`  мы используем оператор разыменования на нём, чтобы изменить внутреннее значение.

После вывода `a`, `b` и `c` мы видим, что значение `5` изменено на `15`.

`Mutex<T>` является потокобезопасной версией `RefCell<T>`.

### 15.6. Цикличные ссылки и утечка памяти

_Rust_ всё-ещё не даёт гарантий отсутствия утечек памяти.

__Создание цикличных ссылок__

`src/main.rs`:

```rust
use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell<Rc<List>>),
    Nil.
}

impl List {
    fn tail(&self) -> Option<&RefCell<Rc<List>>> {
        match self {
            Cons(_, item) => Some(item),
            Nil => None,
        }
    }
}

fn main() {}
```

В примере выше мы используем вариацию `List` из рассмотренных ранее примеров. Второй элемент варианта `Cons` теперь `RefCell<Rc<List>>`, что значит, что вместо возможности изменения значения `i32`, мы можем изменить значение `List` вариантом `Cons`, на который указываем. Также добавлен метод `.tail()`, чтобы иметь доступ ко второму элементу, если у нас есть вариант `Cons`.

В примере ниже мы добавляем функцию `main()`, которая использует определения из примера выше. Код создаёт список в `a` и список в `b`, который указывает на список в `a`. Далее модифицируем список в `a`, чтобы он указывал на `b`, создав таким образом цикличные сслыки.

`src/main.rs`:

```rust
fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!("a initial rc count = {}", Rc::strong_count(&a));
    println!("a next item = {:?}", a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&a))));

    println!("a rc count after b creation = {}", Rc::strong_count(&a));
    println!("b initial rc count = {}", Rc::strong_count(&b));
    println!("b next item = {:?}", b.tail());

    if let Some(link) = a.tail() {
        *link.borrorw_mut() = Rc::clone(&b);
    }

    println!("b rc count after changing a = {}", Rc::strong_count(&b));
    println!("a rc count after changing a = {}", Rc::strong_count(&a));

    // println!("a next item = {:?}", a.tail());
}
```

Мы создали экземпляр `Rc<List>`, содержащий значение `List` в переменной `a` с инициируюзем списком `5, Nil`. Далее создаём экземпляр `Rc<List>`, содержащий другое значение `List` в переменной `b`, который содержит значение `10` и указывает на список в `a`.

Дальше мы модифицируем `a` так, что он указывает на `b` вместо `Nil`, создав при этом зацикливание. Мы делаем это при помощи метода `.tail()`, чтобы получить ссылку на `RefCell<Rc<List>>` в `a`, которую кладём в переменную `link`. Далее мы используем `.borrow_mut()` на `RefCell<Rc<List>>`, чтобы изменить значение внутри из `Rc<List>`, которое хранит значение `Nil` на значение `Rc<List>` в `b`.

Счётчик ссылок в `Rc<List>` для `a` и для `b` равен `2` после того, как мы изменили список в `a`, чтобы он указывал на `b`. В конце `main()` _Rust_ отбрасывает переменную `b`, что уменьшает количество ссылок `b` `Rc<List>` с `2` до `1`. Память, которую `Rc<List>` выделела в куче не будет отброшена, поскольку счётчик ссылок не равен нулю. Далее _Rust_ отбрасывает `a`, что уменьшает количество ссылок `a` `Rc<List>` с `2` до `1`. Память для неё тоже не может быть очищена, поскольку ещё одна `Rc<List>` ссылается на неё. Память никогда не будет очищена.

Если раскомментировать последний `println!()`, _Rust_ попытается напечатать весь цикл, где `a` указывает на `b`, указывающий на `a` и т.д., пока стек не переполнится.

Если мы имеем значения типа `RefCell<T>`, содержащие `Rc<T>` или подобные вложенные комбинации типов со внутренней мутабельностью и счётчиками ссылок, нужно удостовериться, что зацикливания не создаются.

Один из способов избежания цикличных ссылок - это реорганизация структур данных так, что некоторые ссылки выражают владение, а некоторые - нет. Как результат, можно иметь циклы, состоящие из некоторых взаимоотношений владения и некоторых взаимоотношений "не-владения" и только взаимоотношения владений будут влиять на то, можно ли будет отбросить определённое значение. В примере до предыдущего нам нужн было, чтобы вариант `Cons` владел собственным списком, так что реорганизация структуры данных невозможна.

__Предотвращение циклических ссылок: превращение `Rc<T>` в `Weak<T>`__

Можно создать _слабую ссылку_ на значение внутри `Rc<T>`, вызвав `Rc::downgrade()` и передав ему ссылку на `Rc<T>`. Сильные ссылки - это то, как разделяется владение над экземплярами `Rc<T>`. Слабые ссылки не выражают отношений владения и их счётчик не подвергается воздействию, когда экземпляр `Rc<T>` очищается. Они не создают циклических ссылок, потому что любой цикл со слабыми ссылками будет невалидным, как только счётчик сильных ссылок обнуляется.

При вызове `Rc::downgrade()` мы получаем умный указатель типа `Weak<T>`. Вместо увеличения `strong_count` в `Rc<T>` на единицу, вызов `Rc::downgrade()` увеличивает `weak_count` на единицу. Тип `Rc<T>` использует `weak_count` для слежки за количеством ссылок типа `Weak<T>`. `weak_count` не обязательно должен быть обнулён, чтобы `Rc<T>` могла быть очищена.

Поскольку значение может быть отброшено с использованием ссылок `Weak<T>`, действия со значениями, на которые указывает `Weak<T>`, нужно производить после того, как удостоверились, что значения существуют. Это делается при помощи вызова `.upgrade()` на `Weak<T>`, что вернёт `Option<Rc<T>>`. Получим результат `Some`, если `Rc<T>` ещё не было отброшено и результат `None`, если было отброшено. Поскольку `.upgrade()` возвращает `Option<Rc<T>>`, _Rust_ удостоверится в том, что случаи `Some` и `None` обрабатываются и не будет невалидного указателя.

__Создание дерева (узел с дочерними узлами)__

Для начала создадим дерево с узлами, которые знают о своих дочерних узлах. Структура `Node` содержит значение `i32` и ссылки на дочерние `Node`.

`src/main.rs`:

```rust
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell<Vec<Rc<Node>>>,
}
```

Нам нужно, чтобы у `Node` были дочери и чтобы владение над этими значениями было разделено так, чтобы можно было получить доступ к каждой `Node` в дереве напрямую. Для этого мы определяем элементы `Vec<T>` типа `Rc<Node>`. Нам также нужно модифицировать значения, отвечающие за то, какие узлы являются дочерними, потому нужно иметь `RefCell<T>` в `childern` вокруг `Vac<Rc<Node>>`.

Далее, мы используем наше строгое определение и создадим один экземпляр `Node` с именем `leaf`, которое имеет значение `3` и не имеет потомков, и ещё один экземпляр `branch` со значением `5` и `leaf`, как один из потомков.

`src/main.rs`:

```rust
fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell:new(vec![Rc::clone(&leaf)]),
    });
}
```

Мы клонируем `Rc<Node>` в `leaf` и помещаем в `branch`, что значит, что `Node` в `leaf` теперь имеет двух владельцев: `leaf` и `branch`. Мы можем получить `leaf` из `branch` через `branch.children`, но нет способа получить `branch` из `leaf`. Причина в том, что `leaf` не имеет ссылки на `branch` и не знает о взаимосвязи.

__Добавляем ссылку на потомка родителю__

Для того, чтобы потомок знал о родители, нужно добавить поле `parent` в определение `Node`. Проблема в определении типа `parent`. Мы знаем, что оно не может содержать `Rc<T>`, поскольку это приведёт к созданию цикличной ссылки с `leaf.parent`, указывающим на `branch` и `branch.children`, указывающим на `leaf`, что может стать причиной того, что `strong_count` никогда не обнулится.

Если мыслить о взаимоотношениях иначе, родительский узел должен владеть своими потомками; если родительский узел отброшен, все потомки также должны быть отброшены. Тем не менее, потомок не может владеть своим родителем: если мы отбросим узел потомка, узел родителя должен продолжать существование. В данном случае нужно прибегнуть ко слабым ссылкам.

Вместо `Rc<T>`, для `parent` мы будем использовать `Weak<T>`, а именно `RefCell<Weak<Node>>`.

`src/main.rs`:

```rust
use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell<Weak<Node>>,
    children: RefCell<Vec<Rc<Node>>>,
}
```

Узел сможет ссылаться на родительский узел, но при этом не будет им владеть.

`src/main.rs`:

```rust
fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&branch);

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
}
```

Создание узла `leaf` похоже на то, что было ранее за исключением поля `parent`: `leaf` стартует без родителя и так мы можем создать новый, пустой экземпляр `Weak<Node>`.

На этом моменте, когда попытаемся получить ссылку на родителя `leaf`, используя `.upgrade()`, мы получим `None`.

Когда создаём узел `branch`, он также имеет новую ссылку `Weak<Node>` в поле `parent`, потому что `branch` не имеет родительского узла. Мы всё-ещё имеем `leaf`, как одного из потомков `branch`. Как только мы обзаведёмся экземпляром `Node` в `branch`, мы сможем модифицировать `leaf` так, чтобы дать ему ссылку `Weak<Node>` на его родителя. Мы используем `.borrow_mut()` на `RefCell<Weak<Node>>` в поле `parent` узла `leaf` и затем используем `Rc::downgrade()`, чтобы создать ссылку `Weak<Node>` на `branch` из `Rc<Node>` в `branch`.

Когда мы печатаем содержимое родителя `leaf` нова, в этот раз мы получим вариант `Some`, содержащий `branch`: теперь `leaf` может получить доступ ко своему родителю.

__Визуализация изменений в `strong_count` и `weak_count`__

В примере ниже демонстрируется изменения значений `strong_count` и `weak_count` для `Rc<Node>`. Создана новая область видимости, в которую перемещено создание `branch`.

`src/main.rs`:

```rust
fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&leaf),
        Rc::weak_count(&leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&leaf)]),
        });
        
        *leaf.parents.borrow_mut() = Rc::downgrade(&branch);
        
        println!(
            "branch strong = {}, weak = {}",
            Rc::strong_count(&branch),
            Rc::weak_count(&branch),
        );
        
        println!(
            "leaf strong = {}, weak = {}",
            Rc::strong_count(&leaf),
            Rc::weak_count(&leaf),
        );
    }

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&leaf),
        Rc::weak_count(&leaf),
    );
}
```

В примере выше после создания `leaf`, его `Rc<Node>` имеет счётчик сильных ссылок равным `1` и слабых ссылок равным `0`. Во внутренней области видимости мы создаём `branch` и ассоциируем его с `leaf`, после чего при печати счётчиков, `Rc<Node>` в `branch` будет иметь счётчик сильных ссылок, равный `1` и слабых равный `1` (для `leaf.parent`, указывающей на `branch` при помощи `Weak<Node>`). Когда печатаем счётчики в `leaf`, мы видим, что он будет иметь счётчик сильных ссылок равным `2`, поскольку `branch` теперь имеет клон `Rc<Node>` `leaf`, хранящийся в `branch.children`, но счётчик слабых ссылок всё-ещё будет равен нулю.

Когда вложенная область видимости заканчивается, `branch` выходит из неё и счётчик сильных ссылок `Rc<Node>` обнуляется, так что `Node` отбрасывается. Счётчик слабых ссылок `leaf.parent`, равный `1`, не влияет на очистку.

Если попытаемся получить доступ к родителю `leaf` после его выхода из области видимости, мы получим `None`. В конце программы `Rc<Node>` в `leaf` имеет счётчики сильных ссылок, равный `1` и слабых ссылок, равный `0`, поскольку переменная `leaf` теперь единственная ссылка на `Rc<Node>` снова.

## 16. Конкуренция

Конкуренция - запуск разных частей программы независимо друг от друга. Параллелизм - запуск разных частей программы одновременно.

### 16.1. Использование потоков для одновременного выполнения кода

Примеры проблем параллельно запущенного кода:

 + Состояние гонки, когда потоки пытаются получить доступ к ресурсам без определённого порядка.
 + Взаимная блокировка, когда два потока ждут друг друга и не могут продолжить своё выполнение.
 + Баги, которые случаются в исключительных случаях и которые сложно воспроизвести и исправить.

Стандартная библиотека _Rust_ использует модель _1:1_, когда программа, использующая один поток __ОС__, в языке указывается то же самое. Существуют крэйты, реализующие другие можеди многопоточности, которые отличаются от стандартной модели.

__Создание нового потока при помощи `spawn()`__

Для создания нового потока нужно вызвать функцию `thread::spawn()` и передать ей замыкание, содержащее код, который будет выполняться в новом потоке.

`src/main.rs`:

```rust
use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }
}
```

Как только основной поток завершается, все рождённые потоки тоже завершаются вне зависимости от того, дошли они до финальной точки или нет.

`thread::sleep()` заставляет поток остановить своё выполнение на короткий промежуток, позволяя другим потокам исполняться.

__Ожидание завершения всех потоков при помощи обработчиков `.join()`__

В примере выше рождённый поток останавливается как только останавливается основной поток, что не может даже гарантировать запуска рождённого потока.

Данная проблема рождённого потока решается сохранением значения, возвращаемого из `thread::spawn()`. Тип, возвращаемый из данной функции - `JoinHandle`. От него можно вызвать метод `.join()`, который будет ждать завершения потока. В примере ниже мы ожидаем завершение рождённого потока, только потом выходим из `main()`.

`src/main.rs`:

```rust
use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}
```

Вызов `.join()` на обработчике блокирует текущий поток, пока поток, который представлен обработчиком, не завершится.

В примере выше два потока запущены параллельно, но затем, как только завершается цикл в основном потоке и он доходит до `.join()`, он ожидает завершения рождённого потока.

В примере ниже основной поток дождётся завершения рождённого потока, а затем запустит свой цикл.

`src/main.rs`:

```rust
use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }
}
```

__Использование замыканий `move` с потоками__

Ключевое слово `move` часто используется с замыканиями, переданными в `thread::spawn()`, поскольку замыкания тогда смогут овладеть значениями из окружения, которые они используют, таким образом, передавая владение над этими значениями в тот или иной поток.

Пример ниже пытается создать вектор в основном потоке и использовать его в рождённом, но код не скомпилируется.

`src/main.rs`:

```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("Here's a vector: {:?}", v);
    });

    handle.join().unwrap();
}
```

Замыкание использует `v`, так что оно должно захватить `v` и сделать его частью окружения замыкания. Поскольку `thread::spawn()` выполняет данное замыкание в новом потоке, мы должны иметь возможность получить доступ к `v` внутри нового потока.

_Rust_ также не может сказать, как долго рождённый поток будет запущен, так что он не знает, всегда ли будет ссылка на `v` валидна. Пример ниже не скомпилируется также.

`src/main.rs`:

```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("Here's a vector: {:?}", v);
    });

    drop(v);

    handle.join().unwrap();
}
```

Если бы _Rust_ позволил выполнить код из примера выше, была бы возможность того, что рождённый поток сразу же переместился в фон без запуска. Рождённый поток имеет ссылку на `v` внутри, но основной поток сразу отбрасывает `v`, используя `drop()`. Далее, когда рождённый поток начинает выполняться, `v` уже невалидна.

Добавив ключевое слово `move` до замыкания, мы делаем так, что замыкание овладевает значениями, которые оно использует.

`src/main.rs`:

```rust
use std::thread;

fn main() {
    let vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!("Here's a vector: {:?}", v);
    });

    handle.join().unwrap();
}
```

Для примера выше только что рассмотренного, мы не можем использовать `move` и `drop()`. Как только `move` добавлен для замыкания, `v` перемещается в окружение замыкания и мы больше не можем вызвать `drop(v)` в основном потоке.

Переместив `v` в рождённый поток, мы даём гарантию, что основной поток больше не будет использовать `v`.

### 16.2. Использование обмена сообщениями для передачи данных между потоками

Один из популярных подходов к реализации безопасной конкурентности - _передача сообщений_, где потоки или акторы взаимодействуют друг с другом, посылая сообщения с данными. Пример - идея из _Go_, гласящая: "Не коммуницировать, разделяя память; вместо этого - разделять память, коммуницируя".

Для этого _Rust_ при помощи стандартной библиотеки предоставляет _каналы_. Канал - это обобщённый концепт, при помощи которого данные пересылаются из одного потока в другой.

Канал имеет две части: приёмник и передатчик. Канал считается _закрытым_ на время приёма или передачи.

`src/main.rs`:

```rust
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
}
```

Новый канал создаётся при помощи функции `mpsc::channel()`; `mpsc` - _multiple producer, single consumer_.

`mpsc::channel()` возвращает кортеж, первый элемент которого - передатчик, а второй - приёмник. Объявление `let` с паттерном, деструктуризирующем кортежи, используется в примере.

`src/main.rs`:

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });
}
```

`thread::spawn()` был использован для создания нового потока и затем `move`, чтобы переместить `tx` в замыкание так, чтобы новый поток владел `tx`. Рождённый поток должен владеть передатчиком, чтобы иметь возможность отправлять сообщения через канал. Передатчик имеет метод `.send()`, который принимает значение, которое мы хотим отправить. `.send()` возвращает тип `Result<T, E>`, так что если приёмник был отброшен и некуда отправлять значение, `.send()` вернёт ошибку. Мы также вызываем `.unwrap()` для аварийного завершения в случае ошибки.

`src/main.rs`:

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!("Got: {}", received);
}
```

Приёмник имеет два полезных метода: `.recv()`  и `.try_recv()`. `.recv` заблокирует выполнение потока и будет ждать, пока значение не окажется в канале. Как только значение будет отправлено и принято, `.recv()` вернёт `Result<T, E>`. Когда приёмопередатчик закрывается, `.recv()` возвращает ошибку, сигнализирующую о том, что никаких значений далее не последует.

`.try_recv()` не блокирует, а сразу возвращает `Result<T, E>`: вернётся `Ok`, хранящий в себе сообщение, если таковое доступно, и `Err`, если к моменту вызова `.try_recv()` сообщений на приём не ожидалось. Вызов `.try_recv()` полезен, если у потока есть ещё другая работа помимо ожидания сообщений: можно зациклить вызов `.try_recv()`.

__Каналы и передача владения__

Правила владения играют важную роль при отправке сообщений, поскольку они помогают писать безопасный конкурентный код. В примере ниже будет попытка использовать `val` для рождённого потока после того, как оно будет отправлено по каналу. Пример ниже не скомпилируется.

`src/main.rs`:

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
        println!("val is {}", val);
    });

    let received = rx.recv().unwrap();
    println!("Got: {}", received);
}
```

В примере мы пытаемся вывести `val` после того, как он был отправлен в канал при помощи `tx.send()`. Как только значение отправлено в другой поток, он может модифицировать его или же освободить. `.send()` овладевает параметром и, когда значение перемещено, уже получатель овладевает им.

__Отправка нескольких значений и наблюдение за ожиданием приёмника__

В примере ниже рождённый поток отправит несколько сообщений с промежутком в секунду между каждым.

`src/main.rs`:

```rust
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsx::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];
        
        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Got: {}", received);
    }
}
```

Рождённый поток имеет вектор строк, которые мы хотим отправить в основной поток. Мы итерируем их, отправляя каждую строку по отдельности и останавливаемся между отправками на секунду, вызывая `thread::sleep()` с `Duration` в `1` секунду.

В основном потоке мы уже не вызываем `.recv()`: вместо этого мы используем `rx` в качестве итератора. Когда канал закрывается, итерация заканчивается.

__Создание нескольких продуцирующих объектов при помощи клонирования передатчика__

В примере ниже мы отправим значения из нескольких потоков в один приёмник.

`src/main.rs`:

```rust
// ...
let (tx, rx) = mpsc::channel();

let tx1 = tx.clone();
thread::spawn(move || {
    let vals = vec![
        String::from("hi"),
        String::from("from"),
        String::from("the"),
        String::from("thread"),
    ];

    for val in vals {
        tx1.send(val).unwrap();
        thread::sleep(Duration::from_secs(1));
    }
});

thread::spawn(move || {
    let vals = vec![
        String::from("more"),
        String::from("messages"),
        String::from("for"),
        String::from("you"),
    ];

    for val in vals {
        tx.send(val).unwrap();
        thread::sleep(Duration::from_secs(1));
    }
});

for received in rx {
    println!("Got: {}", received);
}
// ...
```

В этот раз мы создаём первый поток и вызываем `.clone()` на передатчике. Так мы получим новый передатчик, который можно передать в первый рождённый поток. Мы передаём оригинальный передатчик также во второй рождённый поток. Это даёт нам два потока, каждый из которых отправляет разные сообщения одному приёмнику.

### 16.3. Конкуренция с разделяемым состоянием

Существует ещё один способ получения доступа нескольким потокам к одним данным.

Разделение памяти позволяет нескольким потокам получать доступ к той же памяти в одно время.

__Использование мьютексов для доступа к данным из одного потока в единицу времени__

_Мьютекс_ - аббревиатура от _mutual exclusion_ (взаимное исключение). Для доступа к данным в мьютексе, поток должен сначала запросить блокирование мьютекса. Замок в мьютексе - это структура данных, которая следит за тем, кто на данный момент данными пользуется.

Два правила, которым нужно следовать:

 + Нужно пытаться запросить блокирование до использования данных.
 + Когда произведены необходимые действия с данными, нужно разблокировать их так, чтобы другие потоки могли получить замок.

__API `Mutex<T>`__

Пример использования мьютекса в одном потоке.

`src/main.rs`:

```rust
use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!("m = {:?}", m);
}
```

Как и со многими другими типами, мы создаём `Mutex<T>`, используя ассоциированную функцию `new()`. Для доступа к данным внутри мьютекса, мы используем метод `.lock()`, чтобы заблокировать его. Это заблокирует текущий поток, пока мьютекс не будет разблокирован.

Вызов `.lock()` завершится с ошибкой, если другой поток удерживает замок в состоянии паники. В данном случае никто не сможет получить замок, так что мы используем `.unwrap()` и завершаем поток с паникой, если находимся в данной ситуации.

После получения замка, мы можем использовать вернувшееся значение `num`, как мутабельную ссылку на данные внутри. Система типов гарантирует, что мы получим замок до использования значения в `m`. Тип `m` - `Mutex<i32>`, не `i32`, так что мы должны вызвать `.lock()`, чтобы использовать значение `i32`.

`Mutex<T>` - умный указатель. Вызов `.lock()` возвращает умный указатель `MutexGuard`, обёрнутый в `LockResult`, который мы обрабатываем вызовом `.unwrap()`. Умный указатель `MutexGuard` имплементирует `Deref`, чтобы указывать на наши внутренние данные; данный умный указатель также имеет трейт `Drop`, который отпускает замок автоматически, когда `MutexGuard` выходит из области видимости. Так что нет риска забыть освободить замок и заблокировать мьютекс для использования другими потоками.

После освобождения замка, мы можем напечатать значение из мьютекса.

__Использование `Mutex<T>` несколькими потоками__

В 10-ти потоках будет попытка увеличить элемент на единицу. Код ниже не скомпилируется.

`src/main.rs`:

```rust
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];
    
    for _ in 0..10 {
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            
            *num += 1;
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("Result: {}", *counter.lock().unwrap());
}
```

Мы создаём переменную `counter`, которая содержит `i32` в `Mutex<T>`. Далее создаётся 10 потоков при помощи `thread::spawn()` и им передаётся одно и то же замыкание: оно перемещает счётчик в поток, получает замок для `Mutex<T>`, вызывая `.lock()` и затем добавляет единицу ко значению в мьютексе. Когда поток заканчивает свою работу, `num` выходит из области видимости и освобождает замок так, что другой поток может его использовать.

В основном потоке мы собираем обработчики потоков. Далее, мы вызываем `.join()` на каждом обработчике, чтобы удостовериться, что все потоки завершены. Здесь основной поток получит замок и выведет результат выполнения.

Но ошибка в том, что значение `counter` перемещается в каждом из предыдущих итераций цикла. Мы не можем переместить владение над `counter` во множество потоков.

__Множественное владение в нескольких потоках__

`Rc<T>` позволяет обернуть в себя `Mutex<T>` для множественного владения. Но, тем не менее, пример ниже тоже не скомпилируется.

`src/main.rs`:

```rust
use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.joun().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
```

Одно из сообщений компилятора может быть таким: `Rc<Mutex<i32>> cannot be sent between threads safely`. Далее компилятор называет причину: `the trait Send is not implemented for Rc<Mutex<i32>>`. Трейт `Send` - один из тех, которые удостоверяют нас в том, что используемые в потоках типы допустимы в ситуациях с конкурентностью.

`Rc<T>` небезопасен при использовании с потоками. Когда `Rc<T>` управляет количеством ссылок, он добавляет ко счётчику каждый вызов `clone()` и вычитает каждый раз, когда клон освобождается. Но он не использует примитивов для работы с многопоточностью, чтобы удостовериться в том, что изменения в счётчике не были изменены другим потоком. Это может привести к ошибкам с ложными значениями в счётчике, что приведёт к утечкам памяти или отбросу значений до завершения работы с ними.

__Атомарный подсчёт ссылок с `Arc<T>`__

`Arc<T>` - тип, похожий на `Rc<T>`, но безопасен при использовании с потоками. _a_ - _atomic_, т.е. _атомарно-ссылаемый счётный_ тип. Атомики - дополнительный тип примитивов для многопоточности. Для [подробностей](https://doc.rust-lang.org/std/sync/atomic/index.html) следует рассмотреть документацию стандартной библиотеки.

Безопасность в потоках сопряжена с накладными расходами в производительности.

`Arc<T>` и `Rc<T>` имеют схожий __API__.

`src/main.rs`:

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
```

Если производятся простейшие арифметические операции, существуют типы более простые, чем `Mutex<T>`, на которые стоит обратить внимание. См. модуль [`std::sync::atomic` стандартной библиотеки](https://doc.rust-lang.org/std/sync/atomic/index.html).

__Схожести между `RefCell<T>`/`Rc<T>` и `Mutex<T>`/`Arc<T>`__

`counter` в примере выше иммутабелен, но мы можем получить мутабельную ссылку на значение внутри; это значит, что `Mutex<T>` предоставляет внутреннюю мутабельность, как и семейство типов `Cell`. Так же, как мы, используя `RefCell<T>` ранее, могли изменять содержимое `Rc<T>`, мы используем `Mutex<T>`, чтобы изменить содержимое внутри `Arc<T>`.

Использование `Mutex<T>` создаёт риск создания дэдлоков. Это случается, когда операция нуждается в получении замка для двух ресурсов и два потока получили один из этих замков, что заставляет их ждать друг друга бесконечно.

### 16.4. Расширяемая конкуренция с трейтами `Sync` и `Send`

Два концепта конкуренции встроены в язык: трейты из `std::marker` `Sync` и `Send`.

__Разрешение передачи владений между потоками при помощи `Send`__

Трейт `Send` показывает, что владение над значениями типа, имплементирующего `Send`, могут быть переданы между потоками. Почти любой тип в _Rust_ имеет его, но есть некоторые исключения, среди которых `Rc<T>`: он не может иметь трейт `Send`, поскольку если мы склонировали значение `RC<T>` и попытались передать владение над клоном в другой поток, оба потока могут обновить счётчик ссылок в одно и то же время. По этой причине `Rc<T>` используется только в одном потоке.

Почти все примитивные типы имеют `Send`, кроме "сырых указателей".

__Разрешения доступа из множества потоков при помощи `Sync`__

`Sync` показывает нам, что на тип, имплементирующий данный трейт, безопасно ссылаться из разных потоков. Т.е. любой тип `T` - `Sync`, если `&T` - `Send`, что значит, что ссылка может быть безопасно отправлена в другой поток. Как и для `Send`, примитивные типы имеют `Sync` и типы, составленный целиком из типов с `Sync` также `Sync`.

Умный указатель `Rc<T>` не является `Sync` по той же причине, что и не имеет трейта `Send`. `RefCell<T>` и семейство типов `Cell<T>` также не имеют трейта `Sync`. Реализация проверки зависимостей, которую совершает `RefCell<T>` во время выполнения программы не потоко-безопасна. Умный указатель `Mutex<T>` имеет трейт `Sync`.

__Самостоятельная реализация `Send` и `Sync` небезопасна__

Поскольку составные типы, созданные из типов с трейтами `Send` и `Sync`, также имеют их, нам не нужно реализовывать данные трейты самостоятельно. Как маркирующие трейты, они не имеют даже методов.

Ручная имплементация данных трейтов задействует использование небезопасного кода _Rust_.

## 17. ООП в _Rust_

### 17.1. Характеристики ООП

__Объекты содержат данные и поведение__

> Объектно-ориентированные программы состоят из объектов. _Объект_ содержит в себе данные и процедуры, которые производят операции над этими данными. Процедуры обычно называются _методами_ или _операциями_.

Если следовать данному определению, _Rust_ объектно-ориентирован: структуры и перечисления содержат данные, `impl` предоставляют методы для структур и перечислений.

__Инкапсуляция скрывает детали реализации__

Ещё один аспект, связанный с __ООП__ - идея _инкапсуляции_, что означает, что детали реализации объекта недоступны из кода, использующего данный объект. Таким образом, единственный способ взаимодействия с объектом - через публичный __API__; код, использующий объект, не должен изменять данные и поведения напрямую. Это позволяет изменять и рефакторить внутренности объекта без необходимости исправлять код, использующий объект.

См. [[#7. Управление растущими проектами с использованием пакетов, "крэйтов" и модулей]]; мы можем использовать `pub`, чтобы решить, какие модули, типы, функции и методы в нашем коде будут публичными, а по-умолчанию всё остальное приватно.

`src/lib.rs`:

```rust
pub struct AveragedCollection {
    list: Vec<i32>,
    average: f64,
}
```

Структура помечена, как `pub`, так что другой код сможет её использовать, но поля структуры приватны. Операции над данными полями производим при помощи реализации методов `.add()`, `.remove()` и `.average()`.

`src/lib.rs`:

```rust
impl AveragedCollection {
    pub fn add(&mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&mut self) -> Option<i32> {
        let result = self.list.pop();
        match result {
            Some(value) => {
                self.update_average();
                Some(value)
            }
            None => None,
        }
    }

    pub fn average(&self) -> f64 {
        self.average
    }

    pub update_average(&mut self) {
        let total: i32 = self.list.iter().sum;
        self.average = total as f64 / self.list.len() as f64;
    }
}
```

Мы оставили поля `list` и `average` приватными, чтобы код из вне не мог их изменять, добавлять или удалять элементы в `list`; иначе, к примеру, `average` не будет соответствовать количеству элементов в `list`.

__Наследование, как система типов и как разделение кода__

_Наследование_ - механизм, когда объект может наследовать элементы из определения другого объекта, таким образом, получая данные и поведение родительского объекта без необходимости определять их снова.

В _Rust_ нет способа определить структуру, чтобы она наследовала поля и методы реализации родительской структуры без использования макросов.

Тем не менее, можно использовать другие решения _Rust_, в зависимости от причин, по которым возникла необходимость в наличии наследования.

Можно реализовать поведение для одного типа и наследовать его для других. Ограниченно сделать это позволяют трейты.

Ещё одна причина использования наследования связана с системой типов: для возможности использовать дочерний тип там же, где и родительский. Это называется _полиморфизмом_, что значит, что имеется возможность подменить несколько объектов друг другом во время выполнения программы, если они разделяют некоторые общие характеристики.

> __Полиморфизм__
> Для многих полиморфизм - синоним наследования. Но, на самом деле, это более обобщённый концепт, который ссылается на код, который может работать с данными разных типов. Для наследования, данные типы обычно - подклассы.
> _Rust_ вместо этого использует обобщения для абстракции от  разных возможных типов и привязок трейтов, чтобы наложить ограничения на то, что именно данные типы должны предоставить. Иногда это называется _привязанным параметрическим полиморфизмом_.

Вместо наследования в классическом смысле, _Rust_ использует _объекты трейтов_.

### 17.2. Использование объектов трейтов

Иногда нам нужно, чтобы пользователь нашей библиотеки мог расширить набор типов, валидный для конкретной ситуации.

Гипотетический пример - __GUI__-библиотека, реализующая класс `Component`, имеющий метод `draw`. Нам нужны будут и другие классы, например: `Button`, `Image`, `SelectBox` и т.д., которые будут наследниками `Component` и, таким образом, унаследуют метод `draw`. Но в _Rust_ нет наследования, потому нам нужен другой способ структуризации библиотеки `gui` для того, чтобы дать возможность пользователям расширять её новыми типами.

__Определение трейта для общего поведения__

Для определения поведения, которое нам нужно в `gui`, мы определим трейт `Draw`, который будет иметь единственный метод `.draw()`. Далее мы можем определить вектор, в который можно поместить _объекты трейта_. Объект трейта указывает на экземпляр типа, имплементирующего наш трейт и на таблицу, используемую для поиска методов трейта для нашего типа во время выполнения программы. Мы можем создать объект трейта, указав некоторый указатель, такой, как `&` ссылка или умный указатель `Box<T>`, далее - ключевое слово `dyn` и далее описывая релевантный трейт. Мы можем использовать объекты трейта вместо общих или конкретных типов. Каждый раз, при использовании объекта трейта, система типов _Rust_ будет удостоверяться в том, что любое значение, используемое в данном контексте, реализует трейт объекта трейта. Как следствие, нам не нужно знать о всех возможных типах во время компиляции.

Перечисления и структуры в _Rust_ не являются объектами (поведение в `impl` и данные сепарированы), хоть и могут иметь методы. Но объекты трейта больше похожи на объекты в других __ЯП__ в том смысле, что они комбинируют данные и поведение. Но объекты трейтов не могут добавлять к себе данных. Их основное назначение - абстракция над общим поведением.

`src/lib.rs`:

```rust
pub trait Draw {
    fn draw(&self);
}
```

Ниже мы определяем структуру `Screen`, хранящую вектор `components`. Тип элементов вектора - `Box<dyn Draw>`, что является объектом трейта; это обозначение любого типа внутри `Box`, у которого есть трейт `Draw`.

`src/lib.rs`:

```rust
pub struct Screen {
    pub components: Vec<Box<dyn Draw>>,
}
```

Для структуры `Screen` определим метод `.run()`, который вызовет `.draw()` для всех своих `components`.

`src/lib.rs`:

```rust
impl Screen {
    pub fn run(&self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
```

Это работает иначе, нежели определение структуры, использующей параметр обобщённого типа с привязкой к трейту. Параметр обобщённого типа может быть замещённым одним конкретным типом за раз, когда как объекты трейтов позволяют нескольким конкретным типам заполнить места объектов трейта во время выполнения программы. Пример ниже, когда мы используем структуру с обобщённым типом для `Screen`, ограничивает её экземпляр использованием компонентов только одного типа (либо `Button`, либо `TextField`, либо что-то иное).

`src/lib.rs`:

```rust
pub struct Screen<T: Draw> {
    pub components: Vec<T>,
}

impl<T> Screen<T>
where
    T: Draw,
{
    pub fn run(&self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
```

С использованием объектов трейта мы можем хранить в `Vec<T>` внутри `Screen` объекты разных типов: и `Box<Button>`, и `Box<TextField>`.

__Реализация трейта__

Теперь добавим несколько типов, имплементирующих `Draw`. Зададим тип `Button`.

`src/lib.rs`:

```rust
pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&self) {
// ...
    }
}
```

Поля `width`, `height` и `label` внутри `Button` могут отличаться от полей других компонентов. Каждый тип, который мы захотим "нарисовать" в __GUI__ будет иметь трейт `Draw`, но использовать, при этом, собственный код в методе `.draw()`. Тип `Button` также может иметь дополнительный блок `impl` с методами, связанными с действиями при нажатии на кнопку. Они не будут применены к другим типам.

Если некий пользователь нашей библиотеки решит реализовать структуру `SelectBox`, которая имеет поля `width`, `height` и `options`, он должен реализовать трейт `Draw` для `SelectBox`.

`src/main.rs`:

```rust
use gui::Draw;

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec<String>,
}

impl Draw for SelectBox {
    fn draw(&self) {
// ...
    }
}
```

Теперь пользователь нашей библиотеки может написать `main()` и создать экземпляр `Screen`. Для `Screen` он может добавить `SelectBox` и `Button`, поместив каждый в `Box<T>`, сделав из них объекты трейта. Далее можно выполнить метод `.run()` для `Screen`, что вызовет `.draw()` на каждом из компонентов.

`src/main.rs`:

```rust
use gui::{Button, Screen};

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from("Yes"),
                    String::from("Maybe"),
                    String::from("No"),
                ]
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from("OK"),
            }),
        ],
    };

    screen.run();
}
```

Данный концепт схож с концептом _утиной типизации_ в динамически-типируемых __ЯП__: если что-то ходит, как утка и крякает, как утка, то это - утка. `.run()` не должен знать о конкретном типе каждого компонента.

Пример ниже с попыткой создания `Screen` со `String` в качестве компонента не скомпилируется (`Screen` не реализует трейт `Draw`).

`src/main.rs`:

```rust
use gui::Screen;

fn main() {
    let screen = Screen {
        components: vec![Box::new(String::from("Hi"))],
    };

    screen.run();
}
```

__Объекты трейтов выполняют динамическую диспетчеризация__

Код, который является результатом мономорфизации при использовании обобщённых типов, производит _статическую диспетчеризацию_. Т.е. компилятор знает, какой метод вызывается во время компиляции. Это противоположность _динамической диспетчеризации_, при которой компилятор не может сказать во время компиляции, какой из методов вызывается.

При использовании объектов трейтов, _Rust_ должен использовать динамическую диспетчеризацию. Компилятор не знает обо всех типах, которые могут быть использованы с кодом, который использует объекты трейта, так что он не знает, какой метод имплементирован на каком типе. Вместо этого, во время выполнения, _Rust_ использует указатели внутри объекта трейта, чтобы узнать, какой метод вызвать. Данный поиск увеличивает нагрузку во время выполнения. Динамическая диспетчеризация также предотвращает использование встроенного кода метода в качестве выбора для компилятора, что предотвращает некоторые оптимизации. Вместо этого, мы позволяем коду быть более гибким.

### 17.3. Имплементация паттернов Объектно-Ориентированного Дизайна

_Паттерн состояния_ - это паттерн объектно-ориентированного дизайна. Суть паттерна - определение набора состояний, которые значение может иметь внутри себя. Состояния представляются набором _объектов состояний_, а поведение значения изменяется в зависимости от его состояния. В нашем примере будет структура "публикации" с состояниями "draft", "review" или "published".

Объекты состояний разделяют функционал. Каждый объект состояния ответственен за своё поведение и контроль того, когда состояние должно измениться. Значение, содержащее объект состояния ничего не знает о разном поведении состояний или о переходах между состояниями.

Иногда (напр., при изменении бизнес-логики) нам достаточно изменить код в одном из объектов состояний или добавить несколько.

Результат будет примерно таким:

 1. Публикация начинается, как пустой черновик.
 2. Когда черновик заполнен, требуется ревью публикации.
 3. Когда публикация утверждена, она публикуется.
 4. Только опубликованные публикации возвращают содержимое для печати, так что неутверждённые публикации не могут быть случайно опубликованы.

Любая другая попытка (в ином порядке) изменений публикации не должна иметь эффекта.

Код ниже не скомпилируется, поскольку у нас нет реализации крэйта `blog`.

`src/main.rs`:

```rust
use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");
    assert_eq!("", post.content());

    post.request_review();
    assert_eq!("", post.content());

    post.approve();
    assert_eq!("I ate a salad for lunch today", post.content());
}
```

Единственный тип, с которым приходится взаимодействовать - это `Post`. Этот тип будет использовать паттерн состояний и содержать значение, которое будет одним из трёх объектов состояния, представляющих разные состояния, в которых может находиться публикация. Смена состояний будет происходить внутри типа `Post`. Состояния меняются в ответ на вызов методов на экземпляре `Post` пользователем нашей библиотеки. Также у пользователя не должно получиться использовать состояния "неправильно".

__Определяем `Post` и создаём новый экземпляр в состоянии _Draft___

Помимо определения `Post`, создадим приватный трейт `State`, который определит поведение для всех объектов состояний, которые должен иметь `Post`.

`Post` получает объект трейта `Box<dyn State>` внутри `Option<T>` в приватном поле с именем `state`, в котором будет содержаться объект состояния.

`src/lib.rs`:

```rust
pub struct Post {
    state: Option<Box<dyn State>>,
    content: String,
}

impl Post {
    pub fn new() -> Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}

trait State {}

struct Draft {}

impl State for Draft {}
```

Объекты состояния: `Draft`, `PendingReview` и `Published`. Все они имеют трейт `State`.

При создании нового `Post`, мы устанавливаем его поле `state` в значение `Some`, содержащее `Box`. Данный `Box` указывает на новый экземпляр структуры `Draft`. По этой причине, при создании нового экземпляра `Post`, он сразу же будет в состоянии "draft". Поскольку `state` приватно, нет возможности создать `Post` в другом состоянии. `content` при вызове `Post::new()` устанавливается в пустую строку.

__Хранения текста содержания `Post`__

`src/lib.rs`:

```rust
impl Post {
// ...
    pub fn add_text(&mut self, text: &str) {
        self.content.push_str(text);
    }
}
```

`.add_text()` принимает мутабельную ссылку на `self`, поскольку мы изменяем экземпляр `Post`, на котором вызываем `.add_text()`. Далее вызываем `.push_str()` на `String` в `content` и передаём аргумент `text`, чтобы добавить к сохранённому в `content`. Данное поведение не зависит от состояния публикации, потому не является частью паттерна состояния. `.add_text()` не взаимодействует с полем `state`.

__Удостоверяемся, что содержание `Post`'а' _Draft_ пустое__

После вызова `.add_text()` и добавления содержимого, мы всё-ещё хотим, чтобы `.content()` возвращал пустой строковой слайс, поскольку публикация всё-ещё в черновике. `.content()` ниже будет всегда возвращать пустой строковой слайс. Данное поведение изменим позже, когда добавим возможность изменять состояние публикации.

`src/lib.rs`:

```rust
impl Post {
// ...
    pub fn content(&self) -> &str {
        ""
    }
}
```

__Запрос ревью публикации меняет её состояние__

Далее добавим функционал для запроса ревью публикации, который должен изменить её состояние с `Draft` на `PendingReview`.

`src/lib.rs`:

```rust
impl Post {
// ...
    pub fn request_review(&mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
}

trait State {
    fn request_review(self: Box<Self>) -> Box<dyn State>;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        self
    }
}
```

Здесь даём для `Post` публичный метод `.request_review()`, который принимает мутабельную ссылку на `self`. Далее вызываем внутренний метод `.request_review()` для текущего состояния `Post` и этот второй метод поглощает текущее состояние и возвращает новое.

Мы добавили `.request_review()` для трейта `State`; все типы, которые имеют данный трейт теперь должны реализовывать метод `.request_review()`. Вместо `self`, `&self` или `&mut self` мы передаём `self: Box<Self>`. Данный синтаксис означает, что метод валиден только для коробки. Данный синтаксис овладевает `Box<Self>`, инвалидируя старое состояние так, что состояние `Post` может трансформироваться в новое.

Для поглощения старого состояния, `.request_review()` должен овладеть значением состояния. Здесь на помощь приходит `Option` в поле `state` структуры `Post`: мы вызываем `.take()`, чтобы принять значение `Some` из поля `state` и оставить `None` на его месте, потому что _Rust_ не позволит нам иметь пустое поле в структуре. Это даёт нам возможность переместить значение `state` из `Post`, а не заимствовать его. Далее мы установим значение публикации `state` в качестве результата данной операции.

Нам нужно установить `state` в `None` опосредованно, а не напрямую, вызвав, к примеру, `self.state = self.state.request_review()`; чтобы получить владение над значением `state`. Это для того, чтобы `Post` не смог использовать старое значение `state` после его трансформации в новое.

`.request_review()` на `Draft` возвращает новый экземпляр новой структуры `PendingReview` в "коробке", что показывает, что состояние публикации - ожидание ревью. Структура `PendingReview` также реализует `.request_review()`, но не производит изменений состояния. Он возвращает самого себя, потому что когда мы запрашиваем ревью для публикации, находящейся в состоянии `PendingReview`, мы должны оставлять её в том же состоянии.

__Добавляем `approve` для изменения поведения `content`__

`.approve()` похож на `.request_review()`.

`src/lib.rs`:

```rust
impl Post {
// ...
    pub fn approve(&mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box<Self>) -> Box<dyn State>;
    fn approve(self: Box<Self>) -> Box<dyn State>;
}

struct Draft {}

impl State for Draft {
// ...
    fn approve(self: Box<Self>) -> Box<dyn State> {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
// ...
    fn approve(self: Box<Self>) -> Box<dyn State> {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        self
    }

    fn approve(self: Box<Self>) -> Box<dyn State> {
        self
    }
}
```

Мы добавили `.approve()` к трейту `State` и добавили новую структуру с трейтом `State`, представляющую состояние `Published`.

Подобно `.request_review()` для `PendingReview`, елси вызвать `.approve()` на `Draft`, не будет никакого эффекта, поскольку `.approve()` вернёт `self`. Когда вызываем `.approve()` на `PendingReview`, он возвращает новый экземпляр структуры `Published` в "коробке".

Теперь нужно обновить `.content()` для `Post`. Нам нужно, чтобы значение, вернувшееся из `.content()`, зависило от текущего состояния `Post`, так что нам нужно, чтобы `Post` делегировать для `.content()`, определённому на его `state`. Пример ниже не скомпилируется.

`src/lib.rs`:

```rust
impl Post {
// ...
    pub fn content(&self) -> &str {
        self.state.as_ref().unwrap().content(self)
    }
// ...
}
```

Поскольку нужно хранить все эти правила внутри структур, которые имплементируют `State`, мы можем вызывать `.content()` на значениях в `state` и передать экземпляр публикации (`self`) в качестве аргумента. Затем возвращаем значение, которое приходит нам от `.content()` на значении `state`.

Мы вызываем `.as_ref()` на `Option`, поскольку хотим ссылку на значение внутри `Option`, а не овладеть значением. Поскольку `state` - `Option<Box<dyn State>>`, когда мы вызываем `.as_ref()`, возвращается `Option<&Box<dyn State>>`. Если мы не вызовем `.as_ref()`, мы получим ошибку, поскольку мы не можем переместить `state` из позаимствованного параметра функции `&self`.

Далее вызываем `.unwrap()`, который никогда не вызовет паники, поскольку мы знаем, что методы на `Post` удостоверяются в том, что `state` всегда будет содержать значение `Some`, когда эти методы завершаются.

Теперь, когда вызываем `.content()` на `&Box<dyn State>`, принуждение к разыменованию повлияет на `&` и `Box`, так что `.content()` может быть вызван на типе, который имплементирует трейт `State`. Это значит, что нам нужно добавить `.content()` в определение трейта `State`, чтобы мы смогли уложить логику для того, какое содержимое вернуть в зависимости от того, какое состояние имеем сейчас.

`src/lib.rs`:

```rust
trait State {
// ...
    fn content<'a>(&self, post: &'a Post) -> &'a str {
        ""
    }
}
// ...
struct Published {}

impl State for Published {
// ...
    fn content<'a>(&self, post: &'a Post) -> &'a str {
        &post.content
    }
}
```

Мы добавили стандартную реализацию `.content()`, которая возвращает пустой строковой слайс. Это значит, что нам не нужно реализовывать `.content()` на `Draft` и `PendingReview`. `Published` переопределит метод `.content()` и вернёт значение в `post.content`.

Для данного метода нужна аннотация времени жизни. Мы взяли ссылку на `post` в качестве аргумента и вернули ссылку на часть этого `post`, так что время жизни на вернувшейся ссылки связано со временем жизни аргумента `post`.

> __Почему не `enum`?__
> Почему же не используется `enum` с различными возможными состояниями публикации в качестве вариантов? Это является возможным решением. Но один минус использования перечислений - в каждом месте, которое проверяет его, нужно выражение `match` или нечто подобное для проверки каждого варианта.

__Компромиссы при использовании паттерна состояний__

С помощью паттернов состояний, методы `Post` и места, в которых `Post` используются, могут не иметь выражений `match` и, для того, чтобы добавить новое состояние, нам достаточно добавить новую структуру и реализовать для неё методы трейта.

Реализацию, использующую паттерн состояний легче расширить и добавить больше функциональности. Например, для кода выше, можно попробовать:

 + Добавить `.reject()`, который меняет состояние с `PendingReview` на `Draft`.
 + Запросить два вызова `.approve()`, чтобы состояние могло быть изменено на `Published`.
 + Дать возможность пользователям добавлять наполнение публикации только когда она находится в состоянии `Draft`. _Подсказка_: можно создать объект состояния, который отвечает за то, что можно изменить в содержимом публикации, но не отвечает за модификацию `Post`.

Минус паттерна состояний в том, что по причине того, что состояние реализуют переход между состояниями, некоторые состояния спариваются друг с другом. Для примера выше, если добавить состояние `Scheduled` между `PendingReview` и `Published`, нам придётся менять код в `PendingReview` для перехода в `Scheduled`.

Ещё один минус - дублирование логики. Для того, чтоб избавиться от неё, можно попытаться создать стандартные реализации для `.request_review()` и `.approve()` на трейте `State`, которые возвращают `self`; тем не менее, это нарушит безопасность объектов, поскольку трейт не знает, чем может быть `self`.

Другие дублирования выражаются в одинаковых реализациях `.request_review()` и `.approve()` на `Post`. Оба метода делегируются реализациям одного и того же метода на значении в поле `state` `Option` и устанавливают новое значение `state` в качестве результата. Если бы у нас было много методов для `Post`, которые следуют данному паттерну, нам бы, возможно, пришлось использовать макросы, чтобы избавиться от повторений.

__Кодируем состояния и поведения, как типы__

Переосмыслим паттерн состояний. Вместо инкапсуляции состояний и переходов, мы закодируем состояния в другие типы. Как следствие, система проверки типов _Rust_ предотвратит попытки использования черновых публикаций там, где могут быть использованы только опубликованные посты, на этапе компиляции.

`src/main.rs`:

```rust
fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");
    assert_eq!("", post.content());
}
```

Мы всё-ещё можем создавать новые публикации в состоянии черновика при помощи `Post::new()` и возможности добавить текст в содержимое публикации. Но, вместо метода `.content()` на черновой публикации, который возвращает аустую строку, мы сделаем так, что черновые публикации не будут иметь метода `.content()` вообще. Таким образом, если мы попытаемся получить содержимое черновой публикации, мы получим ошибку компиляции.

`src/lib.rs`:

```rust
pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
    pub fn new() -> DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&self) -> &str {
        &self.content
    }
}

impl DraftPost {
    pub fn add_text(&mut self, text: &str) {
        self.content.push_str(text);
    }
}
```

`Post` и `DraftPost` имеют приватное поле `content`. Структуры больше не имеют поля `state`, потому что они перемещают закодированное состояние в типы структур. `Post` будет представлять опубликованный текст и иметь `.content()`, возвращающий `content`.

Всё-ещё есть функция `Post::new()`, но вместо возврата экземпляра `Post`, она вернёт экземпляр `DraftPost`. Поскольку `content` приватен и нету функции, которая вернёт `Post`, невозможно создать экземпляр `Post` в данный момент.

`DraftPost` имеет `.add_text()`, так что мы можем добавить текст в `content`, как и раньше, но `DraftPost` не имеет определения метода `.content()`. Теперь программа удостоверена в том, что все публикации начинают с состояния черновика и, что черновые публикации не имеют содержимого, доступного для вывода.

__Реализация переходов, как трансформаций в другие типы__

Теперь нам нужно правило, при котором черновые публикации должны быть рассмотрены и утверждены перед публикацией. Публикация в состоянии ожидания рассмотрения всё-ещё не должна выводить содержимого. Реализуем эти ограничения, добавив структуру `PendingReviewPost`, определяющую `.request_review()` на `DraftPost`, чтобы вернуть `PendingReviewPost` и определим `.approve()` на `PendingReviewPost`, чтобы вернуть `Post`.

`src/lib.rs`:

```rust
impl DraftPost {
// ...
    pub fn request_review(self) -> PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -> Post {
        Post {
            content: self.content,
        }
    }
}
```

`.request_review()` и `.approve()` овладевают `self`, таким образом поглощая `DraftPost` и `PendingReviewPost` и трансформируя их в `PendingReviewPost` и опубликованный `Post`. Так, у нас не будет задержки экземпляров `DraftPost` после вызова `.request_review()` на них и т.д. `PendingReviewPost` не имеет `.content()`,так что попытка чтения содержимого повлечёт ошибку компилирования, как и с `DraftPost`. Поскольку единственный способ получить опубликованный `Post`, который не имеет метода `.content()` - это вызов `.approve()` на `PendingReviewPost` и единственный способ получить `PendingReviewPost` - это вызов `.request_review()` на `DraftPost`, у нас теперь есть закодированный в систему типов "воркфлоу" публикаций.

Но нужно также внести несколько изменений в `main()`. `.request_review()` и `.approve()` возвращают новые экземпляры, а не модифицируют структуры, для которых были вызваны, так что нам нужно добавить больше затеняющих присваиваний `let post =` для сохранения возвращённых экземпляров. Мы также не можем проверять содержимое черновых и ожидающих ревью публикаций на пустые строки (но данная проверка теперь нам не нужна): мы не можем скомпилировать код, который пытается использовать содержимое публикаций в данных состояниях.

`src/main.rs`:

```rust
use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");

    let post = post.request_review();

    let post = post.approve();

    assert_eq!("I ate a salad for lunch today", post.content());
}
```

В `main()` нам нужно переназначить `post`, поскольку теперь данная реализация не совсем следует объектно-ориентированным паттернам состояний: трансформация между состояниями теперь не инкапсулирована полностью внутри `Post`. Тем не менее, теперь невозможны невалидные состояния, поскольку проверка типов происходит во время компиляции.

## 18. Паттерны и совпадения

_Паттерны_ - специальный синтаксис в _Rust_ для подбора совпадений в структурах типов. Использование паттернов с `match` и другими конструкциями даёт больше контроля над программой. Паттерн состоит из комбинаций, включающих в себя:

 + Литеры
 + Деструктуризированные массивы, перечисления, структуры или кортежи
 + Переменные
 + Подстановочные знаки
 + Плейсхолдеры

Некоторые примеры: `x`, `(a, 3)` `Some(Color::Red)`. В контексте, при которых паттерны валидны, эти компоненты можно описать, как очертание данных. Наша программа сравнивает значения с паттернами, чтобы понять, подходят ли они под эти очертания.

### 18.1. Все использования паттернов

__Ветви `match`__

Формально, выражения `match` определены, как ключевое слово `match`, значение для сравнения и одна или более ветвь сравнения, состоящая из паттерна и выражения для выполнения, если значение совпало с паттерном ветви:

```
match VALUE {
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
}
```

```rust
match x {
    None => None,
    Some(i) => Some(i + 1),
}
```

Требование для выражений `match` в том, что они должны быть _всеобъемлющими_. Все возможные значения для значения в выражении `match` должны учитываться. Один из способов - использовать паттерн охвата всего (`_`) в последней ветке.

__Условные выражения `if let`__

`if let` может иметь соответствующий `else`.

`src/main.rs`:

```rust
fn main() {
    let favorite_color: Option<&str> = None;
    let is_tuesday = false;
    let age: Result<u8, _> = "34".parse();

    if let Some(color) = favorite_color {
        println!("Using your favorite color, {color}, as the background");
    } else if is_tuesday {
        println!("Tuesday is green day!");
    } else if let Ok(age) = age {
        if age > 30 {
            println!("Using purple as the background color");
        } else {
            println!("Using orange as the background color");
        }
    } else {
        println!("Using blue as the background color");
    }
}
```

В примере выше будет выведено `Using purple as the background color`. `if let Ok(age) = age` вводит новую затенённую переменную `age`, которая содержит значение внутри варианта `Ok`. Мы не можем скомбинировать в блоке `if let Ok(age) = age && age > 30`. Затенённый `age` невалиден, пока новая область видимости не введётся.

__Условные циклы `while let`__

Цикл `while` будет запущен, пока паттерн совпадает.

```rust
let mut stack = Vec::new();

stack.push(1);
stack.push(2);
stack.push(3);

while let Some(top) = stack.pop() {
    println!("{}", top);
}
```

__Циклы `for`__

Значение, следующее за `for` - паттерн. В `for x in y` `x` - паттерн.

```rust
let v = vec!['a', 'b', 'c'];

for (index, value) in v.iter().enumerate() {
    println!("{} is at index {}", value, index);
}
```

В примере выше `.enumerate()` пакует индекс и значение для очередного элемента в кортеж.

__Объявления `let`__

```rust
let x = 5;
```

Формализация `let`:

```
let PATTERN = EXPRESSION;
```

В `let x = 5` `x` - паттерн, означающий "привязать что угодно, что подходит к переменной `x`". `x` - целый паттерн, потому: "привязать что угодно к переменной `x` и без разницы, чем является значение".

В примере ниже - паттерн, деструктуризирующий кортеж.

```rust
let (x, y, z) = (1, 2, 3);
```

_Rust_ сравнит значение `(1, 2, 3)` с паттерном `(x, y, z)` и увидит, что значение с паттерном совпадает, так что `1` привязывается к `x`, `2` -к `y` и `3` - к `z`.

В примере ниже получим компиляцию из-за несовпадения паттерна и количества элементов в кортеже (деструктуризация кортежа из 3-х элементов в две переменные):

```rust
let (x, y) = (1, 2, 3);
```

Для исправления ошибки можно проигнорировать одно или несколько значений в кортеже, используя `_` или `..`.

__Параметры функций__

```rust
fn foo(x:i32) {
// ...
}
```

`x` в примере выше - паттерн. И, как и с `let`, можно сравнивать кортеж в аргументах функции с паттерном. Пример ниже разбивает значения в кортеже, когда передаём его функции.

`src/main.rs`:

```rust
fn print_coordinates(&(x, y): &(i32, i32)) {
    println!("Current location: ({}, {})", x, y);
}

fn main() {
    let point = (3, 5);
    print_coordinates(&point);
}
```

`&(3, 5)` совпадает с паттерном `&(x, y)`.

Для замыканий паттерны можно использовать подобным образом.

### 18.2. Опровержимость: когда паттерн не совпадает

Паттерны могут иметь две формы: опровержимые и неопровержимые. Паттерны, подходящие под любое возможное значение _неопровержимы_. Пример: `x` в выражении `let x = 5`, поскольку `x` подходит ко всему. Паттерны, которые могут не подойти к одному или более из возможных значений, _опровержимы_. Пример: `Some(x)` в выражении `if let Some(x) = a_value`, потому что если значение переменной `a_value` - `None`, а не `Some`, паттерн `Some(x)` не совпадёт.

Параметры функций, объявления `let` и циклы `for` принимают только неопровержимые паттерны, поскольку программа не сможет сделать ничего полезного, когда значения не совпадают с ними. Выражения `if let` и `while let` принимают и опровержимые, и неопровержимые паттерны, но компилятор предупреждает при использовании неопровержимых паттернов, потому что по определению они не предназначены для обработки возможных ошибок: функциональность условных операторов заключается в их возможности действовать в зависимости от успеха или неуспеха.

Пример ниже не скомпилируется, поскольку `let` пытается взаимодействовать с опровержимым паттерном `Some(x)`:

```rust
let Some(x) = some_option_value;
```

Если бы `some_option_value` имел значение `None`, оно бы не совпало с паттерном `Some(x)`. Мы не можем "покрыть" все валидные значения в паттерне `Some(X)`.

Для исправления можно использовать `if let`. Тогда, если паттерн не совпадает, код просто пропустит всё находящееся в фигурных скобках:

```rust
if let Some(x) = some_option_value {
    println!("{}", x);
}
```

Для кода ниже компилятор выдаст предупреждение (паттерн всегда совпадает):

```rust
if let x = 5 {
    println!("{}", x);
};
```

### 18.3. Синтаксис паттернов

__Совпадение с литерами__

```rust
let x = 1;

match x {
    1 => println!("one"),
    2 => println!("two"),
    3 => println!("three"),
    _ => println!("anything"),
}
```

__Совпадение с именованными переменными__

Поскольку `match` организует новую область видимости, переменные, объявленные, как часть паттерна внутри выражения `match`, будут затенять те, что имеют схожее имя вне конструкции `match`, как в случае со всеми переменными.

`src/main.rs`:

```rust
let x = Some(5);
let y = 10;

match x {
    Some(50) => println!("Got 50"),
    Some(y) => println!("Matched, y = {y}"),
    _ => println!("Default case, x = {:?}", x),
}

println!("at the end: x = {:?}, y = {y}", x);
```

Вторая ветвь представляет новую переменную `y`, которая совпадёт с любым значением внутри `Some`. По этой причине выполнится вторая ветвь. Поскольку мы открыли новую область видимости внутри выражения `match`, создаётся новая переменная `y`. `y` внутри `match` затеняется.

`x` в выражении - всё-ещё внешняя переменная `x`.

Чтобы создать `match`, которое сравнило бы внешние `x` и `y`, нам нужно использовать защиту совпадений.

__Несколько паттернов__

Можно использовать несколько паттернов, используя оператор `|` "или" для паттернов.

```rust
let x = 1;

match x {
    1 | 2 => println!("one or two"),
    3 => println!("three"),
    _ => println!("anything"),
}
```

__Совпадение с диапазонами значений при помощи `..=`__

Синтаксис `..=` позволяет сравнивать включительный диапазон значений (когда паттерн совпадает с одним из значений из диапазона):

```rust
let x = 5;

match x {
    1..=5 => println!("one through five"),
    _ => println!("something else"),
}
```

В примере выше выполнится первая ветвь.

Диапазоны можно использовать только с числами или `char`.

```rust
let x = 'c';

match x {
    'a'..='j' => println!("early ASCII letter"),
    'k'..='z' => println!("late ASCII letter"),
    _ => println!("something else"),
}
```

__Деструктуризация для разбиения значений__

__Деструктуризация структур__

`src/main.rs`:

```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
```

Код выше создаёт переменные `a` и `b`, которые соответствуют значениям полей `x` и `y` структуры `p`.

Пример ниже аналогичен примеру выше:

`src/main.rs`:

```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}
```

Код создаёт переменные `x` и `y`, совпадающие с полями `x` и `y` переменной `p`.

Можно также деструктуризовать с литерами, как частями паттерна структуры, вместо создания переменных для всех полей.

В примере ниже выражение `match` сепарирует значения `Point` для трёх случаев.

`src/main.rs`:

```rust
fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } => println!("On the x axis at {x}"),
        Point { x: 0, y } => println!("On the y axis at {y}"),
        Point { x, y } => {
            println!("On neither axis: ({x}, {y})");
        }
    }
}
```

Паттерны в примере выше внутри `match` создают и переменные `x`, и переменные `y`.

Для (0, 0) выполнится первое совпадение.

__Деструктуризация перечислений__

В примере ниже `match` деструктуризирует каждое внутреннее значение перечисления.

`src/main.rs`:

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit => {
            println!("The Quit variant has no data to destructure.");
        }
        Message::Move { x, y } => {
            println!("Move in the x direction {x} and in the y direction {y}");
        }
        Message::Write(text) => {
            println!("Text message: {text}");
        }
        Message::ChangeColor(r, g, b) => {
            println!("Change the color to red {r}, green {g}, and blue {b}",)
        }
    }
}
```

__Деструктуризация вложенных структур и перечислений__

```rust
enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) => {
            println!("Change color to red {r}, green {g}, and blue {b}");
        }
        Message::ChangeColor(Color::Hsv(h, s, v)) => {
            println!("Change color to hue {h}, saturation {s}, value {v}")
        }
        _ => (),
    }
}
```

Для примера выше паттерн первой ветки `match` проверяет перечисление `Message::ChangeColor` на вариант `Color::Rgb`; далее паттерн привязывается к трём внутренним значениям `i32`. Паттерн второй ветви также сверяет вариант перечисления `Message::ChangeColor`, но внутреннее перечисление должно совпадать с вариантом `Color::Hsv`.

__Деструктуризация структур и кортежей__

Пример ниже демонстрирует сложную деструктуризацию, где мы вкладываем структуры и кортежи в кортеж и деструктурируем все примитивные значения вовне:

```rust
let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
```

__Игнорирование значений в паттерне__

Есть несколько способов игнорировать целые значения или части значений в паттерне: используя паттерн `_`, используя паттерн `_` внутри другого паттерна, используя имя, которое начинается с `_` или используя `..`, чтобы игнорировать оставшуюся часть значения.

__Игнорирование значения целиком при помощи `_`__

До этого `_` использовался, как паттерн подстановочного знака, который совпадёт с любым значением, но не привязывается к нему.

`src/main.rs`:

```rust
fn foo(_: i32, y: i32) {
    println!("This code only uses the y parameter: {}", y);
}

fn main() {
    foo(3, 4);
}
```

Код выше проигнорирует значение `3`, переданное в качестве первого аргумента.

Игнорирование параметра функции может быть полезно когда, к примеру, реализуется трейт, где нужна определённая сигнатура типа, но тело функции внутри реализации не нуждается в одном из параметров.

__Игнорирование частей значения при помощи вложенных `_`__

Мы можем использовать `_` внутри других паттернов, чтобы игнорировать часть значения. К примеру, когда мы хотим проверить только часть значения, но для остальной части применения в коде нет.

```rust
let mut setting_value = Some(5);
let new_setting_value = Some(10);

match (setting_value, new_setting_value) {
    (Some(_), Some(_)) => {
        println!("Can't overwrite an existing customized value");
    }
    _ => {
        setting_value = new_setting_value;
    }
}

println!("setting is {:?}", setting_value);
```

Код выше выведет `Can't overwrite an existing customized value` и далее `setting is Some(5)`. В первой ветви `match` нам не нужно искать совпадения или использовать значения из вариантов `Some`, но они нам нужны, чтобы проверить случай, когда `setting_value` и `new_setting_value` - варианты `Some`. В данном случае, мы выведем причину, по которой не меняется `setting_value`.

Во всех других случаях (если `setting_value` или `new_setting_value` - `None`), выраженных при помощи паттерна `_` во второй ветви, нам может понадобиться, чтобы `new_setting_value` приняло значение `setting_value`.

Мы также можем использовать `_` в нескольких местах одного паттерна, чтобы игнорировать конкретные значения.

```rust
let numbers = (2, 4, 8, 16, 32);

match numbers {
    (first, _, third, _, fifth) =? {
        println!("Some numbers: {first}, {third}, {fifth}")
    }
}
```

Код выше выведет `Some numbers: 2, 8, 32` и проигнорирует `4` и `16`.

__Игнорирование неиспользуемых значений, именуя их с `_` в самом начале__

Иногда может быть полезно иметь возможность создать переменную, которая пока не используется (к примеру, при прототипировании или старте проекта). В данной ситуации можно попросить _Rust_ не выводить предупреждения о неиспользуемых переменных, начиная имя переменной с нижнего подчёркивания. Для примера ниже предупреждение будет только для одной переменной.

`src/main.rs`:

```rust
fn main() {
    let _x = 5;
    let y = 10;
}
```

Синтаксис `_x` всё-ещё привязывает значение к переменной, когда как просто `_` не привязывается ни к чему. Пример ниже данное поведение демонстрирует (не скомпилируется):

```rust
let s = Some(String::from("Hello!"));

if let Some(_s) = s {
    println!("found a string");
}

println!("{:?}", s);
```

Мы получим ошибку, потому что значение `s` будет перемещено в `_s`, что не даст нам использовать `s` снова. Но использование `_` не привязывает ко значению. Пример ниже скомпилируется, поскольку `s` не перемещается в `_`:

```rust
let s = Some(String::from("Hello!"));

if let Some(_) = s {
    println!("found a string");
}

println!("{:?}", s);
```

__Игнорирование оставшихся частей значения при помощи `..`__

Со значениями, имеющими множество частей, мы можем использовать синтаксис `..`, чтобы использовать конкретную часть и игнорировать остальное, избегая необходимости использовать `_` для каждого игнорируемого значения. Паттерн `..` игнорирует любые части значения, которые не совпадают с оставшейся частью паттерна. В примере ниже в выражении `match` мы оперируем только координатой `x` и игнорируем значения в полях `y` и `z`:

```rust
struct Point {
    x: i32,
    y: i32,
    z: i32,
}

let origin = Point { x: 0, y: 0, z: 0 };

match origin {
    Point { x, .. } => println!("x is {}", x),
}
```

Синтаксис `..` расширится в то количество значений, в которое нужно. Ниже пример использования с кортежами. Будет проигнорировано всё, что находится между первым и последним элементами.

`src/main.rs`:

```rust
fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) => {
            println!("Some numbers: {first}, {last}");
        }
    }
}
```

Если мы неизвестно, какие  значения нужны для сверки, а какие должны игнорироваться, _Rust_ выдаст ошибку. Пример ниже не скомпилируется.

`src/main.rs`:

```rust
fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) => {
            println!("Some numbers: {}", second)
        },
    }
}
```

В примере выше _Rust_ не может определить, сколько значений в кортеже нужно проигнорировать до совпадения значения с `second` и сколько игнорировать после.

__Дополнительные условия и защита совпадений__

_Защита совпадений_ - дополнительное условие `if`, указанное после паттерна в ветви `match`, которое также должно совпадать с выбранной ветвью. Они полезны для выражения более сложных идей.

Условие может использовать переменные, созданные в паттерне. Пример ниже демонстрирует `match`, в котором первая ветвь имеет паттерн `Some(x)` и также защиту совпадений `if x % 2 == 0`:

```rust
let num = Some(4);

match num {
    Some(x) if x % 2 == 0 => println!("The number {} us even", x),
    Some(x) => println!("The number {} is odd", x),
    None => (),
}
```

Пример выше выведет `The number 4 is even`. Когда `num` сравнивается с паттерном в первой ветви, он совпадает, поскольку `Some(4)` совпадает с `Some(x)`. Далее защита совпадений проверяет, является ли остаток от деления на `2` нулём или нет.

Будб `num` `Some(5)`, защита совпадений в первой ветви была бы ложной. Тогда _Rust_ переходит к следующей ветви.

Выразить условие `if x % 2 == 0` в паттерне не получится, так что защита совпадений даёт возможность выразить данную логику. Минус - компилятор не пытается проверить всеобщность, когда сталкивается с защитой совпадений.

Защиту совпадений можно использовать для решения проблем с затенением переменных.

`src/main.rs`:

```rust
fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) => println!("Got 50"),
        Some(n) if n == y => println!("Matched, n = {n}"),
        _ => println!("Default case, x = {:?}", x),
    }

    println!("at the end: x = {:?}, y = {y}", x)
}
```

В примере выше паттерн во второй ветви не представляет новой переменной `y`, которая затенит внешнюю `y`, что значит, что мы можем использовать внешнюю `y` внутри защиты совпадений. Вместо определения паттерна, как `Some(y)`, что затенило бы внешнюю `y`, мы определяем `Some(n)`. Так создаётся новая переменная `n`, которая ничего не затеняет.

Защита совпадений `if n == y` не является паттерном и, соответственно, не вводит новых переменных.

Можно использовать оператор `|` в защите совпадений, чтобы определить несколько паттернов; если условие в защите совпадений выполнится, оно выполнится для всех паттернов.

```rust
let x = 4;
let y = false;

match x {
    4 | 5 | 6 if y => println!("yes"),
    _ => println!("no"),
}
```

Для примера выше вывод будет `no`.

Ниже несколько вариаций.

```
(4 | 5 | 6) if y => ...
```

```
4 | 5 | (6 if y) => ...
```

__Привязки `@`__

Оператор `@` позволяет создавать переменную, которая содержит значение и, в то же время, мы проверяем данное значение на совпадение с паттерном. В примере ниже мы хотим проверить поле `id` `Message::Hello` на совпадение с диапазоном `3..=7`. Мы также хотим привязать значение к переменной `id_variable` так, что мы потом сможем использовать её в коде, ассоциированном с ветвью.

```rust
enum Message {
    Hello { id: i32 },
}

let msg = Message::Hello { id: 5 };

match msg {
    Message::Hello {
        id: id_variable @ 3..=7.
    } => println!("Found an id in range: {}", id_variable),
    Message::Hello { id: 10..=12 } => {
        println("Found an id in another range")
    }
    Message::Hello { id } => println!("Found some other id: {}", id),
}
```

Пример выше выведет `Found an id in range: 5`. Указав `id_variable @` до диапазона `3..=7`, мы захватываем любое значение, совпадающее с диапазоном и также проверяем, что значение совпало с паттерном диапазона.

Во второй ветви, где у нас указан только диапазон в паттерне, код, ассоциированный с ветвью не имеет переменной, которая содержит значение поля `id`. Значение поля `id` могло бы быть `10`, `11` или `12`, но код, который идёт вместе с паттерном, не знает, какое из них. Код паттерна не может использовать значение из поля `id`, поскольку мы не сохранили значение `id` в переменную.

Любое значение подойдёт для паттерна из третьей ветви.

`@` позволяет нам проверять значение и сохранить её в переменной одним паттерном.

## 19. Продвинутые возможности

### 19.1. "Небезопасный" _Rust_

__Небезопасные возможности__

Для переключения в небезопасный режим _Rust_, используется ключевое слово `unsafe` и последующий блок небезопасного кода. Для небезопасного кода доступно следующее:

 + Разыменование сырых указателей
 + Вызов небезопасной функции или метода
 + Доступ к или модификация мутабельной статической переменной
 + Реализация небезопасного трейта
 + Доступ к полям `union`'ов

`unsafe` не отключает проверок безопасности, но позволяет использовать вышеперечисленные возможности.

Для изоляции небезопасного кода желательно помещать его в безопасные абстракции и предоставлять безопасный __API__.

__Разыменование сырого указателя__

_Сырые указатели_ схожи со ссылками. Как и с ними, сырые указатели могут быть мутабельными и иммутабельными и указываются, как `*const T` и `*mut T`. `*` - часть имени типа. В контексте сырых указателей, _иммутабельный_ значит, что указатель не может быть назначен напрямую после разыменования.

Отличия сырых указателей от умных указателей и ссылок:

 + Они могут игнорировать правила заимствования, имея иммутабельные и мутабельные указатели или несколько мутабельных указателей на один участок
 + Они не гарантированно указывают на валидную память
 + Могут быть null
 + Не реализуют автоматической очистки

Пример ниже показывает, как создать иммутабельный и мутабельный сырой указатель из ссылок:

```rust
let mut num = 5;

let r1 = &num as *const i32;
let r2 = &mut num as *mut i32;
```

Сырые указатели могут быть созданы в области безопасного кода; но разыменовывать их вне блока небезопасного кода нельзя.

Используя `as`, мы транслируем иммутабельные и мутабельные ссылки в соответствующие типы сырых указателей.

Пример ниже показывает, как создать сырой указатель на адрес в памяти. Поведение при использовании случайного адреса не определено: по данному адресу могут находиться данные, компилятор может оптимизировать код так, что к участку не будет доступа или может возникнуть ошибка сегментации:

```rust
let address = 0x012345usize;
let r = address as *const i32;
```

Пример ниже показывает, как разыменовать сырой указатель внутри блока `unsafe`:

```rust
let mut num = 5;

let r1 = &num as *const i32;
let r2 = &mut num as *mut i32;

unsafe {
    println!("r1 is: {}", *r1);
    println!("r2 is: {}", *r2);
}
```

__Вызов небезопасных функций или методов__

Небезопасные функции и методы имеют дополнительно `unsafe` перед определением.

```rust
unsafe fn dangerous() {}

unsafe {
    dangerous();
}
```

Для примера выше, мы должны вызывать `dangerous()` внутри отдельного блока `unsafe`.

__Создание безопасной абстракции над небезопасным кодом__

Если функция содержит небезопасный код, нам не обязательно помечать функцию целиком, как небезопасную. Пример - часть функции `split_at_mut()` из стандартной библиотеки.

```rust
let mut v = vec![1, 2, 3, 4, 5, 6];

let r = &mut v[..];

let (a, b) = r.split_at_mut(3);

assert_eq!(a, &mut [1, 2, 3]);
assert_eq!(b, &mut [4, 5, 6]);
```

Пример ниже не скомпилируется:

```rust
fn split_at_mut(values: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
    let len = values.len();

    assert!(mid <= len);

    (&mut values[..mid], &mut values[mid..])
}
```

Функция в примере выше сначала получает общую длину слайса. Далее проверяет, что индекс, переданный через параметр внутри слайса, проверив, равен он длине или нет. Проверка значит, что если мы передаём индекс больший, чем длина, на которую нужно разбить слайс, функция "запаникует" до попытки использования индекса.

Далее мы возвращаем два мутабельных слайса в кортеже: один от начала оригинального слайса до индекса `mid`, второй - от `mid` и до конца слайса.

Проверка заимствований в _Rust_ не может понять, что мы заимствуем две разных части слайса; она знает только то, что мы заимствуем из однного слайса дважды.

Реимплементация с использованием небезопасного кода:

```rust
use std::slice;

fn split_at_mut(values: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
    let len = values.len();
    let ptr = valuse.as_mut_ptr();

    assert!(mid <= len);

    unsafe {
        (
            slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}
```

`slice::from_raw_parts_mut()` принимает сырой указатель и длину и создаёт слайс. `.add()` на сырых указателях также небезопасен.

Полностью помечать `split_at_mut()`, как `unsafe`, не обязательно.

В противовес, в примере ниже `slice::from_raw_parts_mut()` наиболее вероятно "упадёт":

```rust
use std::slice;

let address = 0x01234usize;
let r = address as *mut i32;

let values: &[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
```

__Использование функций `extern` для вызова внешнего кода__

_Rust_ имеет ключевое слово `extern`, которое создаёт и использует __FFI__ (_Foreign Function Interface_). __FFI__ - способ __ЯП__ определять функции и возможность использовать функции из других __ЯП__.

Пример ниже - интеграция функции из стандартной библиотеки _C_. Функции, объявленные через `extern`, всегда небезопасны для вызова.

`src/main.rs`:

```rust
extern "C" {
    fn abs(input: i32) -> i32;
}

fn main() {
    unsafe {
        println!("Absolute value of -3 accoding to C: {}", abs(-3));
    }
}
```

Внутри `extern "C"` мы перечисляем имена и сигнатуры внешних функций из других __ЯП__. Где `"C"` - определение __ABI__ (_application binary interface_), используемого внешней функцией: __ABI__ определяет, как вызывать функцию на уровне ассемблера.

> __Вызов функций _Rust_ из других ЯП__
> Мы можем использовать `extern`, чтобы создать интерфейс, который позволит другим языкам вызывать функции _Rust_. Вместо создания целого блока `extern`, мы добавляем ключевое слово `extern` и определяем __ABI__ для использования прямо перед ключевым словом `fn` соответствующей функции. Нам также нужно добавить аннотацию `#[no_mangle]`, чтобы компилятор не "покалечил" имя функции. "Покалечить" в данном контексте - это значит изменить имя функции на иное, не человеко-читаемое, содержащее больше информации для других частей процесса компиляции. Компиляторы любых языков программирования "калечат" имена функций по-своему.
> В примере ниже мы сделаем функцию `call_from_c()` доступной для вызова из _C_ после компиляции её в библиотеку и линковкой из _C_:

```rust
#[no_mangle]
pub extern "C" fn call_from_c() {
    println!("Just called a Rust function from C!");
}
```

__Доступ к или модификация мутабельных статических переменных__

Доступ двух потоков к одной мутабельной глобальной переменной может привести к состоянию гонок.

В _Rust_ глобальные переменные называются _статическими_.

`src/main.rs`:

```rust
static HELLO_WORLD: &str = "Hello, world!";

fn main() {
    println!("name is: {}", HELLO_WORLD);
}
```

Статические переменные могут хранить ссылки только со временем жизни `'static`.

Разница между константой и статической переменной в том, что статическая переменная имеет фиксированный адрес в памяти. Константы могут дублировать свои данные в тех местах, где они используются. Ещё одно отличие - статические переменные могут изменяться. Доступ к и модификация статических переменных _небезопасны_

`src/main.rs`:

```rust
static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!("COUNTER: {}", COUNTER);
    }
}
```

__Реализация небезопасного трейта__

`unsafe` можно использовать для реализации небезопасного трейта. Трейт небезопасен, когда хотя бы один из его методов имеет некоторый инвариант, который компилятор не может подтвердить.

```rust
unsafe trait Foo {
// ...
}

unsafe impl Foo for i32 {
// ...
}

fn main() {}
```

Как пример, трейты `Sync` и `Send`: если мы имплементируем тип, который не содержит данных трейтов (сырые указатели) и хотим их пометить, как `Send` или `Sync`, мы должны использовать `unsafe`.

__Доступ к полям объединений__

`union` схож со `struct`, но только одно указанное поле используется в экземпляре в конкретный момент времени. Объединения в основном используются в качестве интерфейса к объединениям из _C_.  Доступ к полям в объединениях небезопасен, поэтому следует помечать это действие, как `unsafe` (_Rust_ не знает, какой именно тип данных в данный момент хранится в объединении).

### 19.2. Продвинутые "трейты"

__Определения замещающих типов в опреденениях трейтов при помощи ассоциированных типов__

_Ассоциированные типы_ соединяют плейсхолдер типа с трейтом так, что определения методов трейта могут использовать эти плейсхолдеры типов в сигнатурах. Тот, кто имплементирует трейт, должен указать конкретный тип для использования вместо плейсхолдера для частного случая реализации. Таким образом, мы можем определить трейт, который использует некоторые типы без необходимости знать о том, какими данные типы являются, пока трейт не реализован.

Пример трейта с ассоциированным типом - `Iterator`. Ассоциированный тип именуется, как `Item` и представляет тип для значений, типы которых реализуют трейт `Iterator`:

```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;
}
```

`Item` - плейсхолдер, определение `.next()` показывает, что он вернёт значения типа `Option<Self::Item>`. Реализующие трейт `Iterator` должны указать, какой конкретный тип будет заменять `Item`, а метод `.next()` вернёт `Option`, содержащий значение данного конкретного типа.

Код ниже будет сравниваться с обобщениями типов. Реализация `Iterator` на типе `Counter`, который определяет `Item`, как `u32`.

`src/lib.rs`:

```rust
impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
// ...
```

Далее - попытка использовать обобщения:

```rust
pub trait Iterator<T> {
    fn next(&mut self) -> Option<T>;
}
```

Разница здесь будет в том, что при использовании обобщённых типов, мы должны аннотировать типы в каждой имплементации; поскольку мы можем также реализовать `Iterator<String>` для `Counter` или любого другого типа, мы можем иметь несколько имплементаций `Iterator` для `Counter`. Иными словами, когда трейт имеет обобщённый параметр, он может быть реализован для типа несколько раз, меняя конкретные типы параметров обобщённого типа каждый раз. И потому, при использовании `.next()` на `Counter`, нам бы пришлось предоставить аннотацию типа, чтобы показать, какую реализацию `Iterator` мы хотим использовать.

С ассоциированными типами нам не нужно аннотировать типы, поскольку мы не можем реализовать трейт для типа несколько раз. Для примера выше нам не нужно будет указывать каждый раз, что мы хотим итератор для значений типа `u32`, когда вызываем `.next()` на `Counter`.

__Стандартные обобщённые типы параметров и перегрузка операторов__

При использовании параметров обобщённого типа, мы можем указать стандартный конкретный тип для обобщённого типа. Это упраздняет необходимость имплементации трейта, чтобы указать конкретный тип, если работает стандартный. Указать стандартный тип можно при объявлении обобщённого типа синтаксисом `<PlaceholderType=ConcreteType>`.

Отличный пример, где данная техника может быть полезна - _перегрузка операторов_, когда можно кастомизировать поведение операторов (`+`, `-` и т.д.) для частных случаев.

Можно перегрузить операции и соответствующие трейты, перечисленные в `std::ops`, имплементируя трейты, ассоциированные с оператором. В примере ниже мы перегружаем `+` так, чтобы он мог складывать два экземпляра `Point` вместе. Делается это имплементацией трейта `Add` на структуре `Point`.

`src/main.rs`:

```rust
use std::ops::Add;

#[derive(Debug, Copy, Clone, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -> Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(
        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
        Point { x: 3, y: 3 }
    );
}
```

`.add()` принимает значения `x` и `y` двух `Point`, чтобы сложить их и создать новую структуру `Point` с суммой значений в полях. `Add` имеет ассоциированный тип, именуемый `Output`, который определяет тип, возвращаемый из `.add()`.

Стандартный обобщённый тип в этом коде внутри трейта `Add`. Вот его определение:

```rust
trait Add<Rhs=Self> {
    type Output;

    fn add(self, rhs: Rhs) -> Self::Output;
}
```

Трейт с одним методом и ассоциированный тип. Синтаксис `Rhs=Self` - _параметры стандартного типа_. `Rhs` (_right hand side_) определяет тип параметра `rhs` метода `.add()`. Если мы не определим конкретный тип для `Rhs`, когда будем имплементировать трейт `Add`, тип `Rhs` станет по-умолчанию `Self`, который будет типом, на котором имплементируем `Add`.

Ниже пример использования `Rhs`. У нас две структуры: `Millimeters` и `Meters`, содержащие значения в разных велечинах. Тонкая обёртка существующих типов в другую структуру известна, как _паттерн newtype_. Мы хотим, чтобы `Add` правильно конвертировал величины.

`src/lib.rs`:

```rust
use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add<Meters> for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -> Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
```

Два частых сценария использования:

 + Расширение типа без необходимости перелопачивать код
 + Кастомизация специфичных сценариев

__Полностью квалифицированный синтаксис для устранения неоднозначностей: вызов методов с одним именем__

Ничто не мешает трейту иметь метод с тем же именем, что и у метода другого трейта, как и использовать эти трейты на одном типе. Можно также реализовать метод для типа с тем же именем, что и у методов трейтов этого типа.

`src/main.rs`:

```rust
trait Pilot {
    fn fly(&self);
}

trait Wizard {
    fn fly(&self);
}

struct Human;

impl Pilot for Human {
    fn fly(&self) {
        println!("This is your captain speaking.");
    }
}

impl Wizard for Human {
    fn fly(&self) {
        println!("Up!");
    }
}

impl Human {
    fn fly(&self) {
        println!("*waving arms furiously*");
    }
}
```

При вызове `.fly()` на `Human` компилятор по-умолчанию вызывает метод, имплементированный для типа.

`src/main.rs`:

```rust
fn main() {
    let person = Human;
    person.fly();
}
```

Для вызова методов `.fly()` из трейтов мы должны их указать.

`src/main.rs`:

```rust
fn main() {
    let person = Human;
    Pilot::fly(&person);
    Wizard::fly(&person);
    person.fly();
}
```

Поскольку `.fly()` принимает параметр `self`, если бы мы имели два типа, которые имплементируют один трейт, _Rust_ сможет понять, какая имплементация трейта будет использоваться, исходя из типа `self`.

Тем не менее, ассоциированные функции, которые не являются методами, не имеют параметра `self`. В таких случаях, придётся использовать _полностью квалифицированный синтаксис_.

`src/main.rs`:

```rust
trait Animal {
    fn baby_name() -> String;
}

struct Dog;

impl Dog {
    fn baby_name() -> String {
        String::from("Spot")
    }
}

impl Animal for Dog {
    fn baby_name() -> String {
        String::from("puppy")
    }
}

fn main() {
    println!("A baby dog is called a {}", Dog::baby_name());
}
```

В примере выше `Dog::baby_name()` вызовет ассоциированную функцию, определённую в `Dog`.

Если изменить код и попытаться вызвать ассоциированную с трейтом функцию, компилятор выдаст ошибку (`Animal::baby_name()` не имеет параметра `self` и потому могут быть другие типы, которые имплементируют трейт `Animal`; _Rust_ не может определить, какую из имплементаций `Animal::baby_name()` мы хотим вызвать).

`src/main.rs`:

```rust
fn main() {
    println!("A baby dog is called a {}", Animal::baby_name());
}
```

В примере ниже используется полностью квалифицированный синтаксис для вызова функции `baby_name()` трейта `Animal`, реализованного для `Dog`.

`src/main.rs`:

```rust
fn main() {
    println!("A baby dog is called a {}", <Dog as Animal>::baby_name());
}
```

В общем, полностью квалифицированный синтаксис выглядит так:

```rust
<Type as Trait>::function(receiver_if_method, next_arg, ...);
```

__Использование супертрейтов для запроса функционала одного трейта при помощи другого трейта__

Иногда может понадобиться определить трейт, который зависит от другого трейта: чтобы тип имплементировал первый трейт, ему нужно имплементировать и второй. Это можно сделать так, что определение трейта сможет использовать ассоциированные элементы из второго трейта. Трейт, на определение которого опирается другой, называется для него _супертрейтом_.

К примеру, нам нужен такой вывод:

```
**********
*        *
* (1, 3) *
*        *
**********
```

В реализации `.outline_print()` мы хотим использовать функционал трейта `Display`. Тогда нам нужно указать, что трейт `OutlinePrint` будет работать только с теми типами, которые реализуют трейт `Display` и предоставляют функционал, необходимый для `OutlinePrint`. В определении трейта это можно сделать, указав `OutlinePrint: Display`.  Техника похожа на добавление привязки трейта к трейту.

`src/main.rs`:

```rust
use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&self) {
        let output = self.to_string();
        let len = output.len();
        println!("{}", "*".repeat(len + 4));
        println!("*{}*", " ".repeat(len + 2));
        println!("* {} *", output);
        println!("*{}*", " ".repeat(len + 2));
        println!("{}", "*".repeat(len + 4));
    }
}
```

Поскольку мы указади, что `OutlinePrint` требует `Display`, мы можем использовать `.to_string()`, которая автоматически имплементируется для любого типа, имплементирующего `Display`.

Пример ниже не скомпилируется, поскольку мы пытаемся реализовать `OutlinePrint` на типе, не имплементирующем `Display`.

`src/main.rs`:

```rust
struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
```

Для исправления, нам нужно реализовать `Display` на `Point`.

`src/main.rs`:

```rust
use std::fmt;

impl fmt::Display for Point {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}
```

__Использование паттерна newtype для реализации внешних трейтов на внешних типах__

Мы можем реализовать трейт на типе, если трейт или тип локальны по отношению к крэйту. Но это ограничение можно обойти, используя _паттерн newtype_, который создаёт новый тип в кортежной структуре (см. [[#5.1. Определение и инстанциирование структур]]). Кортежная структура будет иметь только одно поле и будет тонкой обёрткой вокруг типа, для которого мы хотим имплементировать трейт. Обёрточный тип локален к нашему крэйту и мы можем реализовать трейт на обёртке. _Newtype_ - термин, который берёт начало из __ЯП__ _Haskell_.

К примеру, мы хотим реализовать `Display` на `Vec<T>`, что не позволяют нам сделать правила напрямую, поскольку трейт `Display` и тип `Vec<T>` определены вне крэйта. Мы можем создать структуру `Wrapper`, которая содержит экземпляр `Vec<T>`; далее мы можем реализовать `Display` на `Wrapper` и использовать значение `Vec<T>`.

`src/main.rs`:

```rust
use std::fmt;

struct Wrapper(Vec<String>);

impl fmt::Display for Wrapper {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "[{}]", self.0.join(", "))
    }
}

fn main() {
    let w = Wrapper(vec![String::from("hello"), String::from("world")]);
    println!("w = {}", w);
}
```

Имплементация `Display` использует `self.0` для доступа ко внутреннему `Vec<T>`, поскольку `Wrapper`- кортежная структура, а `Vec<T>` - элемент с индексом `0` в кортеже.

Минус данного способа: `Wrapper` - новый тип, так что он не имеет методов, которые содержит значение внутри. Мы можем имплементировать все методы `Vec<T>` на `Wrapper`. Если мы хотим, чтобы этот новый обёрточный тип имел все методы внутреннего типа, нужно реализовать на нём трейт `Deref`, чтобы вернуть внутренний тип.

### 19.3. Продвинутые типы

__Использование паттерна newtype для безопасности типов и абстрагирования__

Паттерн newtype также полезен для статического принуждения значений на индикацию юнитов значения.

Его также можно использовать, чтобы абстрагировать некоторые детали реализации типа: новый тип может предоставить публичный __API__, который отличается от __API__ приватного внутреннего типа.

Также можно скрывать внутреннюю реализацию. К примеру, мы можем предоставить тип `People` для обёртки `HashMap<i32, String>`, который хранит __ID__ человека, ассоциированный с именем. Код, использующий `People` будет взаимодействовать только с публичным __API__, который мы предоставляем (напр., метод, который добавляет имя в набор `People`; данный код не обязательно должен знать, что мы ставим в соответствие именам __ID__ типа `i32` внутри). Паттерн newtype - легковесный способ добиться инкапсуляции.

__Создание синонимов типов при помощи алайасов типов__

_Алайас типа_ может дать новое имя существующему типу. Для этого используется ключевое слово `type`:

```rust
type Kilometers = i32;
```

`Kilometers` не является новым отдельным типом.

```rust
type Kilometers = i32;

let x: i32 = 5;
let y: Kilometers = 5;

println!("x + y = {}", x + y);
```

Основная причина использования синонимов - уменьшение повторений.

```rust
Box<dyn Fn() + Send + 'static>
```

```rust
let f: Box<dyn Fn() + Send + 'static> = Box::new(|| println!("hi"));

fn takes_long_type(f: Box<dyn Fn() + Send + 'static>) {
// ...
}

fn returns_long_type() -> Box<dyn Fn() + Send + 'static> {
// ...
}
```

Алайас `Thunk` для длинного определения типа сокращает количество кода:

```rust
type Thunk = Box<dyn Fn() + Send + 'static>;

let f: Thunk = Box::new(|| println!("hi"));

fn takes_long_type(f: Thunk) {
// ...
}

fn returns_long_type() -> Thunk {
// ...
}
```

Алайасы часто используются с `Result<T, E>`.

```rust
use std::fmt;
use std::io::Error;

pub trait Write {
    fn write(&mut self, buf: &[u8]) -> Result<usize, Error>;
    fn flush(&mut self) -> Result<(), Error>;

    fn write_all(&mut self, buf: &[u8]) -> Result<(), Error>;
    fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<(), Error>;
}
```

В примере выше `Result<..., Error>` повторяется очень часто. `std::io` имеет объявление алайаса для данного типа: 

```rust
type Result<T> = std::result::Result<T, std::io::Error>;
```

Поскольку определение в `std::io`, мы можем использовать полностью квалифицированный алайас `std::io::Result<T>`; так, `Result<T, E>` с `E` заполненняется, как `std::io::Error`. Сигнатуры функций трейта `Write` теперь выглядят так:

```rust
pub trait Write {
    fn write(&mut self, buf: &[u8]) -> Result<usize>;
    fn flush(&mut self) -> Result<()>;

    fn write_all(&mut self, buf: &[u8]) -> Result<()>;
    fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<()>;
}
```

__Тип never, который никогда не возвращается__

В _Rust_ есть специальный _пустой тип_ (_never_) `!`, не имеющий значения.

```rust
fn bar() -> ! {
// ...
}
```

Функции, возвращающие never, называются _расходящимися функциями_.

```rust
let guess: u32 = match guess.trim().parse() {
    Ok(num) => num,
    Err(_) => continue,
};
```

Ветви `match` всегда возвращают одинаковый тип, так что код ниже не сработает:

```rust
let guess = match guess.trim().parse() {
    Ok(_) => 5,
    Err(_) => "hello",
}
```

Тип `guess` должен быть и числом, и строкой для кода выше.

`continue` имеет значение `!`. Оно не возвращает значения, а передаёт контроль назад в верх цикла.

```rust
impl<T> Option<T> {
    pub fn unwrap(self) -> T {
        match self {
            Some(val) => val,
            None => panic!("called `Option::unwrap()` on a `None` value"),
        }
    }
}
```

В коде выше _Rust_ видит, что `val` имеет тип `T`, а `panic!()` имеет тип `!`, так что результат выражения `match` целиком - `T`.

Ещё одно выражение, имеющее тип `!` - цикл `loop`:

```rust
print!("forever ");

loop {
    print!("and ever ");
}
```

__Типы с динамическим размером и трейт `Sized`__

Типы с динамическим размером (__DST__, _dynamically sized types_) позволяют нам писать код, используя значения, размер которых мы можем знать только во время выполнения.

`str` - это __DST__. Мы не можем знать, насколько длинной будет строка до момента выполнения, что значит, что мы не можем создать переменную типа `str` и, мы не можем принять `str` в качестве аргумента. Код ниже не сработает:

```rust
let s1: str = "Hello there!";
let s2: str = "How's it going?";
```

Переменные `s1` и `s2` не имеют одинакового размера, тип `str` по этой причине определённого размера не имеет.

Мы можем комбинировать `str` с любыми типами указателей (`Box<str>`, `Rc<str>` и т.д.). Каждый трейт является типом с динамическим размером, на который мы можем ссылаться, используя имя трейта. К объектам трейта нам, как и в предыдущем примере, придётся образаться через указатели разного рода (`&dyn Trait`, `Box<dyn Trait>`, `Rc<dyn Trait>` и т.д.).

Для работы с __DST__ _Rust_ предоставляет трейт `Sized`, чтобы определить, является ли размер типа известным на время компиляции. Данный трейт автоматически имплементируется для всего, размер чего известен во время компиляции. Вдобавок, `Sized` связывается со всеми обобщёнными функциями:

```rust
fn generic<T>(t: T) {
// ...
}
```

```rust
fn generic<T: Sized>(t: T) {
// ...
}
```

По-умолчанию, обобщённые функции сработают только на типах, размер которых известен во время компиляции. Но можно использовать специальный синтаксис для обхода данного ограничения:

```rust
fn generic<T: ?Sized>(t: &T) {
// ...
}
```

Привязка трейта на `?Sized` означает "`T` может быть, а может и не быть `Sized`". Синтаксис `?Trait` с данным значением доступен только для трейта `Sized`.

Ещё в примере выше мы сменили тип параметра `t` с `T` на `&T`. Поскольку тип может и не быть `Sized`, нам нужно использовать его опосредованно через какой-нибудь указатель (в данном случае этот указатель является ссылкой).

### 19.4. Продвинутые функции и замыкания

__Указатели на функции__

Обычные функции также можно передавать в качестве аргументов функций.

Тип `fn` - _указатель на функцию_.

Синтаксис для указания указателей на функцию в качестве параметра похож на синтаксис при использовании замыканий в качестве параметров. В примере ниже `do_twice()` принимает два параметра: указатель на любую функцию, принимающую `i32` в качестве параметра и возвращающую `i32` и одно значение `i32`.

`src/main.rs`:

```rust
fn add_one(x: i32) -> i32 {
    x + 1
}

fn do_twice(f: fn(i32) -> i32, arg: i32) -> i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!("The answer is: {}", answer);
}
```

В отличии от замыканий, `fn` - это тип, а не трейт, так что `fn` указывается в качестве параметра напрямую, а не указывается как параметр общего типа с привязкой к одному из трейтов `Fn`.

Указатель на функцию имплементирует все три трейта замыканий (`Fn`, `FnMut` и `FnOnce`), так что указатель на функцию всегда можно передать в качестве аргумента в функцию, ожидающую замыкание.

Один из примеров, когда лучше принять только `fn`, а не замыкание - это когда используется интерфейс со внешним кодом, который не имеет замыканий (к примеру, функции _C_ могут принимать функции в качестве аргументов, но _C_ не имеет замыканий).

Два примера ниже аналогичны. В первом используются замыкания, во втором - указатели на функции:

```rust
let list_of_numbers = vec![1, 2, 3];
let list_of_strings : Vec<String> =
    list_of_numbers.iter().map(|i| i.to_string()).collect();
```

```rust
let list_of_numbers = vec![1, 2, 3];
let list_of_strings: Vec<String> =
    list_of_numbers.iter().map(ToString::to_string).collect();
```

Имя каждого варианта перечисления также становится инициализатором функции. Мы можем использовать данные инициализирующие функции, как указатели на функции, которые имплементируют трейты замыканий, что значит, что мы можем указать инициализирующие функции в качестве аргументов методов, которые принимают замыкания:

```rust
enum Status {
    Value(u32),
    Stop,
}

let list_of_statuses: Vec<Status> = (0u32..20).map(Status::Value).collect();
```

Здесь мы создаём экземпляры `Status::Value`, используя каждое значение `u32` из диапазона, на которые вызывается `.map()`, использующий инициализирующую функцию `Status::Value()` в качестве аргумента.

__Возврат замыканий__

Замыкания представлены трейтами, что значит, что мы не можем вернуть из замыкания напрямую. В большинстве случаев, где нам может понадобиться вернуть трейт, можно, вместо этого, использовать конкретный тип, который имплементирует трейт, как возврат значения из функции. Тем не менее, этого нельзя сделать с замыканиями, поскольку они не имеют конкретного возвращаемого типа; нельзя использовать указатель на функцию `fn` в качестве возвращаемого типа.

Код ниже не скомпилируется:

```rust
fn returns_closure() -> dyn Fn(i32) -> i32 {
    |x| x + 1
}
```

_Rust_ не знает, сколько места нужно для хранения замыкания. Но можно использовать объект трейта:

```rust
fn returns_closure() -> Box<dyn Fn(i32) -> i32> {
    Box::new(|x| x + 1)
}
```

### 19.5. Макросы

В _Rust_ есть _декларативные_ макросы с `macro_rules!` и три типа _процедурных_ макросов:

 + Кастомный макрос `#[derive]`, определяющий код, добавленный с атрибутом `derive` на структурах и перечислениях
 + Атрибуто-подобные макросы, которые определяют кастомные атрибуты, используемые на любом элементе
 + Функцио-подобные макросы, которые похожи на вызовы функций, но оперируют на токенах, указанных в качестве аргументов

__Разница между макросами и функциями__

Макросы используются в _метапрограммировании_.

Макросы могут принимать переменное число параметров. Они расширяются до интерпретации кода компилятором.

Определять макрос и вводить его в область видимости нужно до его вызова.

__Декларативные макросы и `macro_rules!` для метапрограммирования__

Самый частоиспользуемый тип макросов в _Rust_ - _декларативный_ или просто _макрос_. В своей основе, макрос позволяет писать нечто подобное `match`. Паттерны сравниваются со структурами кода и, при совпадении, код из макроса заменяет их.

Для определения макроса нужно использовать конструкцию `macro_rules!`.

```rust
let v: Vec<u32> = vec![1, 2, 3];
```

Пример ниже - упрощённое определение макроса `vec!`:

`src/lib.rs`:

```rust
#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
```

Аннотация `#[macro_export]` показывает, что этот макрос должен быть доступен из любого крэйта, в котором макрос входит в область видимости.

Когда мы начинаем определение макроса с `macro_rules!` и именем макроса, после имени макроса не нужно указывать `!`. Далее следует определение макроса.

Структура тела `vec!` похожа на структуру выражения `match`. Здесь мы имеем одну ветвь с паттерном `( $( $x:expr ),* )` с последующим `=>` и блоком кода, ассоциированным с данным паттерном. Если паттерн совпадает, ассоциированный блок кода будет подставлен.

Паттерны макросов сравниваются со структурой кода _Rust_, а не со значениями.

В примере выше сначала используются скобки для охвата паттерна целиком. Мы используем `$` для объявления переменной в системе макросов, которая будет содержать код _Rust_, соответствующий паттерну. `$` означает, что это переменная макроса. Далее идут скобки, которые захватывают значения, которые совпадают с паттерном внутри скобок для использования в замещающем коде. Внутри `$()` - `$x:expr`, что подходит для любого выражения _Rust_ и именует выражение, как `$x`.

Запятая после `$()` означает, что разделительная запятая может опционально появиться после кода, совпадающего с кодом в `$()`. `*` указывает на то, что паттерн совпадает с нулём или более элементов, предшествующих `*`.

Когда мы вызывает этот макрос с `vec![1, 2, 3]`, паттерн `$x` совпадает трижды для трёх выражений `1`, `2` и `3`. Пример ниже раскрывает паттерн из примера:

```rust
{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}
```

__Процедурные макросы для генерации кода из атрибутов__

Ещё одна форма макросов - _процедурные макросы_, которые действуют подобно функциям. Процедурные макросы принимают некоторый код в качестве входа, оперируют над ним и продуцируют некоторый код в качестве вывода вместо проверки совпадений с паттернами и замены кода на другой, как это делают декларативные макросы. Три типа процедурных макросов: кастомные "выведенные" макросы, атрибуто-подобные и функцио-подобные, и все они работают примерно одинаково.

При создании процедурных макросов, определения должны находиться в собственных крэйтах со специальным типом крэйта. В примере ниже определяется процедурный макрос, в котором `some_attribute` - плейсхолдер для использования конкретного набора макросов.

`src/lib.rs`:

```rust
use proc_macro;

#[some_attribute]
pub fn some_name(input: TokenStream) -> TokenStream {
}
```

Функция, которая определяет процедурный макрос, принимает `TokenStream` в качестве входа и генерирует `TokenStream` в качестве вывода. Тип `TokenStream` определён крэйтом `proc_macro`, который включен в _Rust_ и представляет последовательность токенов. Это есть ядро макроса: исходный код, на котором оперирует макрос, составляет входной `TokenStram`, а выходной исходный код, генерируемый макросом, представлен выходным `TokenStream`. Функция также имеет привязанный атрибут, который указывает, какой тип процедурного макроса мы создаём. Мы можем иметь разные типы процедурных макросов в одном крэйте.

__Как написать макрос `derive`__

Попробуем создать крэйт `hello_macro`, который определяет трейт `HelloMacro` с одной ассоциированной функцией `hello_macro()`. Вместо того, чтобы заставлять пользователей реализовывать `HelloMacro` для всех пользовательских типов, мы предоставим процедурный макрос так, что пользователи смогут аннотировать их тип с `#[derive(HelloMacro)]`, чтобы получить стандартную имплементацию функции `hello_macro()`. Стандартная имплементация выведет `Hello, Macro! My name is TypeName`, где `TypeName` - имя типа, на котором был опеделён трейт (код ниже пока не скомпилируется).

`src/main.rs`:

```rust
use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}
```

Первый шаг - создать новый библиотечный крэйт:

```bash
cargo new hello_macro --lib
```

Далее определим трейт `HelloMacro` и его ассоциированную функцию.

`src/lib.rs`:

```rust
pub trait HelloMacro {
    fn hello_macro();
}
```

```rust
use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!("Hello, Macro! My name is Pancakes!");
    }
}

fn main() {
    Pancakes::hello_macro();
}
```

Тем не менее, пользователям придётся писать имплементацию для каждого типа, который они захотят использовать с `hello_macro`.

Мы также пока не можем предоставить `hello_macro()` без стандартной имплементации, которая выведет имя функции, на которой реализован трейт: _Rust_ не имеет возможностей рефлекции, так что он не может найти имя типа во время выполнения. Нам нужен макрос для генерации кода во время компиляции.

Следующий шаг - реализация процедурного макроса. По соглашению, для крэйта с именем `foo`, крэйт кастомного процедурного макроса называется `foo_derive`:

```bash
cargo new hello_macro_derive --lib
```

Мы создаём крэйт процедурного макроса в крэйте `hello_macro`.

`hello_macro_derive` должен быть объявлен, как крэйт процедурного макроса. Нам также понадобится функционал крэйтов `syn` и `quote`.

`hello_macro_derive/Cargo.toml`:

```toml
[lib]
pro-macro = true

[dependencies]
syn = "1.0"
quote = "1.0"
```

Код определения процедурного макроса ниже не скомпилируется, пока не добавим определение функции `impl_hello_macro()`.

`hello_macro_derive/src/lib.rs`:

```rust
use proc_macro::TokenStream;
use quote::quote;
use syn;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -> TokenStream {
// Конструирование представления кода Rust, как синтаксическое дерево,
// которым мы можем манипулировать
    let ast = syn::parse(input).unwrap();

// Сборка реализации трейта
    impl_hello_macro(&ast)
}
```

Мы разделили код на `hello_macro_derive()`, которая ответственна за парсинг `TokenStream` и `impl_hello_macro()`, которая ответственна для трансформацию дерева синтаксиса. Код во внешней функции (`hello_macro_derive()`) будет тем же почти для каждого крэйта процедурного макроса. Код, указанный в теле внешней функции (`impl_hello_macro()`) будет отличатся в зависимости от назначения процедурного макроса.

Крэйт `proc_macro` - __API__ компилятора, который помогает читать и манипулировать над кодом _Rust_ из нашего кода.

Крэйт `syn` парсит код _Rust_ из строки в структуры данных, над которыми мы можем выполнять операции. Крэйт `quote` превращает данные `syn` обратно в код _Rust_.

`hello_macro_derive()` вызывается, когда пользователь нашей библиотеки указывает `#[derive(HelloMacro)]` для типа. Это возможно, поскольку мы аннотировали `hello_macro_derive()` с `proc_macro_derive` и указали имя `HelloMacro`, что совпадает с именем трейта; этому соглашению соответствует большинство процедурных макросов.

`hello_macro_derive()` сначала конвертирует `input` из `TokenStream` в структуру данных, которую мы затем интерпретируем и над которой выполняем операции. Для этого пригождается `syn`. `parse()` из `syn` принимает `TokenStream` и возвращает структуру `DeriveInput`, представляющую обработанный код _Rust_. Пример ниже - экземпляр `DeriveInput`, полученный после обработки кода:

```rust
DeriveInput {
// ...

    ident: Ident {
        ident: "Pancakes",
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}
```

Поля этой структуры показывают, что код _Rust_, который мы распарсили - структура `ident` `Pancakes`'ов. В этой структуре много других полей, описывающих код _Rust_ (см. документацию `syn`).

Далее мы определим `impl_hello_macro()`, в которой мы собираем новый код _Rust_, который хотим включить. Но прежде, стоит заметить, что возврат для нашего макроса - также `TokenStream`. Вернувшийся `TokenStream` добавляется к коду, который пишут пользователи нашего крэйта, так что когда они компилируют свой крэйт, у них будет дополнительный функционал, который мы предоставляем в модифицированном `TokenStream`.

Мы вызываем `.unwrap()`, чтобы `hello_macro_derive()` запаниковала, если вызов `syn::parse()` "завалится". Это важно для нашего процедурного макроса, поскольку функции `proc_macro_derive()` должны вернуть `TokenStream`, а не `Result`, чтобы соответствовать __API__ процедурных макросов. Можно использовать `panic!` или `expect`.

Теперь, когда у нас есть код, чтобы превратить аннотированный код _Rust_ из `TokenStream` в `DeriveInput`, сгенерируем код, имплементирующий трейт `HelloMacro` на аннотированном типе.

`hello_macro_derive/src/lib.rs`:

```rust
fn impl_hello_macro(ast: &syn::DeriveInput) -> TokenStream {
    let name = &ast.ident;
    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!("Hello, Macro! My name is {}!", stringify!(#name));
            }
        }
    };
    gen.into()
}
```

Мы получаем экземпляр структуры `Ident`, содержащий имя (идентификвтор) аннотированного типа, используя `ast.ident`. Когда мы запускаем `impl_hello_macro()`, `ident`, который мы получаем, имеет поле `ident` со значением `"Pancakes"`. Так, переменная `name` будет содержать экземпляр структуры `Ident`, которая при печати будет строкой `"Pancakes"`.

Макрос `quote!` позволяет определить код _Rust_, который мы хотим вернуть. Компилятор ожидает чего-то отличного от прямого результата выполнения `quote!`, так что нам нужно конвертировать его в `TokenStream`. Делается это вызовом `.into()`, который поглощает это промежуточное представление и возвращает значение типа `TokenStream`.

`quote!` также предоставляет интересный механизм: мы можем ввести `#name` и `quote!` заменит его на значение в переменной `name` (см. документацию `quote`).

Мы хотим, чтобы наш процедурный макрос генерировал реализацию трейта `HelloMacro` для типа, который обозначил пользователь, который мы можем получить, используя `#name`. Имплементация трейта имеет одну функцию `hello_macro()`, тело которой содержит функционал, который мы хотим предоставить: печать `Hello, Macro! My name is ` и далее имя обозначенного типа.

Макрос `stringify!` используется здесь, но он встроен в _Rust_. Он принимает выражение _Rust_ (напр., `1 + 2`) и, во время компиляции, превращает выражение в строковую литеру (`"1 + 2"`). Это отличается от `format!` или `println!`, которые раскрывают выражение и затем превращают результат в `String`. Есть вероятность, что `#name` будет выражением, которое нужно напечатать буквально, потому используется `stringify!`. `stringify!` также экономит память, конвертируя `#name` в строковой литер во время компиляции.

Теперь `cargo build` должен успешно скомпилировать `hello_macro` и `hello_macro_derive`. Если `hello_macro` и `hello_macro_derive` не были выложены в _crates.io_, их можно указать через `path`, как регулярные зависимости.

```rust
hello_macro = { path = "../hello_macro" }
hello_macro_derive = { path = "../hello_macro/hello_macro_derive" }
```

__Атрибуто-подобные макросы__

Атрибуто-подобные макросы схожи с derive-макросами, но вместо генерации кода для атрибута `derive`, они позволяют создавать новые атрибуты. Они также более гибкие: `derive` работает только со структурами и перечислениями; атрибуты могут быть применены и к другим объектам (напр., к функциям). В примере ниже мы используем атрибут `route`, аннотирующий функции, когда используется фреймворк веб-приложений:

```rust
#[route(GET, "/")]
fn index() {
```

Атрибут `#[route]` будет определён фреймворком, как процедурный макрос. Сигнатура определения макроса функции будет выглядеть так:

```rust
#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {
```

Здесь у нас два параметра типа `TokenStream`. Первый для содержимого атрибута: `GET, "/"`. Второй - тело элемента, к которому присовокупляется атрибут; в данном случае - `fn index() {}` и тело функции.

__Функцио-подобные макросы__

Функцио-подобные макросы похожи на вызовы функций. Как и `macro_rules!`, они более гибкие, чем функции; к примеру, они могут принять неопределённое число аргументов. Но `macro_rules!` может быть определён `match`-подобным синтаксисом. Функцио-подобные макросы принимают параметр `TokenStream` и их определение манипулирует над этим `TokenStream`, используя код _Rust_, как другие типы процедурных макросов. Пример:

```rust
let sql = sql!(SELECT * FROM posts WHERE id=1);
```

Данный макрос распарсит выражение _SQL_ внутри и проверит, что он синтаксически верен, что является более сложной обработкой, чем может сделать `macro_rules!`. Макрос `sql!` определяется примерно так:

```rust
#[proc_macro]
pub fn sql(input: TokenStream) -> TokenStream {
```

## 20. Заключительный проект: многопоточный Web-сервер

### 20.1. Однопоточный Web-сервер

### 20.2. Превращение однопоточного сервера в многопоточный

### 20.3. Завершение работы и очистка

## 21. Приложение

### 21.1. A - Ключевые слова

 + `as` - примитивное преобразование, устранение неоднозначностей для трейтов или переименование объектов в объявлениях `use`
 + `async` - вернуть `Future` вместо блокирования текущего потока
 + `await` - приостановить выполнения до готовности результата `Future`
 + `break` - остановить цикл
 + `const` - определить константу или сделать сырые указатели константами
 + `continue` - перейти к следующей итерации цикла
 + `crate` - в пути модуля, ссылается на корень крэйта
 + `dyn` - динамическая передача трейту
 + `else` - ветвь для конструкций `if` и `if let`
 + `enum` - определение перечисления
 + `extern` - связать внешнюю функцию или переменную
 + `false` - булево значение "ложь"
 + `fn` - определение функции или указателя на функцию
 + `for` цикл, проходящий итератором по набору; имплементация трейта; спецификация высокорангового времени жизни
 + `if` ветвь, зависящая от результата условного выражения
 + `impl` - имплементация наследуемой или "трейтовой" функциональности
 + `in` - часть цикла `for`
 + `let` - определение переменной
 + `loop` - безусловный цикл
 + `match` - сравнить значения с паттернами
 + `mod` - определить модуль
 + `move` - заставить замыкание брать владение над всем, что в него входит
 + `mut` - определить мутабельность для ссылок, сырых указателей или ассоциаций паттернов
 + `pub` - определить публичную видимость для полей структур, блоков в `impl` или модулей
 + `ref` - ассоциировать при помощи ссылки
 + `return` - возврат из функции
 + `Self` - алиас типа для типа, имплементацию которого мы определяем
 + `self` - субъект метода или текущего модуля
 + `static` - глобальная переменная или переменная со временем жизни в выполнение всей программы
 + `struct` - определение структуры
 + `trait` - определение трейта
 + `true` - булево значение "истина"
 + `type` - определить алайас типа или ассоциированный тип
 + `union` - определить объединение
 + `unsafe` - обозначить небезопасный код, функции, трейты или имплементации
 + `use` - принести символы в область видимости
 + `where` - определить пункты, ограничивающие типы
 + `while` - условный цикл

Сырые идентификаторы (`r#<идентификатор>`) позволяют использовать в качестве идентификаторов ключевые слова, например:

```rust
fn r#match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match("foo", "foobar"));
}
```

### 21.2. B - Операторы и символы

__Операторы__

| Оператор | Пример | Описание | Перегружаемо? |
| - | - | - | - |
| `!` | `ident!(...)`, `ident!{...}`, `ident![...]` | Раскрытие макроса | |
| `!` | `!expr` | Побитовое или логическое отрицание | `Not` |
| `!=` | `expr != expr` | Сравнение на неравенство | `PartialEq` |
| `%` | `expr % expr` | Арифметический остаток | `Rem` |
| `%=` | `var %= expr` | Присвоение вычисленного арифметического остатка | `RemAssign` |
| `&` | `&expr`, `&mut expr` | Заимствование | |
| `&` | `&type`, `&mut type`, `&'a type`, `&'a mut type` | Тип заимствованного указателя | |
| `&` | `expr & expr` | Побитовое И | `BitAnd` |
| `&=` | `var &= expr` | Присвоение вычисленного побитового И | `BitAndAssign` |
| `&&` | `expr && expr` | Логическое И | |
| `*` | `expr * expr` | Умножение | `Mul` |
| `*=` | `var *= expr` | Присвоение с умножением | `MulAssign` |
| `*` | `*expr` | Разыменование | `Deref` |
| `*` | `*const type`, `*mut type` | Сырой указатель | |
| `+` | `trait + trait`, `'a + trait` | Ограничение составного типа | |
| `+` | `expr + expr` | Сложение | `Add` |
| `+=` | `var += expr` | Присвоение со сложением | `AddAssign` |
| `,` | `expr, expr` | Разделение аргументов и элементов | |
| `-` | `- expr` | Арифметическое отрицание | `Neg` |
| `-` | `expr - expr` | Вычитание | `Sub` |
| `-=` | `var -= expr` | Присвоение с вычитанием | `SubAssign` |
| `->` | `fn(...) -> type`, `|...| -> type` | Возвращаемый тип функций и замыканий |
| `.` | `expr.ident` | Доступ к члену | |
| `..` | `..`, `expr..`, `..expr`, `expr..expr` | Исключающий границы интервал диапазона | `PartialOrd` |
| `..=` | `..=expr`, `expr..=expr` | Включающий границы интервал диапазона | `PartialOrd` |
| `..` | `..expr` | Обновление структуры | |
| `..` | `variant(x, ..)`, `struct_type { x, ..}` | Паттерн "и остальные" | |
| `...` | `expr...expr` | (Не используется, использовать `..=`) паттерн инклюзивного диапазона | |
| `/` | `expr / expr` | Деление | `Div` |
| `/=` | `var /= expr` | Присвоение с делением | `DivAssign` |
| `:` | `pat: type`, `ident: type` | Ограничение | |
| `:` | `ident: expr` | Инициализация поля структуры | |
| `:` | `'a: loop {...}` | Метка цикла | |
| `;` | `expr;` | Терминатор заявления или объекта | |
| `;` | `[...; len]` | Часть синтаксиса определения массива | |
| `<<` | `expr << expr` | Побитовый сдвиг влево | `Shl` |
| `<<=` | `var <<= expr` | Побитовый сдвиг влево с присвоением | `ShlAssign` |
| `<` | `expr < expr` | Сравнение "меньше, чем" | `PartialOrd` |
| `<=` | `expr <= expr` | Сравнение "меньше или равно" | `PartialOrd` |
| `=` | `var = expr`, `ident = type` | Присвоение/эквивалент | |
| `==` | `expr == expr` | Сравнение "равно" | `PartialEq` |
| `=>` | `pat => expr` | Часть синтаксиса для `match` | |
| `>` | `expr > expr` | Сравнение "больше, чем" | `PartialOrd` |
| `>=` | `expr >= expr` | Сравнение "больше или равно" | `PartialOrd` |
| `>>` | `expr >> expr` | Побитовый сдвиг вправо | `Shr` |
| `>>=` | `var >>= expr` | Побитовый сдвиг вправо с присвоением | `ShrAssign` |
| `@` | `ident @ pat` | Связывание паттерна | |
| `^` | `expr ^ expr` | Исключающее ИЛИ | `BitXor` |
| `^=` | `var ^= expr` | Исключающее ИЛИ с присвоением | `BitXorAssign` |
| \| | pat \| pat | Альтернатива паттерна | |
| \| | expr \| expr | Побитовое ИЛИ | `BitOr` |
| \|= | var \|= expr | Побитовое ИЛИ с присвоением | `BitOrAssign` |
| `?` | `expr?` | Распространение ошибки | |

__Неоперативные символы__

| Символ | Описание |
| - | - |
| `'ident` | Именованное время жизни или метка цикла |
| `...u8`, `...i32`, `...f64`, `...usize` и т.д. | Числовой литерал или специфичный тип |
| `"..."` | Строковой литерал |
| `r"..."`, `r#"..."#`, `r##"..."##` и т.д. | Сырой строковой литерал, эскейп-последовательности не обрабатываются |
| `b"..."` | Литерал байтовой строки; конструирует массив байт вместо строки |
| `br"..."`, `br#"..."#`, `br##"..."##` и т.д. | Сырой байтовый строчный литерал; комбинация сырого и байтового строкового литерала |
| `'...'` | Символьный литерал |
| `b'...'` | ASCII байт |
| \|...\| expr | Замыкание |
| `!` | Всегда пустое дно для расходящихся функций |
| `_` | "Игнорируемый" паттерн. Также разделитель для чиловых литералов |

Пути:

| Символ | Описание |
| - | - |
| `ident::ident` | Путь пространства имён |
| `::path` | Путь относительный к корню крэйта (абсолютный) |
| `self::path` | Путь относительный к текущему модулю |
| `super::path` | Путь относительный к родителю текущего модуля |
| `type::ident`, `<type as trait>::ident` | Ассоциированные ограничения, функции и типы |
| `<type>::...` | Ассоциированный объект для типа, который не может быть напрямую назван (`<&T>::...`, `<[T]>::...` и т.д.) |
| `trait::method(...)` | Снятие неоднозначностей с вызова метода при помощи именования трейта, определяющего метод |
| `type::method(...)` | Именование типа для вызова метода |
| `<type as trait::method(...)` | Снятие неоднозначностей с вызова метода при помощи именования трейта и типа, определяющих метод |

Параметры общего типа:

| Символ | Описание |
| - | - |
| `path<...>` | Определение параметров для общего типа внутри типа (напр.: `Vec<u8>`) |
| `path::<...>`, `method::<...>` | Определение параметров для общего типа, функции или метода в выражении; _turbofish_ (напр.: `"42".parse::<i32>()`) |
| `fn ident <...> ...` | Определение общей функции |
| `struct ident<...> ...` | Определение общей структуры |
| `enum ident<...> ...` | Определение общего перечисления |
| `impl<...> ...` | Определение общей имплементации |
| `for<...> type` | Высокоранговые границы времени жизни |
| `type<ident=type>` | Общий тип, где один или более ассоциированных типов имеют специфичные присвоения (напр.: `Iterator<Item=T>`) |

Контекст использования ограничения параметров общего типа с границами трейтов:

| Символ | Описание |
| - | - |
| `T: U` | Общий параметр `T` ограниченный до типов, которые имплементирует `U` |
| `T: 'a` | Общий тип `T`, который должен пережить время жизни `'a` (тип не может переходно содержать любые ссылки со временем жизни короче, чем `'a`) |
| `T: 'static` | Общий тип `T`, который не может содержать заимствованных ссылок, кроме `'static` |
| `'b: 'a` | Общее время жизни `'b` должно продлиться дольше, чем `'a` |
| `T: ?Sized` | Допустить параметру общего типа возможность быть типом с динамическим размером |
| `'a + trait`, `trait + trait` | Ограничения составного типа |

Макросы и атрибуты:

| Символ | Описание |
| - | - |
| `#[meta]` | Внешний атрибут |
| `#![meta]` | Внутренний атрибут |
| `$ident` | Макроподстановка |
| `$ident:kind` | Макрозахват |
| `$(...)...` | Макроповтор |
| `ident!(...), ident!{...}, ident![...]` | Вызов макроса |

Комментарии:

| Символ | Описание |
| - | - |
| `//` | Строка с комментарием |
| `//!` | Внутренняя строка комментария документации |
| `///` | Внешняя строка комментария документации |
| `/*...*/` | Блок с комментарием |
| `/*!...*/` | Внутренний блок комментария документации |
| `/**...*/` | Внешний блок комментария документации |

Круглые скобки, кортежи:

| Символ | Описание |
| - | - |
| `()` | Юнит |
| `(expr)` | Выражение в скобках |
| `(expr,)` | Одноэлементное выражение кортежа |
| `(type,)` | Один тип для кортежа |
| `(expr, ...)` | Кортеж |
| `(type, ...)` | Тип кортежа |
| `expr(expr, ...)` | Вызов функции; также используется для инициализации кортежей, структур и кортежных перечислений |
| `expr.0`, `expr.1` и т.д. | Индексация в кортеже |

Фигурные скобки:

| Контекст | Описание |
| - | - |
| `{...}` | Выражение в блоке |
| `Type {...}` | Литерал структуры |

Квадратные скобки:

| Контекст | Описание |
| - | - |
| `[...]` | Литерал массива |
| `[expr; len]` | Литерал массива, содержащий `len` копий `expr` |
| `[type; len]` | Литерал массива, содержащий `len` реализаций `type` |
| `expr[expr]` | Индексация набора. Перегружаемо (`Index`, `IndexMut`) |
| `expr[..]`, `expr[a..]`, `expr[..b]`, `expr[a..b]` | Набор индексации; можно использовать, как слайс, используя `Range`, `RangeFrom`, `RangeTo` или `RangeFull`, как индекс |

### 21.3. C - Производные трейты

Атрибут `derive` генерирует код, который имплементирует трейт со своей стандартной реализацией на типе, который был аннотирован синтаксисом `derive`.

В этом аппендиксе рассмотрено следующее:

 + Какие операторы и методы, наследующие этот трейт, включены
 + Что делает имплементация трейта, предоставленного `derive`
 + Что говорит имплементация трейта о типе
 + Условия, при которых можно или нельзя имплементировать трейт
 + Примеры операций, которые требуют трейт

Трейты, перечисленные здесь, определены стандартной библиотекой так, что могут быть определены на наших типах с использованием `derive`. Остальные трейты стандартной библиотеки не имеют стандартного поведения, так что их реализация на плечах разработчика.

Пример непроизводного трейта - `Display`.

Библиотеки могут реализовать `derive` для собственных трейтов (см. [[#19.5. Макросы]]).

__`Debug` для вывода__

Трейт `Debug` включает отладочное форматирование в форматированных строках, что указывается, как `:?` без плейсхолдеров `{}`.

Трейт `Debug` позволяет печатать экземпляры типов для отладки.

`Debug`, к примеру, нужен при использовании `assert_eq!`. Этот макрос печатает значения экземпляров, переданных в качестве аргументов, если проверка равенства не сработает.

__`PartialEq` и `Eq` для сравнений неравенств__

`PartialEq` позволяет сравнивать экземпляры типа и проверять равенство, используя операторы `==` и `!=`.

`PartialEq` имплементирует метод `.eq()`. Когда `PartialEq` производится на структуре, два экземпляра равны только если _все_ поля структуры равны. При производной для перечисления, каждый вариант равен себе и неравен другим вариантам.

`PartialEq` может понадобиться при использовании `assert_eq!`, для которого нужно уметь сравнивать два экземпляра типа на равенство.

`Eq` не имеет методов. Его назначение - сигнализировать, что для каждого значения аннотированного типа, значение равно самому себе. `Eq` может быть применён только к типам, которые имплементируют `PartialEq`, но не все типы, которые имплементируют `PartialEq`, могут имплементировать `Eq`. Один пример - числа с плавающей точкой: имплементация чисел с плавающей точкой говорит о том, что два экземпляра значений `NaN` не равны друг другу.

Пример, когда `Eq` нужен - ключи в `HashMap<K, V>`, чтобы `HashMap<K, V>` мог сказать, что два ключа одинаковы.

__`PartialOrd` и `Ord` для сравнений порядков__

`PartialOrd` позволяет сравнивать экземпляры типов для сортировки. Тип, имплементирующий `PartialOrd` может быть использован с `<`, `>`, `<=` и `=>`. `PartialOrd` можно применять только к трейтам, которые имплементируют `PartialEq`.

`PartialOrd` имплементирует `.partial_cmp()`, который возвращает `Option<Ordering>`, который будет `None`, когда переданные значения не поддаются сортировке (таким значением может быть `NaN` для чисел с плавающей точкой). Вызов `.partial_cmp()` с любым числом (включая `NaN`) с плавающей точкой вернёт `None`.

`PartialOrd` на структурах сравнивает два экземпляра, сравнивая значения в каждом поле в порядке, в котором поля появляются в определении структуры. Для перечислений, их варианты указанные раньше, в определении, считаются меньшими, чем варианты, перечисленные позже.

`PartialOrd` нужен, к примеру, для метода `.gen_range()` из крэйта `rand`, который генерирует случайное значение из диапазона.

`Ord` позволяет удостовериться, что для двух любых значений аннотированного типа, будет существовать определённый порядок. `Ord` имплементирует метод `.cmp()`, который возвращает `Ordering`, а не `Option<Ordering>`, поскольку валидный порядок всегда возможен. `Ord` можно применить только к типам, которые имплементируют `PartialOrd` и `Eq` (`Eq`, в свою очередь, требует `PartialEq`). Для структур и перечислений, `.cmp()` ведёт себя, как `.partial_cmp()` с `PartialOrd`.

Пример, когда нужен `Ord` - хранение значений в `BTreeSet<T>` (структура данных, хранящая их в зависимости от порядка сортировки значений).

__`Clone` и `Copy` для дублирования значений__

`Clone` позволяет создать глубокую копию значения, а процесс дублирования может включать в себя код и копирование данных из кучи (см. [[#4. "Владение"]]).

`Clone` имплементирует `.clone()`, который при имплементации на типе целиком, вызывает `.clone()` для каждой части типа. Это значит, что все поля или значения в типе также должны имплементировать `Clone`.

Пример, когда `Clone` может понадобиться - вызов `.to_vec()` на слайсе. Слайс не владеет экземпляром хранимого типа, но вектор, возвращаемый из `.to_vec()`, должен владеть своими экземплярами, так что `.to_vec()` вызывает `.clone()` на каждом элементе.

`Copy` позволяет дублировать значение только копируя части, хранящиеся в стеке; произвольный код не нужен.

`Copy` не определяет новых методов, чтобы не дать программистам возможность перегрузить их, нарушив положения о том, что произвольный код не должен быть запущен.

`Copy` можно использовать на любом типе, производным для всех элементого которого может быть `Copy`. Также производным должен быть `Clone`, поскольку тип, имплементирующий `Copy`, имеет тривиальную имплементацию `Clone`, который выполняет ту же задачу, что и `Copy`.

`Copy` редко требуется; типы, имплементирующие `Copy` имеют оптимизацию, что значит, что не обязательно вызывать `.clone()`.

Всё, что можно сделать при помощи `Copy`, можно сделать и при помощи `Clone`, но код может быть медленнее или придётся часто использовать `.clone()`.

__`Hash` для отображения значений на значения фиксированного размера__

`Hash` позволяет взять экземпляр типа произвольного размера и отобразить этот экземпляр на значение фиксированного размера, используя функцию хэширования. `Hash` имплементирует метод `.hash()`. Производная имплементация `.hash()` комбинирует результат вызова `.hash()` на каждые части типа, т.е. все поля или значения также должны имплементировать `Hash`.

Пример использования - хранение ключей в `HashMap<K, V>` для эффективного хранения данных.

__`Default` для типов "по-умолчанию"__

`Default` позволяет создать значение по-умолчанию для типа. Производная `Default` имплементирует функцию `default()`. Производная имплементация вызовов функции `default()` вызывает `default()` на каждой части типа, что значит, что все поля или значения должны имплементировать `Default`.

`Default::default()` часто используется в комбинации с синтаксисом обновления структур (см. [[#5.1. Определение и инстанциирование структур]]). Можно кастомизировать несколько полей структуры и затем установить и использовать стандартные значения для оставшихся полей, используя `..Default::default()`.

`Default`, к примеру, нужен при использовании метода `unwrap_or_default()` на `Option<T>`. Если `Option<T>` - `None`, метод вернёт результат `Default::default()` для типа `T`, хранящегося в `Option<T>`.

### 21.4. D - Полезные инструменты разработки

### 21.5. E - Издания

### 21.6. F - Переводы книги

### 21.7. G - Как сделаны _Rust_ и _Nightly Rust_

## Ссылки

https://doc.rust-lang.org/book/title-page.html
https://doc.rust-lang.org/reference/macros-by-example.html
https://veykril.github.io/tlborm/
https://doc.rust-lang.org/stable/reference/

#rust #development #programming